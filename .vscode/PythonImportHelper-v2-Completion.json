[
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "gtimer",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gtimer",
        "description": "gtimer",
        "detail": "gtimer",
        "documentation": {}
    },
    {
        "label": "BaseRLAlgorithm",
        "importPath": "maple.core.rl_algorithm",
        "description": "maple.core.rl_algorithm",
        "isExtraImport": true,
        "detail": "maple.core.rl_algorithm",
        "documentation": {}
    },
    {
        "label": "BaseRLAlgorithm",
        "importPath": "maple.core.rl_algorithm",
        "description": "maple.core.rl_algorithm",
        "isExtraImport": true,
        "detail": "maple.core.rl_algorithm",
        "documentation": {}
    },
    {
        "label": "ReplayBuffer",
        "importPath": "maple.data_management.replay_buffer",
        "description": "maple.data_management.replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.replay_buffer",
        "documentation": {}
    },
    {
        "label": "ReplayBuffer",
        "importPath": "maple.data_management.replay_buffer",
        "description": "maple.data_management.replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.replay_buffer",
        "documentation": {}
    },
    {
        "label": "ReplayBuffer",
        "importPath": "maple.data_management.replay_buffer",
        "description": "maple.data_management.replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.replay_buffer",
        "documentation": {}
    },
    {
        "label": "ReplayBuffer",
        "importPath": "maple.data_management.replay_buffer",
        "description": "maple.data_management.replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.replay_buffer",
        "documentation": {}
    },
    {
        "label": "ReplayBuffer",
        "importPath": "maple.data_management.replay_buffer",
        "description": "maple.data_management.replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.replay_buffer",
        "documentation": {}
    },
    {
        "label": "ReplayBuffer",
        "importPath": "maple.data_management.replay_buffer",
        "description": "maple.data_management.replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.replay_buffer",
        "documentation": {}
    },
    {
        "label": "PathCollector",
        "importPath": "maple.samplers.data_collector",
        "description": "maple.samplers.data_collector",
        "isExtraImport": true,
        "detail": "maple.samplers.data_collector",
        "documentation": {}
    },
    {
        "label": "PathCollector",
        "importPath": "maple.samplers.data_collector",
        "description": "maple.samplers.data_collector",
        "isExtraImport": true,
        "detail": "maple.samplers.data_collector",
        "documentation": {}
    },
    {
        "label": "StepCollector",
        "importPath": "maple.samplers.data_collector",
        "description": "maple.samplers.data_collector",
        "isExtraImport": true,
        "detail": "maple.samplers.data_collector",
        "documentation": {}
    },
    {
        "label": "DataCollector",
        "importPath": "maple.samplers.data_collector",
        "description": "maple.samplers.data_collector",
        "isExtraImport": true,
        "detail": "maple.samplers.data_collector",
        "documentation": {}
    },
    {
        "label": "MdpPathCollector",
        "importPath": "maple.samplers.data_collector",
        "description": "maple.samplers.data_collector",
        "isExtraImport": true,
        "detail": "maple.samplers.data_collector",
        "documentation": {}
    },
    {
        "label": "MdpPathCollector",
        "importPath": "maple.samplers.data_collector",
        "description": "maple.samplers.data_collector",
        "isExtraImport": true,
        "detail": "maple.samplers.data_collector",
        "documentation": {}
    },
    {
        "label": "PathCollector",
        "importPath": "maple.samplers.data_collector",
        "description": "maple.samplers.data_collector",
        "isExtraImport": true,
        "detail": "maple.samplers.data_collector",
        "documentation": {}
    },
    {
        "label": "GoalConditionedPathCollector",
        "importPath": "maple.samplers.data_collector",
        "description": "maple.samplers.data_collector",
        "isExtraImport": true,
        "detail": "maple.samplers.data_collector",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Number",
        "importPath": "numbers",
        "description": "numbers",
        "isExtraImport": true,
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "maple.pythonplusplus",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "maple.pythonplusplus",
        "description": "maple.pythonplusplus",
        "detail": "maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "identity",
        "importPath": "maple.pythonplusplus",
        "description": "maple.pythonplusplus",
        "isExtraImport": true,
        "detail": "maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "identity",
        "importPath": "maple.pythonplusplus",
        "description": "maple.pythonplusplus",
        "isExtraImport": true,
        "detail": "maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "identity",
        "importPath": "maple.pythonplusplus",
        "description": "maple.pythonplusplus",
        "isExtraImport": true,
        "detail": "maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "identity",
        "importPath": "maple.pythonplusplus",
        "description": "maple.pythonplusplus",
        "isExtraImport": true,
        "detail": "maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "identity",
        "importPath": "maple.pythonplusplus",
        "description": "maple.pythonplusplus",
        "isExtraImport": true,
        "detail": "maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "identity",
        "importPath": "maple.pythonplusplus",
        "description": "maple.pythonplusplus",
        "isExtraImport": true,
        "detail": "maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "identity",
        "importPath": "maple.pythonplusplus",
        "description": "maple.pythonplusplus",
        "isExtraImport": true,
        "detail": "maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "nested_dict_to_dot_map_dict",
        "importPath": "maple.pythonplusplus",
        "description": "maple.pythonplusplus",
        "isExtraImport": true,
        "detail": "maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "dateutil.tz",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dateutil.tz",
        "description": "dateutil.tz",
        "detail": "dateutil.tz",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "importPath": "maple.core.tabulate",
        "description": "maple.core.tabulate",
        "isExtraImport": true,
        "detail": "maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "maple.core",
        "description": "maple.core",
        "isExtraImport": true,
        "detail": "maple.core",
        "documentation": {}
    },
    {
        "label": "eval_util",
        "importPath": "maple.core",
        "description": "maple.core",
        "isExtraImport": true,
        "detail": "maple.core",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "maple.core",
        "description": "maple.core",
        "isExtraImport": true,
        "detail": "maple.core",
        "documentation": {}
    },
    {
        "label": "append_log",
        "importPath": "maple.core.logging",
        "description": "maple.core.logging",
        "isExtraImport": true,
        "detail": "maple.core.logging",
        "documentation": {}
    },
    {
        "label": "add_prefix",
        "importPath": "maple.core.logging",
        "description": "maple.core.logging",
        "isExtraImport": true,
        "detail": "maple.core.logging",
        "documentation": {}
    },
    {
        "label": "add_prefix",
        "importPath": "maple.core.logging",
        "description": "maple.core.logging",
        "isExtraImport": true,
        "detail": "maple.core.logging",
        "documentation": {}
    },
    {
        "label": "add_prefix",
        "importPath": "maple.core.logging",
        "description": "maple.core.logging",
        "isExtraImport": true,
        "detail": "maple.core.logging",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "python_version_tuple",
        "importPath": "platform",
        "description": "platform",
        "isExtraImport": true,
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "SimpleReplayBuffer",
        "importPath": "maple.data_management.simple_replay_buffer",
        "description": "maple.data_management.simple_replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.simple_replay_buffer",
        "documentation": {}
    },
    {
        "label": "get_dim",
        "importPath": "maple.envs.env_utils",
        "description": "maple.envs.env_utils",
        "isExtraImport": true,
        "detail": "maple.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "maple.torch.pytorch_util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "maple.torch.pytorch_util",
        "description": "maple.torch.pytorch_util",
        "detail": "maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "set_gpu_mode",
        "importPath": "maple.torch.pytorch_util",
        "description": "maple.torch.pytorch_util",
        "isExtraImport": true,
        "detail": "maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "activation_from_string",
        "importPath": "maple.torch.pytorch_util",
        "description": "maple.torch.pytorch_util",
        "isExtraImport": true,
        "detail": "maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "activation_from_string",
        "importPath": "maple.torch.pytorch_util",
        "description": "maple.torch.pytorch_util",
        "isExtraImport": true,
        "detail": "maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "activation_from_string",
        "importPath": "maple.torch.pytorch_util",
        "description": "maple.torch.pytorch_util",
        "isExtraImport": true,
        "detail": "maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "normalize_image",
        "importPath": "multiworld.core.image_env",
        "description": "multiworld.core.image_env",
        "isExtraImport": true,
        "detail": "multiworld.core.image_env",
        "documentation": {}
    },
    {
        "label": "create_stats_ordered_dict",
        "importPath": "maple.core.eval_util",
        "description": "maple.core.eval_util",
        "isExtraImport": true,
        "detail": "maple.core.eval_util",
        "documentation": {}
    },
    {
        "label": "create_stats_ordered_dict",
        "importPath": "maple.core.eval_util",
        "description": "maple.core.eval_util",
        "isExtraImport": true,
        "detail": "maple.core.eval_util",
        "documentation": {}
    },
    {
        "label": "create_stats_ordered_dict",
        "importPath": "maple.core.eval_util",
        "description": "maple.core.eval_util",
        "isExtraImport": true,
        "detail": "maple.core.eval_util",
        "documentation": {}
    },
    {
        "label": "create_stats_ordered_dict",
        "importPath": "maple.core.eval_util",
        "description": "maple.core.eval_util",
        "isExtraImport": true,
        "detail": "maple.core.eval_util",
        "documentation": {}
    },
    {
        "label": "create_stats_ordered_dict",
        "importPath": "maple.core.eval_util",
        "description": "maple.core.eval_util",
        "isExtraImport": true,
        "detail": "maple.core.eval_util",
        "documentation": {}
    },
    {
        "label": "create_stats_ordered_dict",
        "importPath": "maple.core.eval_util",
        "description": "maple.core.eval_util",
        "isExtraImport": true,
        "detail": "maple.core.eval_util",
        "documentation": {}
    },
    {
        "label": "flatten_dict",
        "importPath": "maple.data_management.obs_dict_replay_buffer",
        "description": "maple.data_management.obs_dict_replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "ObsDictRelabelingBuffer",
        "importPath": "maple.data_management.obs_dict_replay_buffer",
        "description": "maple.data_management.obs_dict_replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "normalize_image",
        "importPath": "maple.data_management.obs_dict_replay_buffer",
        "description": "maple.data_management.obs_dict_replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "maple.data_management.shared_obs_dict_replay_buffer",
        "description": "maple.data_management.shared_obs_dict_replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.shared_obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "VAEWrappedEnv",
        "importPath": "maple.envs.vae_wrapper",
        "description": "maple.envs.vae_wrapper",
        "isExtraImport": true,
        "detail": "maple.envs.vae_wrapper",
        "documentation": {}
    },
    {
        "label": "VAEWrappedEnv",
        "importPath": "maple.envs.vae_wrapper",
        "description": "maple.envs.vae_wrapper",
        "isExtraImport": true,
        "detail": "maple.envs.vae_wrapper",
        "documentation": {}
    },
    {
        "label": "compute_p_x_np_to_np",
        "importPath": "maple.torch.vae.vae_trainer",
        "description": "maple.torch.vae.vae_trainer",
        "isExtraImport": true,
        "detail": "maple.torch.vae.vae_trainer",
        "documentation": {}
    },
    {
        "label": "relative_probs_from_log_probs",
        "importPath": "maple.torch.vae.vae_trainer",
        "description": "maple.torch.vae.vae_trainer",
        "isExtraImport": true,
        "detail": "maple.torch.vae.vae_trainer",
        "documentation": {}
    },
    {
        "label": "torch.multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.multiprocessing",
        "description": "torch.multiprocessing",
        "detail": "torch.multiprocessing",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "gym",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gym",
        "description": "gym",
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "ProxyEnv",
        "importPath": "maple.envs.proxy_env",
        "description": "maple.envs.proxy_env",
        "isExtraImport": true,
        "detail": "maple.envs.proxy_env",
        "documentation": {}
    },
    {
        "label": "ProxyEnv",
        "importPath": "maple.envs.proxy_env",
        "description": "maple.envs.proxy_env",
        "isExtraImport": true,
        "detail": "maple.envs.proxy_env",
        "documentation": {}
    },
    {
        "label": "ProxyEnv",
        "importPath": "maple.envs.proxy_env",
        "description": "maple.envs.proxy_env",
        "isExtraImport": true,
        "detail": "maple.envs.proxy_env",
        "documentation": {}
    },
    {
        "label": "ProxyEnv",
        "importPath": "maple.envs.proxy_env",
        "description": "maple.envs.proxy_env",
        "isExtraImport": true,
        "detail": "maple.envs.proxy_env",
        "documentation": {}
    },
    {
        "label": "ProxyEnv",
        "importPath": "maple.envs.proxy_env",
        "description": "maple.envs.proxy_env",
        "isExtraImport": true,
        "detail": "maple.envs.proxy_env",
        "documentation": {}
    },
    {
        "label": "ProxyEnv",
        "importPath": "maple.envs.proxy_env",
        "description": "maple.envs.proxy_env",
        "isExtraImport": true,
        "detail": "maple.envs.proxy_env",
        "documentation": {}
    },
    {
        "label": "mujoco_py",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjSim",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjViewer",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjSim",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjRenderContextOffscreen",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "load_model_from_xml",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjSim",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjViewer",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjSim",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "load_model_from_path",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjSim",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjViewer",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "load_model_from_path",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "cymj",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "MjViewer",
        "importPath": "mujoco_py",
        "description": "mujoco_py",
        "isExtraImport": true,
        "detail": "mujoco_py",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageMujocoEnv",
        "importPath": "maple.envs.wrappers.image_mujoco_env",
        "description": "maple.envs.wrappers.image_mujoco_env",
        "isExtraImport": true,
        "detail": "maple.envs.wrappers.image_mujoco_env",
        "documentation": {}
    },
    {
        "label": "NormalizedBoxEnv",
        "importPath": "maple.envs.wrappers",
        "description": "maple.envs.wrappers",
        "isExtraImport": true,
        "detail": "maple.envs.wrappers",
        "documentation": {}
    },
    {
        "label": "ProxyEnv",
        "importPath": "maple.envs.wrappers",
        "description": "maple.envs.wrappers",
        "isExtraImport": true,
        "detail": "maple.envs.wrappers",
        "documentation": {}
    },
    {
        "label": "ProxyEnv",
        "importPath": "maple.envs.wrappers",
        "description": "maple.envs.wrappers",
        "isExtraImport": true,
        "detail": "maple.envs.wrappers",
        "documentation": {}
    },
    {
        "label": "mujoco_env",
        "importPath": "gym.envs.mujoco",
        "description": "gym.envs.mujoco",
        "isExtraImport": true,
        "detail": "gym.envs.mujoco",
        "documentation": {}
    },
    {
        "label": "Serializable",
        "importPath": "maple.core.serializable",
        "description": "maple.core.serializable",
        "isExtraImport": true,
        "detail": "maple.core.serializable",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections.__init__",
        "description": "collections.__init__",
        "isExtraImport": true,
        "detail": "collections.__init__",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "copy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "MultitaskEnv",
        "importPath": "multiworld.core.multitask_env",
        "description": "multiworld.core.multitask_env",
        "isExtraImport": true,
        "detail": "multiworld.core.multitask_env",
        "documentation": {}
    },
    {
        "label": "get_stat_in_paths",
        "importPath": "multiworld.envs.env_util",
        "description": "multiworld.envs.env_util",
        "isExtraImport": true,
        "detail": "multiworld.envs.env_util",
        "documentation": {}
    },
    {
        "label": "create_stats_ordered_dict",
        "importPath": "multiworld.envs.env_util",
        "description": "multiworld.envs.env_util",
        "isExtraImport": true,
        "detail": "multiworld.envs.env_util",
        "documentation": {}
    },
    {
        "label": "ExplorationPolicy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "Policy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "Policy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "Policy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "ExplorationPolicy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "ExplorationPolicy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "Policy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "Policy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "Policy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "ExplorationPolicy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "ExplorationPolicy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "ExplorationPolicy",
        "importPath": "maple.policies.base",
        "description": "maple.policies.base",
        "isExtraImport": true,
        "detail": "maple.policies.base",
        "documentation": {}
    },
    {
        "label": "RawExplorationStrategy",
        "importPath": "maple.exploration_strategies.base",
        "description": "maple.exploration_strategies.base",
        "isExtraImport": true,
        "detail": "maple.exploration_strategies.base",
        "documentation": {}
    },
    {
        "label": "RawExplorationStrategy",
        "importPath": "maple.exploration_strategies.base",
        "description": "maple.exploration_strategies.base",
        "isExtraImport": true,
        "detail": "maple.exploration_strategies.base",
        "documentation": {}
    },
    {
        "label": "RawExplorationStrategy",
        "importPath": "maple.exploration_strategies.base",
        "description": "maple.exploration_strategies.base",
        "isExtraImport": true,
        "detail": "maple.exploration_strategies.base",
        "documentation": {}
    },
    {
        "label": "RawExplorationStrategy",
        "importPath": "maple.exploration_strategies.base",
        "description": "maple.exploration_strategies.base",
        "isExtraImport": true,
        "detail": "maple.exploration_strategies.base",
        "documentation": {}
    },
    {
        "label": "numpy.random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.random",
        "description": "numpy.random",
        "detail": "numpy.random",
        "documentation": {}
    },
    {
        "label": "maple",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "maple",
        "description": "maple",
        "detail": "maple",
        "documentation": {}
    },
    {
        "label": "robosuite",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "robosuite",
        "description": "robosuite",
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "ALL_GRIPPERS",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "make",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite",
        "description": "robosuite",
        "isExtraImport": true,
        "detail": "robosuite",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "__main__",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "__main__",
        "description": "__main__",
        "detail": "__main__",
        "documentation": {}
    },
    {
        "label": "conf",
        "importPath": "maple.launchers",
        "description": "maple.launchers",
        "isExtraImport": true,
        "detail": "maple.launchers",
        "documentation": {}
    },
    {
        "label": "GymWrapper",
        "importPath": "robosuite.wrappers.gym_wrapper",
        "description": "robosuite.wrappers.gym_wrapper",
        "isExtraImport": true,
        "detail": "robosuite.wrappers.gym_wrapper",
        "documentation": {}
    },
    {
        "label": "GymWrapper",
        "importPath": "robosuite.wrappers.gym_wrapper",
        "description": "robosuite.wrappers.gym_wrapper",
        "isExtraImport": true,
        "detail": "robosuite.wrappers.gym_wrapper",
        "documentation": {}
    },
    {
        "label": "EnvReplayBuffer",
        "importPath": "maple.data_management.env_replay_buffer",
        "description": "maple.data_management.env_replay_buffer",
        "isExtraImport": true,
        "detail": "maple.data_management.env_replay_buffer",
        "documentation": {}
    },
    {
        "label": "TanhGaussianPolicy",
        "importPath": "maple.torch.sac.policies",
        "description": "maple.torch.sac.policies",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies",
        "documentation": {}
    },
    {
        "label": "PAMDPPolicy",
        "importPath": "maple.torch.sac.policies",
        "description": "maple.torch.sac.policies",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies",
        "documentation": {}
    },
    {
        "label": "MakeDeterministic",
        "importPath": "maple.torch.sac.policies",
        "description": "maple.torch.sac.policies",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies",
        "documentation": {}
    },
    {
        "label": "PAMDPPolicy",
        "importPath": "maple.torch.sac.policies",
        "description": "maple.torch.sac.policies",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies",
        "documentation": {}
    },
    {
        "label": "SACTrainer",
        "importPath": "maple.torch.sac.sac",
        "description": "maple.torch.sac.sac",
        "isExtraImport": true,
        "detail": "maple.torch.sac.sac",
        "documentation": {}
    },
    {
        "label": "SACTrainer",
        "importPath": "maple.torch.sac.sac",
        "description": "maple.torch.sac.sac",
        "isExtraImport": true,
        "detail": "maple.torch.sac.sac",
        "documentation": {}
    },
    {
        "label": "SACHybridTrainer",
        "importPath": "maple.torch.sac.sac_hybrid",
        "description": "maple.torch.sac.sac_hybrid",
        "isExtraImport": true,
        "detail": "maple.torch.sac.sac_hybrid",
        "documentation": {}
    },
    {
        "label": "ConcatMlp",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "CNN",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "CNN",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "CNN",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "CNN",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "CNN",
        "importPath": "maple.torch.networks",
        "description": "maple.torch.networks",
        "isExtraImport": true,
        "detail": "maple.torch.networks",
        "documentation": {}
    },
    {
        "label": "TorchBatchRLAlgorithm",
        "importPath": "maple.torch.torch_rl_algorithm",
        "description": "maple.torch.torch_rl_algorithm",
        "isExtraImport": true,
        "detail": "maple.torch.torch_rl_algorithm",
        "documentation": {}
    },
    {
        "label": "TorchTrainer",
        "importPath": "maple.torch.torch_rl_algorithm",
        "description": "maple.torch.torch_rl_algorithm",
        "isExtraImport": true,
        "detail": "maple.torch.torch_rl_algorithm",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "ContextualEnv",
        "importPath": "maple.envs.contextual",
        "description": "maple.envs.contextual",
        "isExtraImport": true,
        "detail": "maple.envs.contextual",
        "documentation": {}
    },
    {
        "label": "contextual_rollout",
        "importPath": "maple.samplers.rollout_functions",
        "description": "maple.samplers.rollout_functions",
        "isExtraImport": true,
        "detail": "maple.samplers.rollout_functions",
        "documentation": {}
    },
    {
        "label": "rollout",
        "importPath": "maple.samplers.rollout_functions",
        "description": "maple.samplers.rollout_functions",
        "isExtraImport": true,
        "detail": "maple.samplers.rollout_functions",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "PathCollector",
        "importPath": "maple.samplers.data_collector.base",
        "description": "maple.samplers.data_collector.base",
        "isExtraImport": true,
        "detail": "maple.samplers.data_collector.base",
        "documentation": {}
    },
    {
        "label": "StepCollector",
        "importPath": "maple.samplers.data_collector.base",
        "description": "maple.samplers.data_collector.base",
        "isExtraImport": true,
        "detail": "maple.samplers.data_collector.base",
        "documentation": {}
    },
    {
        "label": "PathBuilder",
        "importPath": "maple.data_management.path_builder",
        "description": "maple.data_management.path_builder",
        "isExtraImport": true,
        "detail": "maple.data_management.path_builder",
        "documentation": {}
    },
    {
        "label": "rollout",
        "importPath": "maple.samplers.util",
        "description": "maple.samplers.util",
        "isExtraImport": true,
        "detail": "maple.samplers.util",
        "documentation": {}
    },
    {
        "label": "Normalizer",
        "importPath": "maple.data_management.normalizer",
        "description": "maple.data_management.normalizer",
        "isExtraImport": true,
        "detail": "maple.data_management.normalizer",
        "documentation": {}
    },
    {
        "label": "FixedNormalizer",
        "importPath": "maple.data_management.normalizer",
        "description": "maple.data_management.normalizer",
        "isExtraImport": true,
        "detail": "maple.data_management.normalizer",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "torch_ify",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "elem_or_tuple_to_numpy",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "torch_ify",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "elem_or_tuple_to_numpy",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "eval_np",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "eval_np",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "eval_np",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "torch_ify",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "elem_or_tuple_to_numpy",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "torch_ify",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "elem_or_tuple_to_numpy",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "torch_ify",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "elem_or_tuple_to_numpy",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "np_to_pytorch_batch",
        "importPath": "maple.torch.core",
        "description": "maple.torch.core",
        "isExtraImport": true,
        "detail": "maple.torch.core",
        "documentation": {}
    },
    {
        "label": "Delta",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "TanhNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "MultivariateDiagonalNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixture",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixtureFull",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Delta",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "TanhNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "MultivariateDiagonalNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixture",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixtureFull",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Bernoulli",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Beta",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Distribution",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Independent",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixture",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixtureFull",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "MultivariateDiagonalNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "TanhNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Delta",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "TanhNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "MultivariateDiagonalNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixture",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixtureFull",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Delta",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "TanhNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "MultivariateDiagonalNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixture",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixtureFull",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Softmax",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "TanhNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "ConcatDistribution",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "HierarchicalDistribution",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Delta",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "TanhNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "MultivariateDiagonalNormal",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixture",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixtureFull",
        "importPath": "maple.torch.distributions",
        "description": "maple.torch.distributions",
        "isExtraImport": true,
        "detail": "maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "MultiInputSequential",
        "importPath": "maple.torch.networks.basic",
        "description": "maple.torch.networks.basic",
        "isExtraImport": true,
        "detail": "maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "MultiInputSequential",
        "importPath": "maple.torch.networks.basic",
        "description": "maple.torch.networks.basic",
        "isExtraImport": true,
        "detail": "maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "MultiInputSequential",
        "importPath": "maple.torch.networks.basic",
        "description": "maple.torch.networks.basic",
        "isExtraImport": true,
        "detail": "maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "MultiInputSequential",
        "importPath": "maple.torch.networks.basic",
        "description": "maple.torch.networks.basic",
        "isExtraImport": true,
        "detail": "maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "MultiInputSequential",
        "importPath": "maple.torch.networks.basic",
        "description": "maple.torch.networks.basic",
        "isExtraImport": true,
        "detail": "maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "MultiInputSequential",
        "importPath": "maple.torch.networks.basic",
        "description": "maple.torch.networks.basic",
        "isExtraImport": true,
        "detail": "maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "DistributionGenerator",
        "importPath": "maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.torch.networks.stochastic.distribution_generator",
        "isExtraImport": true,
        "detail": "maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "DistributionGenerator",
        "importPath": "maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.torch.networks.stochastic.distribution_generator",
        "isExtraImport": true,
        "detail": "maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "DistributionGenerator",
        "importPath": "maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.torch.networks.stochastic.distribution_generator",
        "isExtraImport": true,
        "detail": "maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "DistributionGenerator",
        "importPath": "maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.torch.networks.stochastic.distribution_generator",
        "isExtraImport": true,
        "detail": "maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "DistributionGenerator",
        "importPath": "maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.torch.networks.stochastic.distribution_generator",
        "isExtraImport": true,
        "detail": "maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "DistributionGenerator",
        "importPath": "maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.torch.networks.stochastic.distribution_generator",
        "isExtraImport": true,
        "detail": "maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "LatentVariableModel",
        "importPath": "maple.torch.lvm.latent_variable_model",
        "description": "maple.torch.lvm.latent_variable_model",
        "isExtraImport": true,
        "detail": "maple.torch.lvm.latent_variable_model",
        "documentation": {}
    },
    {
        "label": "LatentVariableModel",
        "importPath": "maple.torch.lvm.latent_variable_model",
        "description": "maple.torch.lvm.latent_variable_model",
        "isExtraImport": true,
        "detail": "maple.torch.lvm.latent_variable_model",
        "documentation": {}
    },
    {
        "label": "TorchStochasticPolicy",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "PolicyFromDistributionGenerator",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "MakeDeterministic",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "TorchStochasticPolicy",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "PolicyFromDistributionGenerator",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "MakeDeterministic",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "TorchStochasticPolicy",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "PolicyFromDistributionGenerator",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "MakeDeterministic",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "TorchStochasticPolicy",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "TorchStochasticPolicy",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "PolicyFromDistributionGenerator",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "MakeDeterministic",
        "importPath": "maple.torch.sac.policies.base",
        "description": "maple.torch.sac.policies.base",
        "isExtraImport": true,
        "detail": "maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "TorchFixedNormalizer",
        "importPath": "maple.torch.data_management.normalizer",
        "description": "maple.torch.data_management.normalizer",
        "isExtraImport": true,
        "detail": "maple.torch.data_management.normalizer",
        "documentation": {}
    },
    {
        "label": "TorchFixedNormalizer",
        "importPath": "maple.torch.data_management.normalizer",
        "description": "maple.torch.data_management.normalizer",
        "isExtraImport": true,
        "detail": "maple.torch.data_management.normalizer",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "pytorch_util",
        "importPath": "maple.torch",
        "description": "maple.torch",
        "isExtraImport": true,
        "detail": "maple.torch",
        "documentation": {}
    },
    {
        "label": "pytorch_util",
        "importPath": "maple.torch",
        "description": "maple.torch",
        "isExtraImport": true,
        "detail": "maple.torch",
        "documentation": {}
    },
    {
        "label": "pytorch_util",
        "importPath": "maple.torch",
        "description": "maple.torch",
        "isExtraImport": true,
        "detail": "maple.torch",
        "documentation": {}
    },
    {
        "label": "pytorch_util",
        "importPath": "maple.torch",
        "description": "maple.torch",
        "isExtraImport": true,
        "detail": "maple.torch",
        "documentation": {}
    },
    {
        "label": "pytorch_util",
        "importPath": "maple.torch",
        "description": "maple.torch",
        "isExtraImport": true,
        "detail": "maple.torch",
        "documentation": {}
    },
    {
        "label": "torchvision.models",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchvision.models",
        "description": "torchvision.models",
        "detail": "torchvision.models",
        "documentation": {}
    },
    {
        "label": "torch.optim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.optim",
        "description": "torch.optim",
        "detail": "torch.optim",
        "documentation": {}
    },
    {
        "label": "LossFunction",
        "importPath": "maple.core.loss",
        "description": "maple.core.loss",
        "isExtraImport": true,
        "detail": "maple.core.loss",
        "documentation": {}
    },
    {
        "label": "LossStatistics",
        "importPath": "maple.core.loss",
        "description": "maple.core.loss",
        "isExtraImport": true,
        "detail": "maple.core.loss",
        "documentation": {}
    },
    {
        "label": "LossStatistics",
        "importPath": "maple.core.loss",
        "description": "maple.core.loss",
        "isExtraImport": true,
        "detail": "maple.core.loss",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "Sampler",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "OneHotCategorical",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "kl_divergence",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Beta",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Distribution",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Bernoulli",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Independent",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "_sum_rightmost",
        "importPath": "torch.distributions.utils",
        "description": "torch.distributions.utils",
        "isExtraImport": true,
        "detail": "torch.distributions.utils",
        "documentation": {}
    },
    {
        "label": "BatchRLAlgorithm",
        "importPath": "maple.core.batch_rl_algorithm",
        "description": "maple.core.batch_rl_algorithm",
        "isExtraImport": true,
        "detail": "maple.core.batch_rl_algorithm",
        "documentation": {}
    },
    {
        "label": "OnlineRLAlgorithm",
        "importPath": "maple.core.online_rl_algorithm",
        "description": "maple.core.online_rl_algorithm",
        "isExtraImport": true,
        "detail": "maple.core.online_rl_algorithm",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "importPath": "maple.core.trainer",
        "description": "maple.core.trainer",
        "isExtraImport": true,
        "detail": "maple.core.trainer",
        "documentation": {}
    },
    {
        "label": "joblib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "joblib",
        "description": "joblib",
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "boto3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "boto3",
        "description": "boto3",
        "detail": "boto3",
        "documentation": {}
    },
    {
        "label": "LOCAL_LOG_DIR",
        "importPath": "maple.launchers.conf",
        "description": "maple.launchers.conf",
        "isExtraImport": true,
        "detail": "maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "AWS_S3_PATH",
        "importPath": "maple.launchers.conf",
        "description": "maple.launchers.conf",
        "isExtraImport": true,
        "detail": "maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "LOCAL_LOG_DIR",
        "importPath": "maple.launchers.conf",
        "description": "maple.launchers.conf",
        "isExtraImport": true,
        "detail": "maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "run_experiment",
        "importPath": "maple.launchers.launcher_util",
        "description": "maple.launchers.launcher_util",
        "isExtraImport": true,
        "detail": "maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "run_experiment_here",
        "importPath": "maple.launchers.launcher_util",
        "description": "maple.launchers.launcher_util",
        "isExtraImport": true,
        "detail": "maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "run_experiment",
        "importPath": "maple.launchers.launcher_util",
        "description": "maple.launchers.launcher_util",
        "isExtraImport": true,
        "detail": "maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "experiment",
        "importPath": "maple.launchers.robosuite_launcher",
        "description": "maple.launchers.robosuite_launcher",
        "isExtraImport": true,
        "detail": "maple.launchers.robosuite_launcher",
        "documentation": {}
    },
    {
        "label": "experiment",
        "importPath": "maple.launchers.robosuite_launcher",
        "description": "maple.launchers.robosuite_launcher",
        "isExtraImport": true,
        "detail": "maple.launchers.robosuite_launcher",
        "documentation": {}
    },
    {
        "label": "maple.util.hyperparameter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "maple.util.hyperparameter",
        "description": "maple.util.hyperparameter",
        "detail": "maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "doodad",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "doodad",
        "description": "doodad",
        "detail": "doodad",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "sphinx_rtd_theme",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sphinx_rtd_theme",
        "description": "sphinx_rtd_theme",
        "detail": "sphinx_rtd_theme",
        "documentation": {}
    },
    {
        "label": "Interpolator",
        "importPath": "robosuite.controllers.interpolators.base_interpolator",
        "description": "robosuite.controllers.interpolators.base_interpolator",
        "isExtraImport": true,
        "detail": "robosuite.controllers.interpolators.base_interpolator",
        "documentation": {}
    },
    {
        "label": "robosuite.utils.transform_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "rotation_matrix",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "rotation_matrix",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "convert_quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "convert_quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "convert_quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat2quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "convert_quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "euler2mat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat2quat",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_multiply",
        "importPath": "robosuite.utils.transform_utils",
        "description": "robosuite.utils.transform_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "JointVelocityController",
        "importPath": "robosuite.controllers.joint_vel",
        "description": "robosuite.controllers.joint_vel",
        "isExtraImport": true,
        "detail": "robosuite.controllers.joint_vel",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "RingBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "DeltaBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "RingBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "DeltaBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "DeltaBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "RingBuffer",
        "importPath": "robosuite.utils.control_utils",
        "description": "robosuite.utils.control_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "Controller",
        "importPath": "robosuite.controllers.base_controller",
        "description": "robosuite.controllers.base_controller",
        "isExtraImport": true,
        "detail": "robosuite.controllers.base_controller",
        "documentation": {}
    },
    {
        "label": "Controller",
        "importPath": "robosuite.controllers.base_controller",
        "description": "robosuite.controllers.base_controller",
        "isExtraImport": true,
        "detail": "robosuite.controllers.base_controller",
        "documentation": {}
    },
    {
        "label": "Controller",
        "importPath": "robosuite.controllers.base_controller",
        "description": "robosuite.controllers.base_controller",
        "isExtraImport": true,
        "detail": "robosuite.controllers.base_controller",
        "documentation": {}
    },
    {
        "label": "Controller",
        "importPath": "robosuite.controllers.base_controller",
        "description": "robosuite.controllers.base_controller",
        "isExtraImport": true,
        "detail": "robosuite.controllers.base_controller",
        "documentation": {}
    },
    {
        "label": "AtomicSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "ReachSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "ReachOSCSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "GraspSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "PushSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "GripperSkill",
        "importPath": "robosuite.controllers.skills",
        "description": "robosuite.controllers.skills",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "DataCollectionWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "VisualizationWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "DomainRandomizationWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "GymWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "DataCollectionWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "VisualizationWrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "robosuite.wrappers",
        "description": "robosuite.wrappers",
        "isExtraImport": true,
        "detail": "robosuite.wrappers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "reset_controllers",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "controller_factory",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "controller_factory",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "importPath": "robosuite.controllers",
        "description": "robosuite.controllers",
        "isExtraImport": true,
        "detail": "robosuite.controllers",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "input2action",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "input2action",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.utils.input_utils",
        "description": "robosuite.utils.input_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "Bimanual",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "Manipulator",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "ROBOT_CLASS_MAPPING",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "SingleArm",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "ROBOT_CLASS_MAPPING",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "SingleArm",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "BIMANUAL_ROBOTS",
        "importPath": "robosuite.robots",
        "description": "robosuite.robots",
        "isExtraImport": true,
        "detail": "robosuite.robots",
        "documentation": {}
    },
    {
        "label": "robosuite.utils.macros",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "robosuite.utils.macros",
        "description": "robosuite.utils.macros",
        "detail": "robosuite.utils.macros",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "MujocoWorldBase",
        "importPath": "robosuite.models",
        "description": "robosuite.models",
        "isExtraImport": true,
        "detail": "robosuite.models",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas.table_arena",
        "description": "robosuite.models.arenas.table_arena",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas.table_arena",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas.table_arena",
        "description": "robosuite.models.arenas.table_arena",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas.table_arena",
        "documentation": {}
    },
    {
        "label": "RethinkGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "PandaGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "gripper_factory",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "gripper_factory",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GRIPPER_MAPPING",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "JacoThreeFingerGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "PandaGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "RethinkGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "Robotiq140Gripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "Robotiq85Gripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "RobotiqThreeFingerGripper",
        "importPath": "robosuite.models.grippers",
        "description": "robosuite.models.grippers",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "DoorObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "SquareNutObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "RoundNutObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MilkObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BreadObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CerealObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CanObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MilkVisualObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BreadVisualObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CerealVisualObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CanVisualObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CylinderObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CompositeObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CompositeObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CompositeBodyObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "CylinderObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "PrimitiveObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "PrimitiveObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "PrimitiveObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "PrimitiveObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MujocoGeneratedObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MujocoObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MujocoXMLObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MujocoObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "MujocoObject",
        "importPath": "robosuite.models.objects",
        "description": "robosuite.models.objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects",
        "documentation": {}
    },
    {
        "label": "new_joint",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_actuator",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "IMAGE_CONVENTION_MAPPING",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "find_elements",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "GRIPPER_COLLISION_COLOR",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_actuator",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_joint",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "MOUNT_COLLISION_COLOR",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "add_to_dict",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "RED",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "GREEN",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "BLUE",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CYAN",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "add_to_dict",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "RED",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "GREEN",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "BLUE",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "RED",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "BLUE",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "get_size",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "get_size",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "get_size",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "get_size",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_body",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_geom",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_site",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_joint",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_inertial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "OBJECT_COLLISION_COLOR",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "find_elements",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "find_elements",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "ROBOT_COLLISION_COLOR",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "find_elements",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "sort_elements",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "\\",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "postprocess_model_xml",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "save_sim_model",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "postprocess_model_xml",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_site",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_geom",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_body",
        "importPath": "robosuite.utils.mjcf_utils",
        "description": "robosuite.utils.mjcf_utils",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "imageio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imageio",
        "description": "imageio",
        "detail": "imageio",
        "documentation": {}
    },
    {
        "label": "glfw",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glfw",
        "description": "glfw",
        "detail": "glfw",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "robosuite.devices",
        "description": "robosuite.devices",
        "isExtraImport": true,
        "detail": "robosuite.devices",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "robosuite.devices",
        "description": "robosuite.devices",
        "isExtraImport": true,
        "detail": "robosuite.devices",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "importPath": "robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.environments.manipulation.single_arm_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "PegsArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "BlockArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "BinsArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "WipeArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "Arena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "Arena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "Arena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "Arena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "importPath": "robosuite.models.arenas",
        "description": "robosuite.models.arenas",
        "isExtraImport": true,
        "detail": "robosuite.models.arenas",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "importPath": "robosuite.models.tasks",
        "description": "robosuite.models.tasks",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "SequentialCompositeSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "SequentialCompositeSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "importPath": "robosuite.utils.placement_samplers",
        "description": "robosuite.utils.placement_samplers",
        "isExtraImport": true,
        "detail": "robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "RandomizationError",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "SimulationError",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "XMLError",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "MujocoPyRenderer",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "XMLError",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "RandomizationError",
        "importPath": "robosuite.utils",
        "description": "robosuite.utils",
        "isExtraImport": true,
        "detail": "robosuite.utils",
        "documentation": {}
    },
    {
        "label": "RobotEnv",
        "importPath": "robosuite.environments.robot_env",
        "description": "robosuite.environments.robot_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.robot_env",
        "documentation": {}
    },
    {
        "label": "MujocoModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXML",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXMLModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXMLModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXML",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXMLModel",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXML",
        "importPath": "robosuite.models.base",
        "description": "robosuite.models.base",
        "isExtraImport": true,
        "detail": "robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "PegObject",
        "importPath": "robosuite.models.objects.xml_objects",
        "description": "robosuite.models.objects.xml_objects",
        "isExtraImport": true,
        "detail": "robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "ManipulationEnv",
        "importPath": "robosuite.environments.manipulation.manipulation_env",
        "description": "robosuite.environments.manipulation.manipulation_env",
        "isExtraImport": true,
        "detail": "robosuite.environments.manipulation.manipulation_env",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "MujocoEnv",
        "importPath": "robosuite.environments.base",
        "description": "robosuite.environments.base",
        "isExtraImport": true,
        "detail": "robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "SkillController",
        "importPath": "robosuite.controllers.skill_controller",
        "description": "robosuite.controllers.skill_controller",
        "isExtraImport": true,
        "detail": "robosuite.controllers.skill_controller",
        "documentation": {}
    },
    {
        "label": "MujocoWorldBase",
        "importPath": "robosuite.models.world",
        "description": "robosuite.models.world",
        "isExtraImport": true,
        "detail": "robosuite.models.world",
        "documentation": {}
    },
    {
        "label": "MujocoWorldBase",
        "importPath": "robosuite.models.world",
        "description": "robosuite.models.world",
        "isExtraImport": true,
        "detail": "robosuite.models.world",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "importPath": "robosuite.models.grippers.gripper_model",
        "description": "robosuite.models.grippers.gripper_model",
        "isExtraImport": true,
        "detail": "robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "MountModel",
        "importPath": "robosuite.models.mounts.mount_model",
        "description": "robosuite.models.mounts.mount_model",
        "isExtraImport": true,
        "detail": "robosuite.models.mounts.mount_model",
        "documentation": {}
    },
    {
        "label": "MountModel",
        "importPath": "robosuite.models.mounts.mount_model",
        "description": "robosuite.models.mounts.mount_model",
        "isExtraImport": true,
        "detail": "robosuite.models.mounts.mount_model",
        "documentation": {}
    },
    {
        "label": "MountModel",
        "importPath": "robosuite.models.mounts.mount_model",
        "description": "robosuite.models.mounts.mount_model",
        "isExtraImport": true,
        "detail": "robosuite.models.mounts.mount_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "importPath": "robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.models.robots.manipulators.manipulator_model",
        "isExtraImport": true,
        "detail": "robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "RobotModel",
        "importPath": "robosuite.models.robots",
        "description": "robosuite.models.robots",
        "isExtraImport": true,
        "detail": "robosuite.models.robots",
        "documentation": {}
    },
    {
        "label": "RobotModel",
        "importPath": "robosuite.models.robots",
        "description": "robosuite.models.robots",
        "isExtraImport": true,
        "detail": "robosuite.models.robots",
        "documentation": {}
    },
    {
        "label": "create_robot",
        "importPath": "robosuite.models.robots",
        "description": "robosuite.models.robots",
        "isExtraImport": true,
        "detail": "robosuite.models.robots",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "robosuite.models.robots",
        "description": "robosuite.models.robots",
        "isExtraImport": true,
        "detail": "robosuite.models.robots",
        "documentation": {}
    },
    {
        "label": "Task",
        "importPath": "robosuite.models.tasks.task",
        "description": "robosuite.models.tasks.task",
        "isExtraImport": true,
        "detail": "robosuite.models.tasks.task",
        "documentation": {}
    },
    {
        "label": "xml.dom.minidom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.dom.minidom",
        "description": "xml.dom.minidom",
        "detail": "xml.dom.minidom",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "Manipulator",
        "importPath": "robosuite.robots.manipulator",
        "description": "robosuite.robots.manipulator",
        "isExtraImport": true,
        "detail": "robosuite.robots.manipulator",
        "documentation": {}
    },
    {
        "label": "Manipulator",
        "importPath": "robosuite.robots.manipulator",
        "description": "robosuite.robots.manipulator",
        "isExtraImport": true,
        "detail": "robosuite.robots.manipulator",
        "documentation": {}
    },
    {
        "label": "Robot",
        "importPath": "robosuite.robots.robot",
        "description": "robosuite.robots.robot",
        "isExtraImport": true,
        "detail": "robosuite.robots.robot",
        "documentation": {}
    },
    {
        "label": "mount_factory",
        "importPath": "robosuite.models.mounts",
        "description": "robosuite.models.mounts",
        "isExtraImport": true,
        "detail": "robosuite.models.mounts",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "copyfile",
        "importPath": "shutil",
        "description": "shutil",
        "isExtraImport": true,
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "h5py",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "h5py",
        "description": "h5py",
        "detail": "h5py",
        "documentation": {}
    },
    {
        "label": "jit_decorator",
        "importPath": "robosuite.utils.numba",
        "description": "robosuite.utils.numba",
        "isExtraImport": true,
        "detail": "robosuite.utils.numba",
        "documentation": {}
    },
    {
        "label": "jit_decorator",
        "importPath": "robosuite.utils.numba",
        "description": "robosuite.utils.numba",
        "isExtraImport": true,
        "detail": "robosuite.utils.numba",
        "documentation": {}
    },
    {
        "label": "const",
        "importPath": "mujoco_py.generated",
        "description": "mujoco_py.generated",
        "isExtraImport": true,
        "detail": "mujoco_py.generated",
        "documentation": {}
    },
    {
        "label": "numba",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numba",
        "description": "numba",
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "TextureModder",
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "LightingModder",
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "CameraModder",
        "importPath": "robosuite.utils.mjmod",
        "description": "robosuite.utils.mjmod",
        "isExtraImport": true,
        "detail": "robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "gym.core",
        "description": "gym.core",
        "isExtraImport": true,
        "detail": "gym.core",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "viskit.core",
        "description": "viskit.core",
        "isExtraImport": true,
        "detail": "viskit.core",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "flask",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "flask",
        "description": "flask",
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "core",
        "importPath": "viskit",
        "description": "viskit",
        "isExtraImport": true,
        "detail": "viskit",
        "documentation": {}
    },
    {
        "label": "tools",
        "importPath": "plotly",
        "description": "plotly",
        "isExtraImport": true,
        "detail": "plotly",
        "documentation": {}
    },
    {
        "label": "plotly.offline",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.offline",
        "description": "plotly.offline",
        "detail": "plotly.offline",
        "documentation": {}
    },
    {
        "label": "plotly.graph_objs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.graph_objs",
        "description": "plotly.graph_objs",
        "detail": "plotly.graph_objs",
        "documentation": {}
    },
    {
        "label": "BatchRLAlgorithm",
        "kind": 6,
        "importPath": "maple.maple.core.batch_rl_algorithm",
        "description": "maple.maple.core.batch_rl_algorithm",
        "peekOfCode": "class BatchRLAlgorithm(BaseRLAlgorithm, metaclass=abc.ABCMeta):\n    def __init__(\n            self,\n            trainer,\n            exploration_env,\n            evaluation_env,\n            exploration_data_collector: PathCollector,\n            evaluation_data_collector: PathCollector,\n            replay_buffer: ReplayBuffer,\n            batch_size,",
        "detail": "maple.maple.core.batch_rl_algorithm",
        "documentation": {}
    },
    {
        "label": "get_generic_path_information",
        "kind": 2,
        "importPath": "maple.maple.core.eval_util",
        "description": "maple.maple.core.eval_util",
        "peekOfCode": "def get_generic_path_information(paths, stat_prefix=''):\n    \"\"\"\n    Get an OrderedDict with a bunch of statistic names and values.\n    \"\"\"\n    statistics = OrderedDict()\n    returns = [sum(path[\"rewards\"]) for path in paths]\n    rewards = np.vstack([path[\"rewards\"] for path in paths])\n    statistics.update(create_stats_ordered_dict('Rewards', rewards,\n                                                stat_prefix=stat_prefix))\n    statistics.update(create_stats_ordered_dict('Returns', returns,",
        "detail": "maple.maple.core.eval_util",
        "documentation": {}
    },
    {
        "label": "get_average_returns",
        "kind": 2,
        "importPath": "maple.maple.core.eval_util",
        "description": "maple.maple.core.eval_util",
        "peekOfCode": "def get_average_returns(paths):\n    returns = [sum(path[\"rewards\"]) for path in paths]\n    return np.mean(returns)\ndef get_num_rollout_success(paths):\n    num_success = 0\n    for path in paths:\n        if any([info.get('success', False) for info in path['env_infos']]):\n            num_success += 1\n    return num_success\ndef create_stats_ordered_dict(",
        "detail": "maple.maple.core.eval_util",
        "documentation": {}
    },
    {
        "label": "get_num_rollout_success",
        "kind": 2,
        "importPath": "maple.maple.core.eval_util",
        "description": "maple.maple.core.eval_util",
        "peekOfCode": "def get_num_rollout_success(paths):\n    num_success = 0\n    for path in paths:\n        if any([info.get('success', False) for info in path['env_infos']]):\n            num_success += 1\n    return num_success\ndef create_stats_ordered_dict(\n        name,\n        data,\n        stat_prefix=None,",
        "detail": "maple.maple.core.eval_util",
        "documentation": {}
    },
    {
        "label": "create_stats_ordered_dict",
        "kind": 2,
        "importPath": "maple.maple.core.eval_util",
        "description": "maple.maple.core.eval_util",
        "peekOfCode": "def create_stats_ordered_dict(\n        name,\n        data,\n        stat_prefix=None,\n        always_show_all_stats=True,\n        exclude_max_min=True,\n):\n    if stat_prefix is not None:\n        name = \"{}{}\".format(stat_prefix, name)\n    if isinstance(data, Number):",
        "detail": "maple.maple.core.eval_util",
        "documentation": {}
    },
    {
        "label": "TerminalTablePrinter",
        "kind": 6,
        "importPath": "maple.maple.core.logging",
        "description": "maple.maple.core.logging",
        "peekOfCode": "class TerminalTablePrinter(object):\n    def __init__(self):\n        self.headers = None\n        self.tabulars = []\n    def print_tabular(self, new_tabular):\n        if self.headers is None:\n            self.headers = [x[0] for x in new_tabular]\n        else:\n            assert len(self.headers) == len(new_tabular)\n        self.tabulars.append([x[1] for x in new_tabular])",
        "detail": "maple.maple.core.logging",
        "documentation": {}
    },
    {
        "label": "MyEncoder",
        "kind": 6,
        "importPath": "maple.maple.core.logging",
        "description": "maple.maple.core.logging",
        "peekOfCode": "class MyEncoder(json.JSONEncoder):\n    def default(self, o):\n        if isinstance(o, type):\n            return {'$class': o.__module__ + \".\" + o.__name__}\n        elif isinstance(o, Enum):\n            return {\n                '$enum': o.__module__ + \".\" + o.__class__.__name__ + '.' + o.name\n            }\n        elif callable(o):\n            return {",
        "detail": "maple.maple.core.logging",
        "documentation": {}
    },
    {
        "label": "Logger",
        "kind": 6,
        "importPath": "maple.maple.core.logging",
        "description": "maple.maple.core.logging",
        "peekOfCode": "class Logger(object):\n    def __init__(self):\n        self._prefixes = []\n        self._prefix_str = ''\n        self._tabular_prefixes = []\n        self._tabular_prefix_str = ''\n        self._tabular = []\n        self._tabular_keys = {}\n        self._text_outputs = []\n        self._tabular_outputs = []",
        "detail": "maple.maple.core.logging",
        "documentation": {}
    },
    {
        "label": "add_prefix",
        "kind": 2,
        "importPath": "maple.maple.core.logging",
        "description": "maple.maple.core.logging",
        "peekOfCode": "def add_prefix(log_dict: OrderedDict, prefix: str, divider=''):\n    with_prefix = OrderedDict()\n    for key, val in log_dict.items():\n        with_prefix[prefix + divider + key] = val\n    return with_prefix\ndef append_log(log_dict, to_add_dict, prefix=None):\n    if prefix is not None:\n        to_add_dict = add_prefix(to_add_dict, prefix=prefix)\n    return log_dict.update(to_add_dict)\nclass TerminalTablePrinter(object):",
        "detail": "maple.maple.core.logging",
        "documentation": {}
    },
    {
        "label": "append_log",
        "kind": 2,
        "importPath": "maple.maple.core.logging",
        "description": "maple.maple.core.logging",
        "peekOfCode": "def append_log(log_dict, to_add_dict, prefix=None):\n    if prefix is not None:\n        to_add_dict = add_prefix(to_add_dict, prefix=prefix)\n    return log_dict.update(to_add_dict)\nclass TerminalTablePrinter(object):\n    def __init__(self):\n        self.headers = None\n        self.tabulars = []\n    def print_tabular(self, new_tabular):\n        if self.headers is None:",
        "detail": "maple.maple.core.logging",
        "documentation": {}
    },
    {
        "label": "mkdir_p",
        "kind": 2,
        "importPath": "maple.maple.core.logging",
        "description": "maple.maple.core.logging",
        "peekOfCode": "def mkdir_p(path):\n    try:\n        os.makedirs(path)\n    except OSError as exc:  # Python >2.5\n        if exc.errno == errno.EEXIST and os.path.isdir(path):\n            pass\n        else:\n            raise\nclass Logger(object):\n    def __init__(self):",
        "detail": "maple.maple.core.logging",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "maple.maple.core.logging",
        "description": "maple.maple.core.logging",
        "peekOfCode": "logger = Logger()",
        "detail": "maple.maple.core.logging",
        "documentation": {}
    },
    {
        "label": "LossFunction",
        "kind": 6,
        "importPath": "maple.maple.core.loss",
        "description": "maple.maple.core.loss",
        "peekOfCode": "class LossFunction(object, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def compute_loss(self, batch, skip_statistics=False, **kwargs):\n        \"\"\"Returns loss and statistics given a batch of data.\n        batch : Data to compute loss of\n        skip_statistics: Whether statistics should be calculated. If True, then\n            an empty dict is returned for the statistics.\n        Returns: (loss, stats) tuple.\n        \"\"\"\n        pass",
        "detail": "maple.maple.core.loss",
        "documentation": {}
    },
    {
        "label": "LossStatistics",
        "kind": 5,
        "importPath": "maple.maple.core.loss",
        "description": "maple.maple.core.loss",
        "peekOfCode": "LossStatistics = OrderedDict\nclass LossFunction(object, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def compute_loss(self, batch, skip_statistics=False, **kwargs):\n        \"\"\"Returns loss and statistics given a batch of data.\n        batch : Data to compute loss of\n        skip_statistics: Whether statistics should be calculated. If True, then\n            an empty dict is returned for the statistics.\n        Returns: (loss, stats) tuple.\n        \"\"\"",
        "detail": "maple.maple.core.loss",
        "documentation": {}
    },
    {
        "label": "OnlineRLAlgorithm",
        "kind": 6,
        "importPath": "maple.maple.core.online_rl_algorithm",
        "description": "maple.maple.core.online_rl_algorithm",
        "peekOfCode": "class OnlineRLAlgorithm(BaseRLAlgorithm, metaclass=abc.ABCMeta):\n    def __init__(\n            self,\n            trainer,\n            exploration_env,\n            evaluation_env,\n            exploration_data_collector: StepCollector,\n            evaluation_data_collector: PathCollector,\n            replay_buffer: ReplayBuffer,\n            batch_size,",
        "detail": "maple.maple.core.online_rl_algorithm",
        "documentation": {}
    },
    {
        "label": "BaseRLAlgorithm",
        "kind": 6,
        "importPath": "maple.maple.core.rl_algorithm",
        "description": "maple.maple.core.rl_algorithm",
        "peekOfCode": "class BaseRLAlgorithm(object, metaclass=abc.ABCMeta):\n    def __init__(\n            self,\n            trainer,\n            exploration_env,\n            evaluation_env,\n            exploration_data_collector: DataCollector,\n            evaluation_data_collector: DataCollector,\n            replay_buffer: ReplayBuffer,\n            eval_epoch_freq=1,",
        "detail": "maple.maple.core.rl_algorithm",
        "documentation": {}
    },
    {
        "label": "Serializable",
        "kind": 6,
        "importPath": "maple.maple.core.serializable",
        "description": "maple.maple.core.serializable",
        "peekOfCode": "class Serializable(object):\n    def __init__(self, *args, **kwargs):\n        self.__args = args\n        self.__kwargs = kwargs\n    def quick_init(self, locals_):\n        if getattr(self, \"_serializable_initialized\", False):\n            return\n        if sys.version_info >= (3, 0):\n            spec = inspect.getfullargspec(self.__init__)\n            # Exclude the first \"self\" parameter",
        "detail": "maple.maple.core.serializable",
        "documentation": {}
    },
    {
        "label": "simple_separated_format",
        "kind": 2,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "def simple_separated_format(separator):\n    \"\"\"Construct a simple TableFormat with columns separated by a separator.\n    >>> tsv = simple_separated_format(\"\\\\t\") ; \\\n        tabulate([[\"foo\", 1], [\"spam\", 23]], tablefmt=tsv) == 'foo \\\\t 1\\\\nspam\\\\t23'\n    True\n    \"\"\"\n    return TableFormat(None, None, None, None,\n                       headerrow=DataRow('', separator, ''),\n                       datarow=DataRow('', separator, ''),\n                       padding=0, with_header_hide=None)",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "kind": 2,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "def tabulate(tabular_data, headers=[], tablefmt=\"simple\",\n             floatfmt=\"g\", numalign=\"decimal\", stralign=\"left\",\n             missingval=\"\"):\n    \"\"\"Format a fixed width table for pretty printing.\n    >>> print(tabulate([[1, 2.34], [-56, \"8.999\"], [\"2\", \"10001\"]]))\n    ---  ---------\n      1      2.34\n    -56      8.999\n      2  10001\n    ---  ---------",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "__all__ = [\"tabulate\", \"tabulate_formats\", \"simple_separated_format\"]\n__version__ = \"0.7.2\"\nLine = namedtuple(\"Line\", [\"begin\", \"hline\", \"sep\", \"end\"])\nDataRow = namedtuple(\"DataRow\", [\"begin\", \"sep\", \"end\"])\n# A table structure is suppposed to be:\n#\n#     --- lineabove ---------\n#         headerrow\n#     --- linebelowheader ---\n#         datarow",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "__version__ = \"0.7.2\"\nLine = namedtuple(\"Line\", [\"begin\", \"hline\", \"sep\", \"end\"])\nDataRow = namedtuple(\"DataRow\", [\"begin\", \"sep\", \"end\"])\n# A table structure is suppposed to be:\n#\n#     --- lineabove ---------\n#         headerrow\n#     --- linebelowheader ---\n#         datarow\n#     --- linebewteenrows ---",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "Line",
        "kind": 5,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "Line = namedtuple(\"Line\", [\"begin\", \"hline\", \"sep\", \"end\"])\nDataRow = namedtuple(\"DataRow\", [\"begin\", \"sep\", \"end\"])\n# A table structure is suppposed to be:\n#\n#     --- lineabove ---------\n#         headerrow\n#     --- linebelowheader ---\n#         datarow\n#     --- linebewteenrows ---\n#     ... (more datarows) ...",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "DataRow",
        "kind": 5,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "DataRow = namedtuple(\"DataRow\", [\"begin\", \"sep\", \"end\"])\n# A table structure is suppposed to be:\n#\n#     --- lineabove ---------\n#         headerrow\n#     --- linebelowheader ---\n#         datarow\n#     --- linebewteenrows ---\n#     ... (more datarows) ...\n#     --- linebewteenrows ---",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "TableFormat",
        "kind": 5,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "TableFormat = namedtuple(\"TableFormat\", [\"lineabove\", \"linebelowheader\",\n                                         \"linebetweenrows\", \"linebelow\",\n                                         \"headerrow\", \"datarow\",\n                                         \"padding\", \"with_header_hide\"])\ndef _pipe_segment_with_colons(align, colwidth):\n    \"\"\"Return a segment of a horizontal line with optional colons which\n    indicate column's alignment (as in `pipe` output format).\"\"\"\n    w = colwidth\n    if align in [\"right\", \"decimal\"]:\n        return ('-' * (w - 1)) + \":\"",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "_table_formats",
        "kind": 5,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "_table_formats = {\"simple\":\n                  TableFormat(lineabove=Line(\"\", \"-\", \"  \", \"\"),\n                              linebelowheader=Line(\"\", \"-\", \"  \", \"\"),\n                              linebetweenrows=None,\n                              linebelow=Line(\"\", \"-\", \"  \", \"\"),\n                              headerrow=DataRow(\"\", \"  \", \"\"),\n                              datarow=DataRow(\"\", \"  \", \"\"),\n                              padding=0,\n                              with_header_hide=[\"lineabove\", \"linebelow\"]),\n                  \"plain\":",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "tabulate_formats",
        "kind": 5,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "tabulate_formats = list(sorted(_table_formats.keys()))\n_invisible_codes = re.compile(\"\\x1b\\[\\d*m\")  # ANSI color codes\n_invisible_codes_bytes = re.compile(b\"\\x1b\\[\\d*m\")  # ANSI color codes\ndef simple_separated_format(separator):\n    \"\"\"Construct a simple TableFormat with columns separated by a separator.\n    >>> tsv = simple_separated_format(\"\\\\t\") ; \\\n        tabulate([[\"foo\", 1], [\"spam\", 23]], tablefmt=tsv) == 'foo \\\\t 1\\\\nspam\\\\t23'\n    True\n    \"\"\"\n    return TableFormat(None, None, None, None,",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "_invisible_codes",
        "kind": 5,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "_invisible_codes = re.compile(\"\\x1b\\[\\d*m\")  # ANSI color codes\n_invisible_codes_bytes = re.compile(b\"\\x1b\\[\\d*m\")  # ANSI color codes\ndef simple_separated_format(separator):\n    \"\"\"Construct a simple TableFormat with columns separated by a separator.\n    >>> tsv = simple_separated_format(\"\\\\t\") ; \\\n        tabulate([[\"foo\", 1], [\"spam\", 23]], tablefmt=tsv) == 'foo \\\\t 1\\\\nspam\\\\t23'\n    True\n    \"\"\"\n    return TableFormat(None, None, None, None,\n                       headerrow=DataRow('', separator, ''),",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "_invisible_codes_bytes",
        "kind": 5,
        "importPath": "maple.maple.core.tabulate",
        "description": "maple.maple.core.tabulate",
        "peekOfCode": "_invisible_codes_bytes = re.compile(b\"\\x1b\\[\\d*m\")  # ANSI color codes\ndef simple_separated_format(separator):\n    \"\"\"Construct a simple TableFormat with columns separated by a separator.\n    >>> tsv = simple_separated_format(\"\\\\t\") ; \\\n        tabulate([[\"foo\", 1], [\"spam\", 23]], tablefmt=tsv) == 'foo \\\\t 1\\\\nspam\\\\t23'\n    True\n    \"\"\"\n    return TableFormat(None, None, None, None,\n                       headerrow=DataRow('', separator, ''),\n                       datarow=DataRow('', separator, ''),",
        "detail": "maple.maple.core.tabulate",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "kind": 6,
        "importPath": "maple.maple.core.trainer",
        "description": "maple.maple.core.trainer",
        "peekOfCode": "class Trainer(object, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def train(self, data):\n        pass\n    def end_epoch(self, epoch):\n        pass\n    def get_snapshot(self):\n        return {}\n    def get_diagnostics(self):\n        return {}",
        "detail": "maple.maple.core.trainer",
        "documentation": {}
    },
    {
        "label": "EnvReplayBuffer",
        "kind": 6,
        "importPath": "maple.maple.data_management.env_replay_buffer",
        "description": "maple.maple.data_management.env_replay_buffer",
        "peekOfCode": "class EnvReplayBuffer(SimpleReplayBuffer):\n    def __init__(\n            self,\n            max_replay_buffer_size,\n            env,\n            env_info_sizes=None\n    ):\n        \"\"\"\n        :param max_replay_buffer_size:\n        :param env:",
        "detail": "maple.maple.data_management.env_replay_buffer",
        "documentation": {}
    },
    {
        "label": "Normalizer",
        "kind": 6,
        "importPath": "maple.maple.data_management.normalizer",
        "description": "maple.maple.data_management.normalizer",
        "peekOfCode": "class Normalizer(object):\n    def __init__(\n            self,\n            size,\n            eps=1e-8,\n            default_clip_range=np.inf,\n            mean=0,\n            std=1,\n    ):\n        self.size = size",
        "detail": "maple.maple.data_management.normalizer",
        "documentation": {}
    },
    {
        "label": "IdentityNormalizer",
        "kind": 6,
        "importPath": "maple.maple.data_management.normalizer",
        "description": "maple.maple.data_management.normalizer",
        "peekOfCode": "class IdentityNormalizer(object):\n    def __init__(self, *args, **kwargs):\n        pass\n    def update(self, v):\n        pass\n    def normalize(self, v, clip_range=None):\n        return v\n    def denormalize(self, v):\n        return v\nclass FixedNormalizer(object):",
        "detail": "maple.maple.data_management.normalizer",
        "documentation": {}
    },
    {
        "label": "FixedNormalizer",
        "kind": 6,
        "importPath": "maple.maple.data_management.normalizer",
        "description": "maple.maple.data_management.normalizer",
        "peekOfCode": "class FixedNormalizer(object):\n    def __init__(\n            self,\n            size,\n            default_clip_range=np.inf,\n            mean=0,\n            std=1,\n            eps=1e-8,\n    ):\n        assert std > 0",
        "detail": "maple.maple.data_management.normalizer",
        "documentation": {}
    },
    {
        "label": "ObsDictRelabelingBuffer",
        "kind": 6,
        "importPath": "maple.maple.data_management.obs_dict_replay_buffer",
        "description": "maple.maple.data_management.obs_dict_replay_buffer",
        "peekOfCode": "class ObsDictRelabelingBuffer(ReplayBuffer):\n    \"\"\"\n    Replay buffer for environments whose observations are dictionaries, such as\n        - OpenAI Gym GoalEnv environments.\n          https://blog.openai.com/ingredients-for-robotics-research/\n        - multiworld MultitaskEnv. https://github.com/vitchyr/multiworld/\n    Implementation details:\n     - Only add_path is implemented.\n     - Image observations are presumed to start with the 'image_' prefix\n     - Every sample from [0, self._size] will be valid.",
        "detail": "maple.maple.data_management.obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "flatten_n",
        "kind": 2,
        "importPath": "maple.maple.data_management.obs_dict_replay_buffer",
        "description": "maple.maple.data_management.obs_dict_replay_buffer",
        "peekOfCode": "def flatten_n(xs):\n    xs = np.asarray(xs)\n    return xs.reshape((xs.shape[0], -1))\ndef flatten_dict(dicts, keys):\n    \"\"\"\n    Turns list of dicts into dict of np arrays\n    \"\"\"\n    return {\n        key: flatten_n([d[key] for d in dicts])\n        for key in keys",
        "detail": "maple.maple.data_management.obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "flatten_dict",
        "kind": 2,
        "importPath": "maple.maple.data_management.obs_dict_replay_buffer",
        "description": "maple.maple.data_management.obs_dict_replay_buffer",
        "peekOfCode": "def flatten_dict(dicts, keys):\n    \"\"\"\n    Turns list of dicts into dict of np arrays\n    \"\"\"\n    return {\n        key: flatten_n([d[key] for d in dicts])\n        for key in keys\n    }\ndef preprocess_obs_dict(obs_dict):\n    \"\"\"",
        "detail": "maple.maple.data_management.obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "preprocess_obs_dict",
        "kind": 2,
        "importPath": "maple.maple.data_management.obs_dict_replay_buffer",
        "description": "maple.maple.data_management.obs_dict_replay_buffer",
        "peekOfCode": "def preprocess_obs_dict(obs_dict):\n    \"\"\"\n    Apply internal replay buffer representation changes: save images as bytes\n    \"\"\"\n    for obs_key, obs in obs_dict.items():\n        if 'image' in obs_key and obs is not None:\n            obs_dict[obs_key] = unnormalize_image(obs)\n    return obs_dict\ndef postprocess_obs_dict(obs_dict):\n    \"\"\"",
        "detail": "maple.maple.data_management.obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "postprocess_obs_dict",
        "kind": 2,
        "importPath": "maple.maple.data_management.obs_dict_replay_buffer",
        "description": "maple.maple.data_management.obs_dict_replay_buffer",
        "peekOfCode": "def postprocess_obs_dict(obs_dict):\n    \"\"\"\n    Undo internal replay buffer representation changes: save images as bytes\n    \"\"\"\n    for obs_key, obs in obs_dict.items():\n        if 'image' in obs_key and obs is not None:\n            obs_dict[obs_key] = normalize_image(obs)\n    return obs_dict\ndef normalize_image(image):\n    assert image.dtype == np.uint8",
        "detail": "maple.maple.data_management.obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "normalize_image",
        "kind": 2,
        "importPath": "maple.maple.data_management.obs_dict_replay_buffer",
        "description": "maple.maple.data_management.obs_dict_replay_buffer",
        "peekOfCode": "def normalize_image(image):\n    assert image.dtype == np.uint8\n    return np.float64(image) / 255.0\ndef unnormalize_image(image):\n    assert image.dtype != np.uint8\n    return np.uint8(image * 255.0)",
        "detail": "maple.maple.data_management.obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "unnormalize_image",
        "kind": 2,
        "importPath": "maple.maple.data_management.obs_dict_replay_buffer",
        "description": "maple.maple.data_management.obs_dict_replay_buffer",
        "peekOfCode": "def unnormalize_image(image):\n    assert image.dtype != np.uint8\n    return np.uint8(image * 255.0)",
        "detail": "maple.maple.data_management.obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "OnlineVaeRelabelingBuffer",
        "kind": 6,
        "importPath": "maple.maple.data_management.online_vae_replay_buffer",
        "description": "maple.maple.data_management.online_vae_replay_buffer",
        "peekOfCode": "class OnlineVaeRelabelingBuffer(SharedObsDictRelabelingBuffer):\n    def __init__(\n            self,\n            vae,\n            *args,\n            decoded_obs_key='image_observation',\n            decoded_achieved_goal_key='image_achieved_goal',\n            decoded_desired_goal_key='image_desired_goal',\n            exploration_rewards_type='None',\n            exploration_rewards_scale=1.0,",
        "detail": "maple.maple.data_management.online_vae_replay_buffer",
        "documentation": {}
    },
    {
        "label": "PathBuilder",
        "kind": 6,
        "importPath": "maple.maple.data_management.path_builder",
        "description": "maple.maple.data_management.path_builder",
        "peekOfCode": "class PathBuilder(dict):\n    \"\"\"\n    Usage:\n    ```\n    path_builder = PathBuilder()\n    path.add_sample(\n        observations=1,\n        actions=2,\n        next_observations=3,\n        ...",
        "detail": "maple.maple.data_management.path_builder",
        "documentation": {}
    },
    {
        "label": "stack_list",
        "kind": 2,
        "importPath": "maple.maple.data_management.path_builder",
        "description": "maple.maple.data_management.path_builder",
        "peekOfCode": "def stack_list(lst):\n    if isinstance(lst[0], dict):\n        return lst\n    else:\n        return np.array(lst)",
        "detail": "maple.maple.data_management.path_builder",
        "documentation": {}
    },
    {
        "label": "ReplayBuffer",
        "kind": 6,
        "importPath": "maple.maple.data_management.replay_buffer",
        "description": "maple.maple.data_management.replay_buffer",
        "peekOfCode": "class ReplayBuffer(object, metaclass=abc.ABCMeta):\n    \"\"\"\n    A class used to save and replay data.\n    \"\"\"\n    @abc.abstractmethod\n    def add_sample(self, observation, action, reward, next_observation,\n                   terminal, **kwargs):\n        \"\"\"\n        Add a transition tuple.\n        \"\"\"",
        "detail": "maple.maple.data_management.replay_buffer",
        "documentation": {}
    },
    {
        "label": "SharedObsDictRelabelingBuffer",
        "kind": 6,
        "importPath": "maple.maple.data_management.shared_obs_dict_replay_buffer",
        "description": "maple.maple.data_management.shared_obs_dict_replay_buffer",
        "peekOfCode": "class SharedObsDictRelabelingBuffer(ObsDictRelabelingBuffer):\n    \"\"\"\n    Same as an ObsDictRelabelingBuffer but the obs and next_obs are backed\n    by multiprocessing arrays. The replay buffer size is also shared. The\n    intended use case is for if one wants obs/next_obs to be shared between\n    processes. Accesses are synchronized internally by locks (mp takes care\n    of that). Technically, putting such large arrays in shared memory/requiring\n    synchronized access can be extremely slow, but it seems ok empirically.\n    This code also breaks a lot of functionality for the subprocess. For example,\n    random_batch is incorrect as actions and _idx_to_future_obs_idx are not",
        "detail": "maple.maple.data_management.shared_obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "to_np",
        "kind": 2,
        "importPath": "maple.maple.data_management.shared_obs_dict_replay_buffer",
        "description": "maple.maple.data_management.shared_obs_dict_replay_buffer",
        "peekOfCode": "def to_np(shared_arr, np_dtype, shape):\n    return np.frombuffer(shared_arr.get_obj(), dtype=np_dtype).reshape(shape)",
        "detail": "maple.maple.data_management.shared_obs_dict_replay_buffer",
        "documentation": {}
    },
    {
        "label": "SimpleReplayBuffer",
        "kind": 6,
        "importPath": "maple.maple.data_management.simple_replay_buffer",
        "description": "maple.maple.data_management.simple_replay_buffer",
        "peekOfCode": "class SimpleReplayBuffer(ReplayBuffer):\n    def __init__(\n        self,\n        max_replay_buffer_size,\n        observation_dim,\n        action_dim,\n        env_info_sizes,\n        replace = True,\n    ):\n        self._observation_dim = observation_dim",
        "detail": "maple.maple.data_management.simple_replay_buffer",
        "documentation": {}
    },
    {
        "label": "SplitReplayBuffer",
        "kind": 6,
        "importPath": "maple.maple.data_management.split_buffer",
        "description": "maple.maple.data_management.split_buffer",
        "peekOfCode": "class SplitReplayBuffer(ReplayBuffer):\n    \"\"\"\n    Split the data into a training and validation set.\n    \"\"\"\n    def __init__(\n            self,\n            train_replay_buffer: ReplayBuffer,\n            validation_replay_buffer: ReplayBuffer,\n            fraction_paths_in_train,\n    ):",
        "detail": "maple.maple.data_management.split_buffer",
        "documentation": {}
    },
    {
        "label": "DiscretizeEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers.discretize_env",
        "description": "maple.maple.envs.wrappers.discretize_env",
        "peekOfCode": "class DiscretizeEnv(ProxyEnv, Env):\n    def __init__(self, wrapped_env, num_bins):\n        super().__init__(wrapped_env)\n        low = self.wrapped_env.action_space.low\n        high = self.wrapped_env.action_space.high\n        action_ranges = [\n            np.linspace(low[i], high[i], num_bins)\n            for i in range(len(low))\n        ]\n        self.idx_to_continuous_action = [",
        "detail": "maple.maple.envs.wrappers.discretize_env",
        "documentation": {}
    },
    {
        "label": "HistoryEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers.history_env",
        "description": "maple.maple.envs.wrappers.history_env",
        "peekOfCode": "class HistoryEnv(ProxyEnv, Env):\n    def __init__(self, wrapped_env, history_len):\n        super().__init__(wrapped_env)\n        self.history_len = history_len\n        high = np.inf * np.ones(\n            self.history_len * self.observation_space.low.size)\n        low = -high\n        self.observation_space = Box(low=low,\n                                     high=high,\n                                     )",
        "detail": "maple.maple.envs.wrappers.history_env",
        "documentation": {}
    },
    {
        "label": "ImageMujocoEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers.image_mujoco_env",
        "description": "maple.maple.envs.wrappers.image_mujoco_env",
        "peekOfCode": "class ImageMujocoEnv(ProxyEnv, Env):\n    def __init__(self,\n                 wrapped_env,\n                 imsize=32,\n                 keep_prev=0,\n                 init_camera=None,\n                 camera_name=None,\n                 transpose=False,\n                 grayscale=False,\n                 normalize=False,",
        "detail": "maple.maple.envs.wrappers.image_mujoco_env",
        "documentation": {}
    },
    {
        "label": "ImageMujocoWithObsEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers.image_mujoco_env_with_obs",
        "description": "maple.maple.envs.wrappers.image_mujoco_env_with_obs",
        "peekOfCode": "class ImageMujocoWithObsEnv(ImageMujocoEnv):\n    def __init__(self, env, **kwargs):\n        super().__init__(env, **kwargs)\n        self.observation_space = Box(\n            low=0.0,\n            high=1.0,\n            shape=(self.image_length * self.history_length\n                   + self.wrapped_env.obs_dim,))\n    def _get_obs(self, history_flat, true_state):\n        return np.concatenate([history_flat, true_state])",
        "detail": "maple.maple.envs.wrappers.image_mujoco_env_with_obs",
        "documentation": {}
    },
    {
        "label": "NormalizedBoxEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers.normalized_box_env",
        "description": "maple.maple.envs.wrappers.normalized_box_env",
        "peekOfCode": "class NormalizedBoxEnv(ProxyEnv):\n    \"\"\"\n    Normalize action to in [-1, 1].\n    Optionally normalize observations and scale reward.\n    \"\"\"\n    def __init__(\n            self,\n            env,\n            reward_scale=1.,\n            obs_mean=None,",
        "detail": "maple.maple.envs.wrappers.normalized_box_env",
        "documentation": {}
    },
    {
        "label": "RewardWrapperEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers.reward_wrapper_env",
        "description": "maple.maple.envs.wrappers.reward_wrapper_env",
        "peekOfCode": "class RewardWrapperEnv(ProxyEnv):\n    \"\"\"Substitute a different reward function\"\"\"\n    def __init__(\n            self,\n            env,\n            compute_reward_fn,\n    ):\n        ProxyEnv.__init__(self, env)\n        self.spec = env.spec # hack for hand envs\n        self.compute_reward_fn = compute_reward_fn",
        "detail": "maple.maple.envs.wrappers.reward_wrapper_env",
        "documentation": {}
    },
    {
        "label": "StackObservationEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers.stack_observation_env",
        "description": "maple.maple.envs.wrappers.stack_observation_env",
        "peekOfCode": "class StackObservationEnv(ProxyEnv):\n    \"\"\"\n    Env wrapper for passing history of observations as the new observation\n    \"\"\"\n    def __init__(\n            self,\n            env,\n            stack_obs=1,\n    ):\n        ProxyEnv.__init__(self, env)",
        "detail": "maple.maple.envs.wrappers.stack_observation_env",
        "documentation": {}
    },
    {
        "label": "get_asset_full_path",
        "kind": 2,
        "importPath": "maple.maple.envs.env_utils",
        "description": "maple.maple.envs.env_utils",
        "peekOfCode": "def get_asset_full_path(file_name):\n    return os.path.join(ENV_ASSET_DIR, file_name)\ndef get_dim(space):\n    if isinstance(space, Box):\n        return space.low.size\n    elif isinstance(space, Discrete):\n        return space.n\n    elif isinstance(space, Tuple):\n        return sum(get_dim(subspace) for subspace in space.spaces)\n    elif hasattr(space, 'flat_dim'):",
        "detail": "maple.maple.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "get_dim",
        "kind": 2,
        "importPath": "maple.maple.envs.env_utils",
        "description": "maple.maple.envs.env_utils",
        "peekOfCode": "def get_dim(space):\n    if isinstance(space, Box):\n        return space.low.size\n    elif isinstance(space, Discrete):\n        return space.n\n    elif isinstance(space, Tuple):\n        return sum(get_dim(subspace) for subspace in space.spaces)\n    elif hasattr(space, 'flat_dim'):\n        return space.flat_dim\n    else:",
        "detail": "maple.maple.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "mode",
        "kind": 2,
        "importPath": "maple.maple.envs.env_utils",
        "description": "maple.maple.envs.env_utils",
        "peekOfCode": "def mode(env, mode_type):\n    try:\n        getattr(env, mode_type)()\n    except AttributeError:\n        pass",
        "detail": "maple.maple.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "ENV_ASSET_DIR",
        "kind": 5,
        "importPath": "maple.maple.envs.env_utils",
        "description": "maple.maple.envs.env_utils",
        "peekOfCode": "ENV_ASSET_DIR = os.path.join(os.path.dirname(__file__), 'assets')\ndef get_asset_full_path(file_name):\n    return os.path.join(ENV_ASSET_DIR, file_name)\ndef get_dim(space):\n    if isinstance(space, Box):\n        return space.low.size\n    elif isinstance(space, Discrete):\n        return space.n\n    elif isinstance(space, Tuple):\n        return sum(get_dim(subspace) for subspace in space.spaces)",
        "detail": "maple.maple.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "maple.maple.envs.make_env",
        "description": "maple.maple.envs.make_env",
        "peekOfCode": "def make(env_id=None, env_class=None, env_kwargs=None, normalize_env=True):\n    assert env_id or env_class\n    if env_class:\n        env = env_class(**env_kwargs)\n    elif env_id in DAPG_ENVS:\n        import mj_envs\n        assert normalize_env == False\n        env = gym.make(env_id)\n    elif env_id in D4RL_ENVS:\n        import d4rl",
        "detail": "maple.maple.envs.make_env",
        "documentation": {}
    },
    {
        "label": "DAPG_ENVS",
        "kind": 5,
        "importPath": "maple.maple.envs.make_env",
        "description": "maple.maple.envs.make_env",
        "peekOfCode": "DAPG_ENVS = [\n    'pen-v0', 'pen-sparse-v0', 'pen-notermination-v0', 'pen-binary-v0', 'pen-binary-old-v0',\n    'door-v0', 'door-sparse-v0', 'door-binary-v0', 'door-binary-old-v0',\n    'relocate-v0', 'relocate-sparse-v0', 'relocate-binary-v0', 'relocate-binary-old-v0',\n    'hammer-v0', 'hammer-sparse-v0', 'hammer-binary-v0',\n]\nD4RL_ENVS = [\n    \"maze2d-open-v0\", \"maze2d-umaze-v0\", \"maze2d-medium-v0\", \"maze2d-large-v0\",\n    \"maze2d-open-dense-v0\", \"maze2d-umaze-dense-v0\", \"maze2d-medium-dense-v0\", \"maze2d-large-dense-v0\",\n    \"antmaze-umaze-v0\", \"antmaze-umaze-diverse-v0\", \"antmaze-medium-diverse-v0\",",
        "detail": "maple.maple.envs.make_env",
        "documentation": {}
    },
    {
        "label": "D4RL_ENVS",
        "kind": 5,
        "importPath": "maple.maple.envs.make_env",
        "description": "maple.maple.envs.make_env",
        "peekOfCode": "D4RL_ENVS = [\n    \"maze2d-open-v0\", \"maze2d-umaze-v0\", \"maze2d-medium-v0\", \"maze2d-large-v0\",\n    \"maze2d-open-dense-v0\", \"maze2d-umaze-dense-v0\", \"maze2d-medium-dense-v0\", \"maze2d-large-dense-v0\",\n    \"antmaze-umaze-v0\", \"antmaze-umaze-diverse-v0\", \"antmaze-medium-diverse-v0\",\n    \"antmaze-medium-play-v0\", \"antmaze-large-diverse-v0\", \"antmaze-large-play-v0\",\n    \"pen-human-v0\", \"pen-cloned-v0\", \"pen-expert-v0\", \"hammer-human-v0\", \"hammer-cloned-v0\", \"hammer-expert-v0\",\n    \"door-human-v0\", \"door-cloned-v0\", \"door-expert-v0\", \"relocate-human-v0\", \"relocate-cloned-v0\", \"relocate-expert-v0\",\n    \"halfcheetah-random-v0\", \"halfcheetah-medium-v0\", \"halfcheetah-expert-v0\", \"halfcheetah-mixed-v0\", \"halfcheetah-medium-expert-v0\",\n    \"walker2d-random-v0\", \"walker2d-medium-v0\", \"walker2d-expert-v0\", \"walker2d-mixed-v0\", \"walker2d-medium-expert-v0\",\n    \"hopper-random-v0\", \"hopper-medium-v0\", \"hopper-expert-v0\", \"hopper-mixed-v0\", \"hopper-medium-expert-v0\"",
        "detail": "maple.maple.envs.make_env",
        "documentation": {}
    },
    {
        "label": "MujocoEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.mujoco_env",
        "description": "maple.maple.envs.mujoco_env",
        "peekOfCode": "class MujocoEnv(mujoco_env.MujocoEnv, Serializable):\n    \"\"\"\n    My own wrapper around MujocoEnv.\n    The caller needs to declare\n    \"\"\"\n    def __init__(\n            self,\n            model_path,\n            frame_skip=1,\n            model_path_is_local=True,",
        "detail": "maple.maple.envs.mujoco_env",
        "documentation": {}
    },
    {
        "label": "get_asset_xml",
        "kind": 2,
        "importPath": "maple.maple.envs.mujoco_env",
        "description": "maple.maple.envs.mujoco_env",
        "peekOfCode": "def get_asset_xml(xml_name):\n    return os.path.join(ENV_ASSET_DIR, xml_name)",
        "detail": "maple.maple.envs.mujoco_env",
        "documentation": {}
    },
    {
        "label": "ENV_ASSET_DIR",
        "kind": 5,
        "importPath": "maple.maple.envs.mujoco_env",
        "description": "maple.maple.envs.mujoco_env",
        "peekOfCode": "ENV_ASSET_DIR = os.path.join(os.path.dirname(__file__), 'assets')\nclass MujocoEnv(mujoco_env.MujocoEnv, Serializable):\n    \"\"\"\n    My own wrapper around MujocoEnv.\n    The caller needs to declare\n    \"\"\"\n    def __init__(\n            self,\n            model_path,\n            frame_skip=1,",
        "detail": "maple.maple.envs.mujoco_env",
        "documentation": {}
    },
    {
        "label": "ImageMujocoEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.mujoco_image_env",
        "description": "maple.maple.envs.mujoco_image_env",
        "peekOfCode": "class ImageMujocoEnv(ProxyEnv, Env):\n    def __init__(self,\n                 wrapped_env,\n                 imsize=32,\n                 keep_prev=0,\n                 init_camera=None,\n                 camera_name=None,\n                 transpose=False,\n                 grayscale=False,\n                 normalize=False,",
        "detail": "maple.maple.envs.mujoco_image_env",
        "documentation": {}
    },
    {
        "label": "ImageMujocoWithObsEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.mujoco_image_env",
        "description": "maple.maple.envs.mujoco_image_env",
        "peekOfCode": "class ImageMujocoWithObsEnv(ImageMujocoEnv):\n    def __init__(self, env, **kwargs):\n        super().__init__(env, **kwargs)\n        self.observation_space = Box(low=0.0,\n                                     high=1.0,\n                                     shape=(\n                                     self.image_length * self.history_length +\n                                     self.wrapped_env.obs_dim,))\n    def _get_obs(self, history_flat, true_state):\n        return np.concatenate([history_flat,",
        "detail": "maple.maple.envs.mujoco_image_env",
        "documentation": {}
    },
    {
        "label": "ProxyEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.proxy_env",
        "description": "maple.maple.envs.proxy_env",
        "peekOfCode": "class ProxyEnv(Env):\n    def __init__(self, wrapped_env):\n        self._wrapped_env = wrapped_env\n        self.action_space = self._wrapped_env.action_space\n        self.observation_space = self._wrapped_env.observation_space\n    @property\n    def wrapped_env(self):\n        return self._wrapped_env\n    def reset(self, **kwargs):\n        return self._wrapped_env.reset(**kwargs)",
        "detail": "maple.maple.envs.proxy_env",
        "documentation": {}
    },
    {
        "label": "VAEWrappedEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.vae_wrapper",
        "description": "maple.maple.envs.vae_wrapper",
        "peekOfCode": "class VAEWrappedEnv(ProxyEnv, MultitaskEnv):\n    \"\"\"This class wraps an image-based environment with a VAE.\n    Assumes you get flattened (channels,84,84) observations from wrapped_env.\n    This class adheres to the \"Silent Multitask Env\" semantics: on reset,\n    it resamples a goal.\n    \"\"\"\n    def __init__(\n        self,\n        wrapped_env,\n        vae,",
        "detail": "maple.maple.envs.vae_wrapper",
        "documentation": {}
    },
    {
        "label": "temporary_mode",
        "kind": 2,
        "importPath": "maple.maple.envs.vae_wrapper",
        "description": "maple.maple.envs.vae_wrapper",
        "peekOfCode": "def temporary_mode(env, mode, func, args=None, kwargs=None):\n    if args is None:\n        args = []\n    if kwargs is None:\n        kwargs = {}\n    cur_mode = env.cur_mode\n    env.mode(env._mode_map[mode])\n    return_val = func(*args, **kwargs)\n    env.mode(cur_mode)\n    return return_val",
        "detail": "maple.maple.envs.vae_wrapper",
        "documentation": {}
    },
    {
        "label": "ProxyEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers",
        "description": "maple.maple.envs.wrappers",
        "peekOfCode": "class ProxyEnv(Env):\n    def __init__(self, wrapped_env):\n        self._wrapped_env = wrapped_env\n        self.action_space = self._wrapped_env.action_space\n        self.observation_space = self._wrapped_env.observation_space\n    @property\n    def wrapped_env(self):\n        return self._wrapped_env\n    def reset(self, **kwargs):\n        return self._wrapped_env.reset(**kwargs)",
        "detail": "maple.maple.envs.wrappers",
        "documentation": {}
    },
    {
        "label": "HistoryEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers",
        "description": "maple.maple.envs.wrappers",
        "peekOfCode": "class HistoryEnv(ProxyEnv, Env):\n    def __init__(self, wrapped_env, history_len):\n        super().__init__(wrapped_env)\n        self.history_len = history_len\n        high = np.inf * np.ones(\n            self.history_len * self.observation_space.low.size)\n        low = -high\n        self.observation_space = Box(low=low,\n                                     high=high,\n                                     )",
        "detail": "maple.maple.envs.wrappers",
        "documentation": {}
    },
    {
        "label": "DiscretizeEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers",
        "description": "maple.maple.envs.wrappers",
        "peekOfCode": "class DiscretizeEnv(ProxyEnv, Env):\n    def __init__(self, wrapped_env, num_bins):\n        super().__init__(wrapped_env)\n        low = self.wrapped_env.action_space.low\n        high = self.wrapped_env.action_space.high\n        action_ranges = [\n            np.linspace(low[i], high[i], num_bins)\n            for i in range(len(low))\n        ]\n        self.idx_to_continuous_action = [",
        "detail": "maple.maple.envs.wrappers",
        "documentation": {}
    },
    {
        "label": "NormalizedBoxEnv",
        "kind": 6,
        "importPath": "maple.maple.envs.wrappers",
        "description": "maple.maple.envs.wrappers",
        "peekOfCode": "class NormalizedBoxEnv(ProxyEnv):\n    \"\"\"\n    Normalize action to in [-1, 1].\n    Optionally normalize observations and scale reward.\n    \"\"\"\n    def __init__(\n            self,\n            env,\n            reward_scale=1.,\n            obs_mean=None,",
        "detail": "maple.maple.envs.wrappers",
        "documentation": {}
    },
    {
        "label": "ExplorationStrategy",
        "kind": 6,
        "importPath": "maple.maple.exploration_strategies.base",
        "description": "maple.maple.exploration_strategies.base",
        "peekOfCode": "class ExplorationStrategy(object, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def get_action(self, t, observation, policy, **kwargs):\n        pass\n    def reset(self):\n        pass\nclass RawExplorationStrategy(ExplorationStrategy, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def get_action_from_raw_action(self, action, **kwargs):\n        pass",
        "detail": "maple.maple.exploration_strategies.base",
        "documentation": {}
    },
    {
        "label": "RawExplorationStrategy",
        "kind": 6,
        "importPath": "maple.maple.exploration_strategies.base",
        "description": "maple.maple.exploration_strategies.base",
        "peekOfCode": "class RawExplorationStrategy(ExplorationStrategy, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def get_action_from_raw_action(self, action, **kwargs):\n        pass\n    def get_action(self, t, policy, *args, **kwargs):\n        action, agent_info = policy.get_action(*args, **kwargs)\n        return self.get_action_from_raw_action(action, t=t), agent_info\n    def reset(self):\n        pass\nclass PolicyWrappedWithExplorationStrategy(ExplorationPolicy):",
        "detail": "maple.maple.exploration_strategies.base",
        "documentation": {}
    },
    {
        "label": "PolicyWrappedWithExplorationStrategy",
        "kind": 6,
        "importPath": "maple.maple.exploration_strategies.base",
        "description": "maple.maple.exploration_strategies.base",
        "peekOfCode": "class PolicyWrappedWithExplorationStrategy(ExplorationPolicy):\n    def __init__(\n            self,\n            exploration_strategy: ExplorationStrategy,\n            policy,\n    ):\n        self.es = exploration_strategy\n        self.policy = policy\n        self.t = 0\n    def set_num_steps_total(self, t):",
        "detail": "maple.maple.exploration_strategies.base",
        "documentation": {}
    },
    {
        "label": "EpsilonGreedy",
        "kind": 6,
        "importPath": "maple.maple.exploration_strategies.epsilon_greedy",
        "description": "maple.maple.exploration_strategies.epsilon_greedy",
        "peekOfCode": "class EpsilonGreedy(RawExplorationStrategy):\n    \"\"\"\n    Take a random discrete action with some probability.\n    \"\"\"\n    def __init__(self, action_space, prob_random_action=0.1):\n        self.prob_random_action = prob_random_action\n        self.action_space = action_space\n    def get_action_from_raw_action(self, action, **kwargs):\n        if random.random() <= self.prob_random_action:\n            return self.action_space.sample()",
        "detail": "maple.maple.exploration_strategies.epsilon_greedy",
        "documentation": {}
    },
    {
        "label": "GaussianAndEpsilonStrategy",
        "kind": 6,
        "importPath": "maple.maple.exploration_strategies.gaussian_and_epsilon_strategy",
        "description": "maple.maple.exploration_strategies.gaussian_and_epsilon_strategy",
        "peekOfCode": "class GaussianAndEpsilonStrategy(RawExplorationStrategy):\n    \"\"\"\n    With probability epsilon, take a completely random action.\n    with probability 1-epsilon, add Gaussian noise to the action taken by a\n    deterministic policy.\n    \"\"\"\n    def __init__(self, action_space, epsilon, max_sigma=1.0, min_sigma=None,\n                 decay_period=1000000):\n        assert len(action_space.shape) == 1\n        if min_sigma is None:",
        "detail": "maple.maple.exploration_strategies.gaussian_and_epsilon_strategy",
        "documentation": {}
    },
    {
        "label": "GaussianStrategy",
        "kind": 6,
        "importPath": "maple.maple.exploration_strategies.gaussian_strategy",
        "description": "maple.maple.exploration_strategies.gaussian_strategy",
        "peekOfCode": "class GaussianStrategy(RawExplorationStrategy):\n    \"\"\"\n    This strategy adds Gaussian noise to the action taken by the deterministic policy.\n    Based on the rllab implementation.\n    \"\"\"\n    def __init__(self, action_space, max_sigma=1.0, min_sigma=None,\n                 decay_period=1000000):\n        assert len(action_space.shape) == 1\n        self._max_sigma = max_sigma\n        if min_sigma is None:",
        "detail": "maple.maple.exploration_strategies.gaussian_strategy",
        "documentation": {}
    },
    {
        "label": "OUStrategy",
        "kind": 6,
        "importPath": "maple.maple.exploration_strategies.ou_strategy",
        "description": "maple.maple.exploration_strategies.ou_strategy",
        "peekOfCode": "class OUStrategy(RawExplorationStrategy):\n    \"\"\"\n    This strategy implements the Ornstein-Uhlenbeck process, which adds\n    time-correlated noise to the actions taken by the deterministic policy.\n    The OU process satisfies the following stochastic differential equation:\n    dxt = theta*(mu - xt)*dt + sigma*dWt\n    where Wt denotes the Wiener process\n    Based on the rllab implementation.\n    \"\"\"\n    def __init__(",
        "detail": "maple.maple.exploration_strategies.ou_strategy",
        "documentation": {}
    },
    {
        "label": "maple_project_dir",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "maple_project_dir = join(os.path.dirname(maple.__file__), os.pardir)\nrobosuite_project_dir = join(os.path.dirname(robosuite.__file__), os.pardir)\nLOCAL_LOG_DIR = join(maple_project_dir, 'data')\n\"\"\"\n********************************************************************************\n********************************************************************************\n********************************************************************************\nYou probably don't need to set all of the configurations below this line,\nunless you use AWS, GCP, Slurm, and/or Slurm on a remote server. I recommend\nignoring most of these things and only using them on an as-needed basis.",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "robosuite_project_dir",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "robosuite_project_dir = join(os.path.dirname(robosuite.__file__), os.pardir)\nLOCAL_LOG_DIR = join(maple_project_dir, 'data')\n\"\"\"\n********************************************************************************\n********************************************************************************\n********************************************************************************\nYou probably don't need to set all of the configurations below this line,\nunless you use AWS, GCP, Slurm, and/or Slurm on a remote server. I recommend\nignoring most of these things and only using them on an as-needed basis.\n********************************************************************************",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "LOCAL_LOG_DIR",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "LOCAL_LOG_DIR = join(maple_project_dir, 'data')\n\"\"\"\n********************************************************************************\n********************************************************************************\n********************************************************************************\nYou probably don't need to set all of the configurations below this line,\nunless you use AWS, GCP, Slurm, and/or Slurm on a remote server. I recommend\nignoring most of these things and only using them on an as-needed basis.\n********************************************************************************\n********************************************************************************",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "CODE_DIRS_TO_MOUNT",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "CODE_DIRS_TO_MOUNT = [\n    maple_project_dir,\n    robosuite_project_dir,\n    # '/home/user/python/module/one', Add more paths as needed\n]\nHOME = os.getenv('HOME') if os.getenv('HOME') is not None else os.getenv(\"USERPROFILE\")\nDIR_AND_MOUNT_POINT_MAPPINGS = [\n    dict(\n        local_dir=join(HOME, '.mujoco/'),\n        mount_point='/root/.mujoco',",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "HOME",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "HOME = os.getenv('HOME') if os.getenv('HOME') is not None else os.getenv(\"USERPROFILE\")\nDIR_AND_MOUNT_POINT_MAPPINGS = [\n    dict(\n        local_dir=join(HOME, '.mujoco/'),\n        mount_point='/root/.mujoco',\n    ),\n]\nRUN_DOODAD_EXPERIMENT_SCRIPT_PATH = (\n    join(maple_project_dir, 'scripts', 'run_experiment_from_doodad.py')\n    # '/home/user/path/to/maple/scripts/run_experiment_from_doodad.py'",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "DIR_AND_MOUNT_POINT_MAPPINGS",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "DIR_AND_MOUNT_POINT_MAPPINGS = [\n    dict(\n        local_dir=join(HOME, '.mujoco/'),\n        mount_point='/root/.mujoco',\n    ),\n]\nRUN_DOODAD_EXPERIMENT_SCRIPT_PATH = (\n    join(maple_project_dir, 'scripts', 'run_experiment_from_doodad.py')\n    # '/home/user/path/to/maple/scripts/run_experiment_from_doodad.py'\n)",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "RUN_DOODAD_EXPERIMENT_SCRIPT_PATH",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "RUN_DOODAD_EXPERIMENT_SCRIPT_PATH = (\n    join(maple_project_dir, 'scripts', 'run_experiment_from_doodad.py')\n    # '/home/user/path/to/maple/scripts/run_experiment_from_doodad.py'\n)\n\"\"\"\nAWS Settings\n\"\"\"\n# If not set, default will be chosen by doodad\n# AWS_S3_PATH = 's3://bucket/directory\n# The docker image is looked up on dockerhub.com.",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "DOODAD_DOCKER_IMAGE",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "DOODAD_DOCKER_IMAGE = \"TODO\"\nINSTANCE_TYPE = 'c4.large'\nSPOT_PRICE = 0.03\nGPU_DOODAD_DOCKER_IMAGE = \"TODO\"\nGPU_INSTANCE_TYPE = 'g2.2xlarge'\nGPU_SPOT_PRICE = 0.5\n# You can use AMI images with the docker images already installed.\nREGION_TO_GPU_AWS_IMAGE_ID = {\n    'us-west-1': \"TODO\",\n    'us-east-1': \"TODO\",",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "INSTANCE_TYPE",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "INSTANCE_TYPE = 'c4.large'\nSPOT_PRICE = 0.03\nGPU_DOODAD_DOCKER_IMAGE = \"TODO\"\nGPU_INSTANCE_TYPE = 'g2.2xlarge'\nGPU_SPOT_PRICE = 0.5\n# You can use AMI images with the docker images already installed.\nREGION_TO_GPU_AWS_IMAGE_ID = {\n    'us-west-1': \"TODO\",\n    'us-east-1': \"TODO\",\n}",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SPOT_PRICE",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SPOT_PRICE = 0.03\nGPU_DOODAD_DOCKER_IMAGE = \"TODO\"\nGPU_INSTANCE_TYPE = 'g2.2xlarge'\nGPU_SPOT_PRICE = 0.5\n# You can use AMI images with the docker images already installed.\nREGION_TO_GPU_AWS_IMAGE_ID = {\n    'us-west-1': \"TODO\",\n    'us-east-1': \"TODO\",\n}\nREGION_TO_GPU_AWS_AVAIL_ZONE = {",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "GPU_DOODAD_DOCKER_IMAGE",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "GPU_DOODAD_DOCKER_IMAGE = \"TODO\"\nGPU_INSTANCE_TYPE = 'g2.2xlarge'\nGPU_SPOT_PRICE = 0.5\n# You can use AMI images with the docker images already installed.\nREGION_TO_GPU_AWS_IMAGE_ID = {\n    'us-west-1': \"TODO\",\n    'us-east-1': \"TODO\",\n}\nREGION_TO_GPU_AWS_AVAIL_ZONE = {\n    'us-east-1': \"us-east-1b\",",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "GPU_INSTANCE_TYPE",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "GPU_INSTANCE_TYPE = 'g2.2xlarge'\nGPU_SPOT_PRICE = 0.5\n# You can use AMI images with the docker images already installed.\nREGION_TO_GPU_AWS_IMAGE_ID = {\n    'us-west-1': \"TODO\",\n    'us-east-1': \"TODO\",\n}\nREGION_TO_GPU_AWS_AVAIL_ZONE = {\n    'us-east-1': \"us-east-1b\",\n}",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "GPU_SPOT_PRICE",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "GPU_SPOT_PRICE = 0.5\n# You can use AMI images with the docker images already installed.\nREGION_TO_GPU_AWS_IMAGE_ID = {\n    'us-west-1': \"TODO\",\n    'us-east-1': \"TODO\",\n}\nREGION_TO_GPU_AWS_AVAIL_ZONE = {\n    'us-east-1': \"us-east-1b\",\n}\n# This really shouldn't matter and in theory could be whatever",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "REGION_TO_GPU_AWS_IMAGE_ID",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "REGION_TO_GPU_AWS_IMAGE_ID = {\n    'us-west-1': \"TODO\",\n    'us-east-1': \"TODO\",\n}\nREGION_TO_GPU_AWS_AVAIL_ZONE = {\n    'us-east-1': \"us-east-1b\",\n}\n# This really shouldn't matter and in theory could be whatever\nOUTPUT_DIR_FOR_DOODAD_TARGET = '/tmp/doodad-output/'\n\"\"\"",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "REGION_TO_GPU_AWS_AVAIL_ZONE",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "REGION_TO_GPU_AWS_AVAIL_ZONE = {\n    'us-east-1': \"us-east-1b\",\n}\n# This really shouldn't matter and in theory could be whatever\nOUTPUT_DIR_FOR_DOODAD_TARGET = '/tmp/doodad-output/'\n\"\"\"\nSlurm Settings\n\"\"\"\nSINGULARITY_IMAGE = '/home/PATH/TO/IMAGE.img'\n# This assumes you saved mujoco to $HOME/.mujoco",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR_FOR_DOODAD_TARGET",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "OUTPUT_DIR_FOR_DOODAD_TARGET = '/tmp/doodad-output/'\n\"\"\"\nSlurm Settings\n\"\"\"\nSINGULARITY_IMAGE = '/home/PATH/TO/IMAGE.img'\n# This assumes you saved mujoco to $HOME/.mujoco\nSINGULARITY_PRE_CMDS = [\n    'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/.mujoco/mjpro150/bin'\n]\nSLURM_CPU_CONFIG = dict(",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SINGULARITY_IMAGE",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SINGULARITY_IMAGE = '/home/PATH/TO/IMAGE.img'\n# This assumes you saved mujoco to $HOME/.mujoco\nSINGULARITY_PRE_CMDS = [\n    'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/.mujoco/mjpro150/bin'\n]\nSLURM_CPU_CONFIG = dict(\n    account_name='TODO',\n    partition='savio',\n    nodes=1,\n    n_tasks=1,",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SINGULARITY_PRE_CMDS",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SINGULARITY_PRE_CMDS = [\n    'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/.mujoco/mjpro150/bin'\n]\nSLURM_CPU_CONFIG = dict(\n    account_name='TODO',\n    partition='savio',\n    nodes=1,\n    n_tasks=1,\n    n_gpus=1,\n)",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SLURM_CPU_CONFIG",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SLURM_CPU_CONFIG = dict(\n    account_name='TODO',\n    partition='savio',\n    nodes=1,\n    n_tasks=1,\n    n_gpus=1,\n)\nSLURM_GPU_CONFIG = dict(\n    account_name='TODO',\n    partition='savio2_1080ti',",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SLURM_GPU_CONFIG",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SLURM_GPU_CONFIG = dict(\n    account_name='TODO',\n    partition='savio2_1080ti',\n    nodes=1,\n    n_tasks=1,\n    n_gpus=1,\n)\n\"\"\"\nSlurm Script Settings\nThese are basically the same settings as above, but for the remote machine",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SSS_CODE_DIRS_TO_MOUNT",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SSS_CODE_DIRS_TO_MOUNT = [\n]\nSSS_DIR_AND_MOUNT_POINT_MAPPINGS = [\n    dict(\n        local_dir='/global/home/users/USERNAME/.mujoco',\n        mount_point='/root/.mujoco',\n    ),\n]\nSSS_LOG_DIR = '/global/scratch/USERNAME/doodad-log'\nSSS_IMAGE = '/global/scratch/USERNAME/TODO.img'",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SSS_DIR_AND_MOUNT_POINT_MAPPINGS",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SSS_DIR_AND_MOUNT_POINT_MAPPINGS = [\n    dict(\n        local_dir='/global/home/users/USERNAME/.mujoco',\n        mount_point='/root/.mujoco',\n    ),\n]\nSSS_LOG_DIR = '/global/scratch/USERNAME/doodad-log'\nSSS_IMAGE = '/global/scratch/USERNAME/TODO.img'\nSSS_RUN_DOODAD_EXPERIMENT_SCRIPT_PATH = (\n    '/global/home/users/USERNAME/path/to/maple/scripts'",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SSS_LOG_DIR",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SSS_LOG_DIR = '/global/scratch/USERNAME/doodad-log'\nSSS_IMAGE = '/global/scratch/USERNAME/TODO.img'\nSSS_RUN_DOODAD_EXPERIMENT_SCRIPT_PATH = (\n    '/global/home/users/USERNAME/path/to/maple/scripts'\n    '/run_experiment_from_doodad.py'\n)\nSSS_PRE_CMDS = [\n    'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/global/home/users/USERNAME'\n    '/.mujoco/mjpro150/bin'\n]",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SSS_IMAGE",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SSS_IMAGE = '/global/scratch/USERNAME/TODO.img'\nSSS_RUN_DOODAD_EXPERIMENT_SCRIPT_PATH = (\n    '/global/home/users/USERNAME/path/to/maple/scripts'\n    '/run_experiment_from_doodad.py'\n)\nSSS_PRE_CMDS = [\n    'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/global/home/users/USERNAME'\n    '/.mujoco/mjpro150/bin'\n]\n\"\"\"",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SSS_RUN_DOODAD_EXPERIMENT_SCRIPT_PATH",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SSS_RUN_DOODAD_EXPERIMENT_SCRIPT_PATH = (\n    '/global/home/users/USERNAME/path/to/maple/scripts'\n    '/run_experiment_from_doodad.py'\n)\nSSS_PRE_CMDS = [\n    'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/global/home/users/USERNAME'\n    '/.mujoco/mjpro150/bin'\n]\n\"\"\"\nGCP Settings",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "SSS_PRE_CMDS",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "SSS_PRE_CMDS = [\n    'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/global/home/users/USERNAME'\n    '/.mujoco/mjpro150/bin'\n]\n\"\"\"\nGCP Settings\n\"\"\"\nGCP_IMAGE_NAME = 'TODO'\nGCP_GPU_IMAGE_NAME = 'TODO'\nGCP_BUCKET_NAME = 'TODO'",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "GCP_IMAGE_NAME",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "GCP_IMAGE_NAME = 'TODO'\nGCP_GPU_IMAGE_NAME = 'TODO'\nGCP_BUCKET_NAME = 'TODO'\nGCP_DEFAULT_KWARGS = dict(\n    zone='us-west2-c',\n    instance_type='n1-standard-4',\n    image_project='TODO',\n    terminate=True,\n    preemptible=True,\n    gpu_kwargs=dict(",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "GCP_GPU_IMAGE_NAME",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "GCP_GPU_IMAGE_NAME = 'TODO'\nGCP_BUCKET_NAME = 'TODO'\nGCP_DEFAULT_KWARGS = dict(\n    zone='us-west2-c',\n    instance_type='n1-standard-4',\n    image_project='TODO',\n    terminate=True,\n    preemptible=True,\n    gpu_kwargs=dict(\n        gpu_model='nvidia-tesla-p4',",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "GCP_BUCKET_NAME",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "GCP_BUCKET_NAME = 'TODO'\nGCP_DEFAULT_KWARGS = dict(\n    zone='us-west2-c',\n    instance_type='n1-standard-4',\n    image_project='TODO',\n    terminate=True,\n    preemptible=True,\n    gpu_kwargs=dict(\n        gpu_model='nvidia-tesla-p4',\n        num_gpu=1,",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "GCP_DEFAULT_KWARGS",
        "kind": 5,
        "importPath": "maple.maple.launchers.conf",
        "description": "maple.maple.launchers.conf",
        "peekOfCode": "GCP_DEFAULT_KWARGS = dict(\n    zone='us-west2-c',\n    instance_type='n1-standard-4',\n    image_project='TODO',\n    terminate=True,\n    preemptible=True,\n    gpu_kwargs=dict(\n        gpu_model='nvidia-tesla-p4',\n        num_gpu=1,\n    )",
        "detail": "maple.maple.launchers.conf",
        "documentation": {}
    },
    {
        "label": "get_git_infos",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def get_git_infos(dirs):\n    try:\n        import git\n        git_infos = []\n        for directory in dirs:\n            # Idk how to query these things, so I'm just doing try-catch\n            try:\n                repo = git.Repo(directory)\n                try:\n                    branch_name = repo.active_branch.name",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "recursive_items",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def recursive_items(dictionary):\n    \"\"\"\n    Get all (key, item) recursively in a potentially recursive dictionary.\n    Usage:\n    ```\n    x = {\n        'foo' : {\n            'bar' : 5\n        }\n    }",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "save_experiment_data",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def save_experiment_data(dictionary, log_dir):\n    with open(log_dir + '/experiment.pkl', 'wb') as handle:\n        pickle.dump(dictionary, handle, protocol=pickle.HIGHEST_PROTOCOL)\ndef run_experiment_here(\n        experiment_function,\n        variant=None,\n        exp_id=0,\n        seed=None,\n        use_gpu=True,\n        gpu_id=0,",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "run_experiment_here",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def run_experiment_here(\n        experiment_function,\n        variant=None,\n        exp_id=0,\n        seed=None,\n        use_gpu=True,\n        gpu_id=0,\n        # Logger params:\n        exp_prefix=\"default\",\n        snapshot_mode='last',",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "create_exp_name",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def create_exp_name(exp_prefix, exp_id=0, seed=0):\n    \"\"\"\n    Create a semi-unique experiment name that has a timestamp\n    :param exp_prefix:\n    :param exp_id:\n    :return:\n    \"\"\"\n    now = datetime.datetime.now(dateutil.tz.tzlocal())\n    timestamp = now.strftime('%Y_%m_%d_%H_%M_%S')\n    return \"%s_%s_%04d--s-%d\" % (exp_prefix, timestamp, exp_id, seed)",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "create_log_dir",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def create_log_dir(\n        exp_prefix,\n        exp_id=0,\n        seed=0,\n        base_log_dir=None,\n        include_exp_prefix_sub_dir=True,\n):\n    \"\"\"\n    Creates and returns a unique log directory.\n    :param exp_prefix: All experiments with this prefix will have log",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def setup_logger(\n        exp_prefix=\"default\",\n        variant=None,\n        text_log_file=\"debug.log\",\n        variant_log_file=\"variant.json\",\n        tabular_log_file=\"progress.csv\",\n        snapshot_mode=\"last\",\n        snapshot_gap=1,\n        log_tabular_only=False,\n        log_dir=None,",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "dict_to_safe_json",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def dict_to_safe_json(d):\n    \"\"\"\n    Convert each value in the dictionary into a JSON'able primitive.\n    :param d:\n    :return:\n    \"\"\"\n    new_d = {}\n    for key, item in d.items():\n        if safe_json(item):\n            new_d[key] = item",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "safe_json",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def safe_json(data):\n    if data is None:\n        return True\n    elif isinstance(data, (bool, int, float)):\n        return True\n    elif isinstance(data, (tuple, list)):\n        return all(safe_json(x) for x in data)\n    elif isinstance(data, dict):\n        return all(isinstance(k, str) and safe_json(v) for k, v in data.items())\n    return False",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "set_seed",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def set_seed(seed):\n    \"\"\"\n    Set the seed for all the possible random number generators.\n    :param seed:\n    :return: None\n    \"\"\"\n    seed = int(seed)\n    random.seed(seed)\n    np.random.seed(seed)\ndef reset_execution_environment():",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "reset_execution_environment",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def reset_execution_environment():\n    \"\"\"\n    Call this between calls to separate experiments.\n    :return:\n    \"\"\"\n    logger.reset()\ndef query_yes_no(question, default=\"yes\"):\n    \"\"\"Ask a yes/no question via raw_input() and return their answer.\n    \"question\" is a string that is presented to the user.\n    \"default\" is the presumed answer if the user just hits <Enter>.",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "query_yes_no",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def query_yes_no(question, default=\"yes\"):\n    \"\"\"Ask a yes/no question via raw_input() and return their answer.\n    \"question\" is a string that is presented to the user.\n    \"default\" is the presumed answer if the user just hits <Enter>.\n        It must be \"yes\" (the default), \"no\" or None (meaning\n        an answer is required of the user).\n    The \"answer\" return value is True for \"yes\" or False for \"no\".\n    \"\"\"\n    valid = {\"yes\": True, \"y\": True, \"ye\": True,\n             \"no\": False, \"n\": False}",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "run_experiment",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def run_experiment(\n        method_call,\n        mode='local',\n        exp_folder=None,\n        exp_prefix='default',\n        seed=None,\n        variant=None,\n        exp_id=0,\n        prepend_date_to_exp_prefix=True,\n        use_gpu=False,",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "create_mounts",
        "kind": 2,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "def create_mounts(\n        mode,\n        base_log_dir,\n        sync_interval=180,\n        local_input_dir_to_mount_point_dict=None,\n):\n    if mode == 'sss':\n        code_mounts = SSS_CODE_MOUNTS\n        non_code_mounts = SSS_NON_CODE_MOUNTS\n    else:",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "GitInfo",
        "kind": 5,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "GitInfo = namedtuple(\n    'GitInfo',\n    [\n        'directory',\n        'code_diff',\n        'code_diff_staged',\n        'commit_hash',\n        'branch_name',\n    ],\n)",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "ec2_okayed",
        "kind": 5,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "ec2_okayed = False\ngpu_ec2_okayed = False\nfirst_sss_launch = True\ntry:\n    import doodad.mount as mount\n    from doodad.utils import REPO_DIR\n    CODE_MOUNTS = [\n        mount.MountLocal(local_dir=REPO_DIR, pythonpath=True),\n    ]\n    for code_dir in conf.CODE_DIRS_TO_MOUNT:",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "gpu_ec2_okayed",
        "kind": 5,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "gpu_ec2_okayed = False\nfirst_sss_launch = True\ntry:\n    import doodad.mount as mount\n    from doodad.utils import REPO_DIR\n    CODE_MOUNTS = [\n        mount.MountLocal(local_dir=REPO_DIR, pythonpath=True),\n    ]\n    for code_dir in conf.CODE_DIRS_TO_MOUNT:\n        CODE_MOUNTS.append(mount.MountLocal(local_dir=code_dir, pythonpath=True))",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "first_sss_launch",
        "kind": 5,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "first_sss_launch = True\ntry:\n    import doodad.mount as mount\n    from doodad.utils import REPO_DIR\n    CODE_MOUNTS = [\n        mount.MountLocal(local_dir=REPO_DIR, pythonpath=True),\n    ]\n    for code_dir in conf.CODE_DIRS_TO_MOUNT:\n        CODE_MOUNTS.append(mount.MountLocal(local_dir=code_dir, pythonpath=True))\n    NON_CODE_MOUNTS = []",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "target_mount",
        "kind": 5,
        "importPath": "maple.maple.launchers.launcher_util",
        "description": "maple.maple.launchers.launcher_util",
        "peekOfCode": "target_mount = None\ndef run_experiment(\n        method_call,\n        mode='local',\n        exp_folder=None,\n        exp_prefix='default',\n        seed=None,\n        variant=None,\n        exp_id=0,\n        prepend_date_to_exp_prefix=True,",
        "detail": "maple.maple.launchers.launcher_util",
        "documentation": {}
    },
    {
        "label": "experiment",
        "kind": 2,
        "importPath": "maple.maple.launchers.robosuite_launcher",
        "description": "maple.maple.launchers.robosuite_launcher",
        "peekOfCode": "def experiment(variant):\n    def make_env(mode):\n        assert mode in ['expl', 'eval']\n        torch.set_num_threads(1)\n        env_variant = variant['env_variant']\n        controller_config = load_controller_config(default_controller=env_variant['controller_type'])\n        controller_config_update = env_variant.get('controller_config_update', {})\n        controller_config.update(controller_config_update)\n        robot_type = env_variant.get('robot_type', 'Panda')\n        obs_keys = env_variant['robot_keys'] + env_variant['obj_keys']",
        "detail": "maple.maple.launchers.robosuite_launcher",
        "documentation": {}
    },
    {
        "label": "get_ckpt_update_func",
        "kind": 2,
        "importPath": "maple.maple.launchers.robosuite_launcher",
        "description": "maple.maple.launchers.robosuite_launcher",
        "peekOfCode": "def get_ckpt_update_func(variant):\n    import os.path as osp\n    import torch\n    from maple.launchers.conf import LOCAL_LOG_DIR\n    def ckpt_update_func(algo, epoch):\n        if epoch == variant.get('ckpt_epoch', None) or epoch % algo._eval_epoch_freq == 0:\n            filename = osp.join(LOCAL_LOG_DIR, variant['ckpt_path'], 'itr_%d.pkl' % epoch)\n            try:\n                print(\"Loading ckpt from\", filename)\n                if ptu.gpu_enabled():",
        "detail": "maple.maple.launchers.robosuite_launcher",
        "documentation": {}
    },
    {
        "label": "get_video_save_func",
        "kind": 2,
        "importPath": "maple.maple.launchers.robosuite_launcher",
        "description": "maple.maple.launchers.robosuite_launcher",
        "peekOfCode": "def get_video_save_func(variant):\n    from maple.samplers.rollout_functions import rollout\n    from maple.launchers.visualization import dump_video\n    save_period = variant.get('save_video_period', 50)\n    dump_video_kwargs = variant.get(\"dump_video_kwargs\", dict())\n    dump_video_kwargs['horizon'] = variant['algorithm_kwargs']['max_path_length']\n    def video_save_func(algo, epoch):\n        if epoch % save_period == 0 or epoch == algo.num_epochs:\n            if variant.get('vis_expl', True):\n                dump_video(",
        "detail": "maple.maple.launchers.robosuite_launcher",
        "documentation": {}
    },
    {
        "label": "dump_video",
        "kind": 2,
        "importPath": "maple.maple.launchers.visualization",
        "description": "maple.maple.launchers.visualization",
        "peekOfCode": "def dump_video(\n        env,\n        policy,\n        rollout_function,\n        mode,\n        epoch,\n        rows=3,\n        columns=6,\n        pad_length=0,\n        pad_color=255,",
        "detail": "maple.maple.launchers.visualization",
        "documentation": {}
    },
    {
        "label": "dump_skillmap",
        "kind": 2,
        "importPath": "maple.maple.launchers.visualization",
        "description": "maple.maple.launchers.visualization",
        "peekOfCode": "def dump_skillmap(\n        env,\n        rollout_actions,\n        successes,\n        horizon,\n        logdir,\n        mode,\n        epoch,\n):\n    import matplotlib",
        "detail": "maple.maple.launchers.visualization",
        "documentation": {}
    },
    {
        "label": "get_image",
        "kind": 2,
        "importPath": "maple.maple.launchers.visualization",
        "description": "maple.maple.launchers.visualization",
        "peekOfCode": "def get_image(obs, imsize=84, pad_length=1, pad_color=255):\n    if len(obs.shape) == 1:\n        obs = obs.reshape(-1, imsize, imsize).transpose()\n    img = obs\n    # img = np.uint8(255 * img)\n    if pad_length > 0:\n        img = add_border(img, pad_length, pad_color, imsize=imsize)\n    return img\ndef add_border(img, pad_length, pad_color, imsize=84):\n    H = imsize",
        "detail": "maple.maple.launchers.visualization",
        "documentation": {}
    },
    {
        "label": "add_border",
        "kind": 2,
        "importPath": "maple.maple.launchers.visualization",
        "description": "maple.maple.launchers.visualization",
        "peekOfCode": "def add_border(img, pad_length, pad_color, imsize=84):\n    H = imsize\n    W = imsize\n    img = img.reshape((imsize, imsize, -1))\n    img2 = np.ones((H + 2 * pad_length, W + 2 * pad_length, img.shape[2]),\n                   dtype=np.uint8) * np.array(pad_color, dtype=np.uint8)\n    img2[pad_length:-pad_length, pad_length:-pad_length, :] = img\n    return img2\ndef annotate_image(img, text, imsize=84, color=(0, 0, 255), loc='ll'):\n    img = img.copy()",
        "detail": "maple.maple.launchers.visualization",
        "documentation": {}
    },
    {
        "label": "annotate_image",
        "kind": 2,
        "importPath": "maple.maple.launchers.visualization",
        "description": "maple.maple.launchers.visualization",
        "peekOfCode": "def annotate_image(img, text, imsize=84, color=(0, 0, 255), loc='ll'):\n    img = img.copy()\n    fontScale = 0.30 / 84 * imsize\n    if imsize == 1024:\n        thickness = 10\n        fontScale *= 1.5\n    elif imsize == 512:\n        thickness = 5\n    elif imsize == 84:\n        thickness = 1",
        "detail": "maple.maple.launchers.visualization",
        "documentation": {}
    },
    {
        "label": "normalize_image",
        "kind": 2,
        "importPath": "maple.maple.launchers.visualization",
        "description": "maple.maple.launchers.visualization",
        "peekOfCode": "def normalize_image(image):\n    assert image.dtype == np.uint8\n    return np.float32(image) / 255.0\ndef unormalize_image(image):\n    assert image.dtype != np.uint8\n    return np.uint8(image * 255.0)",
        "detail": "maple.maple.launchers.visualization",
        "documentation": {}
    },
    {
        "label": "unormalize_image",
        "kind": 2,
        "importPath": "maple.maple.launchers.visualization",
        "description": "maple.maple.launchers.visualization",
        "peekOfCode": "def unormalize_image(image):\n    assert image.dtype != np.uint8\n    return np.uint8(image * 255.0)",
        "detail": "maple.maple.launchers.visualization",
        "documentation": {}
    },
    {
        "label": "ArgmaxDiscretePolicy",
        "kind": 6,
        "importPath": "maple.maple.policies.argmax",
        "description": "maple.maple.policies.argmax",
        "peekOfCode": "class ArgmaxDiscretePolicy(nn.Module, Policy):\n    def __init__(self, qf):\n        super().__init__()\n        self.qf = qf\n    def get_action(self, obs):\n        obs = np.expand_dims(obs, axis=0)\n        obs = ptu.from_numpy(obs).float()\n        q_values = self.qf(obs).squeeze(0)\n        q_values_np = ptu.get_numpy(q_values)\n        return q_values_np.argmax(), {}",
        "detail": "maple.maple.policies.argmax",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "maple.maple.policies.base",
        "description": "maple.maple.policies.base",
        "peekOfCode": "class Policy(object, metaclass=abc.ABCMeta):\n    \"\"\"\n    General policy interface.\n    \"\"\"\n    @abc.abstractmethod\n    def get_action(self, observation):\n        \"\"\"\n        :param observation:\n        :return: action, debug_dictionary\n        \"\"\"",
        "detail": "maple.maple.policies.base",
        "documentation": {}
    },
    {
        "label": "ExplorationPolicy",
        "kind": 6,
        "importPath": "maple.maple.policies.base",
        "description": "maple.maple.policies.base",
        "peekOfCode": "class ExplorationPolicy(Policy, metaclass=abc.ABCMeta):\n    def set_num_steps_total(self, t):\n        pass",
        "detail": "maple.maple.policies.base",
        "documentation": {}
    },
    {
        "label": "RandomPolicy",
        "kind": 6,
        "importPath": "maple.maple.policies.simple",
        "description": "maple.maple.policies.simple",
        "peekOfCode": "class RandomPolicy(Policy):\n    \"\"\"\n    Policy that always outputs zero.\n    \"\"\"\n    def __init__(self, action_space):\n        self.action_space = action_space\n    def get_action(self, obs):\n        return self.action_space.sample(), {}",
        "detail": "maple.maple.policies.simple",
        "documentation": {}
    },
    {
        "label": "DataCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.base",
        "description": "maple.maple.samplers.data_collector.base",
        "peekOfCode": "class DataCollector(object, metaclass=abc.ABCMeta):\n    def end_epoch(self, epoch):\n        pass\n    def get_diagnostics(self):\n        return {}\n    def get_snapshot(self):\n        return {}\n    @abc.abstractmethod\n    def get_epoch_paths(self):\n        pass",
        "detail": "maple.maple.samplers.data_collector.base",
        "documentation": {}
    },
    {
        "label": "PathCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.base",
        "description": "maple.maple.samplers.data_collector.base",
        "peekOfCode": "class PathCollector(DataCollector, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def collect_new_paths(\n            self,\n            max_path_length,\n            num_steps,\n            discard_incomplete_paths,\n    ):\n        pass\nclass StepCollector(DataCollector, metaclass=abc.ABCMeta):",
        "detail": "maple.maple.samplers.data_collector.base",
        "documentation": {}
    },
    {
        "label": "StepCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.base",
        "description": "maple.maple.samplers.data_collector.base",
        "peekOfCode": "class StepCollector(DataCollector, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def collect_new_steps(\n            self,\n            max_path_length,\n            num_steps,\n            discard_incomplete_paths,\n    ):\n        pass",
        "detail": "maple.maple.samplers.data_collector.base",
        "documentation": {}
    },
    {
        "label": "ContextualPathCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.contextual_path_collector",
        "description": "maple.maple.samplers.data_collector.contextual_path_collector",
        "peekOfCode": "class ContextualPathCollector(MdpPathCollector):\n    def __init__(\n            self,\n            env: ContextualEnv,\n            policy: Policy,\n            max_num_epoch_paths_saved=None,\n            observation_key='observation',\n            context_keys_for_policy='context',\n            render=False,\n            render_kwargs=None,",
        "detail": "maple.maple.samplers.data_collector.contextual_path_collector",
        "documentation": {}
    },
    {
        "label": "JointPathCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.joint_path_collector",
        "description": "maple.maple.samplers.data_collector.joint_path_collector",
        "peekOfCode": "class JointPathCollector(PathCollector):\n    def __init__(self, path_collectors: Dict[str, PathCollector]):\n        self.path_collectors = path_collectors\n    def collect_new_paths(self, max_path_length, num_steps,\n                          discard_incomplete_paths):\n        paths = []\n        for collector in self.path_collectors.values():\n            collector.collect_new_paths(\n                max_path_length, num_steps, discard_incomplete_paths\n            )",
        "detail": "maple.maple.samplers.data_collector.joint_path_collector",
        "documentation": {}
    },
    {
        "label": "MdpPathCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.path_collector",
        "description": "maple.maple.samplers.data_collector.path_collector",
        "peekOfCode": "class MdpPathCollector(PathCollector):\n    def __init__(\n            self,\n            env,\n            policy,\n            max_num_epoch_paths_saved=None,\n            render=False,\n            render_kwargs=None,\n            rollout_fn=rollout,\n            save_env_in_snapshot=True,",
        "detail": "maple.maple.samplers.data_collector.path_collector",
        "documentation": {}
    },
    {
        "label": "GoalConditionedPathCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.path_collector",
        "description": "maple.maple.samplers.data_collector.path_collector",
        "peekOfCode": "class GoalConditionedPathCollector(MdpPathCollector):\n    def __init__(\n            self,\n            *args,\n            observation_key='observation',\n            desired_goal_key='desired_goal',\n            goal_sampling_mode=None,\n            **kwargs\n    ):\n        def obs_processor(o):",
        "detail": "maple.maple.samplers.data_collector.path_collector",
        "documentation": {}
    },
    {
        "label": "ObsDictPathCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.path_collector",
        "description": "maple.maple.samplers.data_collector.path_collector",
        "peekOfCode": "class ObsDictPathCollector(MdpPathCollector):\n    def __init__(\n            self,\n            *args,\n            observation_key='observation',\n            **kwargs\n    ):\n        def obs_processor(obs):\n            return obs[observation_key]\n        rollout_fn = partial(",
        "detail": "maple.maple.samplers.data_collector.path_collector",
        "documentation": {}
    },
    {
        "label": "VAEWrappedEnvPathCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.path_collector",
        "description": "maple.maple.samplers.data_collector.path_collector",
        "peekOfCode": "class VAEWrappedEnvPathCollector(GoalConditionedPathCollector):\n    def __init__(\n            self,\n            env,\n            policy,\n            decode_goals=False,\n            **kwargs\n    ):\n        \"\"\"Expects env is VAEWrappedEnv\"\"\"\n        super().__init__(env, policy, **kwargs)",
        "detail": "maple.maple.samplers.data_collector.path_collector",
        "documentation": {}
    },
    {
        "label": "MdpStepCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.step_collector",
        "description": "maple.maple.samplers.data_collector.step_collector",
        "peekOfCode": "class MdpStepCollector(StepCollector):\n    def __init__(\n            self,\n            env,\n            policy,\n            max_num_epoch_paths_saved=None,\n            render=False,\n            render_kwargs=None,\n    ):\n        if render_kwargs is None:",
        "detail": "maple.maple.samplers.data_collector.step_collector",
        "documentation": {}
    },
    {
        "label": "GoalConditionedStepCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.step_collector",
        "description": "maple.maple.samplers.data_collector.step_collector",
        "peekOfCode": "class GoalConditionedStepCollector(StepCollector):\n    def __init__(\n            self,\n            env,\n            policy,\n            max_num_epoch_paths_saved=None,\n            render=False,\n            render_kwargs=None,\n            observation_key='observation',\n            desired_goal_key='desired_goal',",
        "detail": "maple.maple.samplers.data_collector.step_collector",
        "documentation": {}
    },
    {
        "label": "ObsDictStepCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.step_collector",
        "description": "maple.maple.samplers.data_collector.step_collector",
        "peekOfCode": "class ObsDictStepCollector(StepCollector):\n    def __init__(\n            self,\n            env,\n            policy,\n            max_num_epoch_paths_saved=None,\n            render=False,\n            render_kwargs=None,\n            observation_key='observation',\n    ):",
        "detail": "maple.maple.samplers.data_collector.step_collector",
        "documentation": {}
    },
    {
        "label": "VAEWrappedEnvPathCollector",
        "kind": 6,
        "importPath": "maple.maple.samplers.data_collector.vae_env",
        "description": "maple.maple.samplers.data_collector.vae_env",
        "peekOfCode": "class VAEWrappedEnvPathCollector(GoalConditionedPathCollector):\n    def __init__(\n            self,\n            goal_sampling_mode,\n            env: VAEWrappedEnv,\n            policy,\n            decode_goals=False,\n            **kwargs\n    ):\n        super().__init__(env, policy, **kwargs)",
        "detail": "maple.maple.samplers.data_collector.vae_env",
        "documentation": {}
    },
    {
        "label": "InPlacePathSampler",
        "kind": 6,
        "importPath": "maple.maple.samplers.in_place",
        "description": "maple.maple.samplers.in_place",
        "peekOfCode": "class InPlacePathSampler(object):\n    \"\"\"\n    A sampler that does not serialization for sampling. Instead, it just uses\n    the current policy and environment as-is.\n    WARNING: This will affect the environment! So\n    ```\n    sampler = InPlacePathSampler(env, ...)\n    sampler.obtain_samples  # this has side-effects: env will change!\n    ```\n    \"\"\"",
        "detail": "maple.maple.samplers.in_place",
        "documentation": {}
    },
    {
        "label": "multitask_rollout",
        "kind": 2,
        "importPath": "maple.maple.samplers.rollout_functions",
        "description": "maple.maple.samplers.rollout_functions",
        "peekOfCode": "def multitask_rollout(\n        env,\n        agent,\n        max_path_length=np.inf,\n        render=False,\n        render_kwargs=None,\n        observation_key=None,\n        desired_goal_key=None,\n        get_action_kwargs=None,\n        return_dict_obs=False,",
        "detail": "maple.maple.samplers.rollout_functions",
        "documentation": {}
    },
    {
        "label": "contextual_rollout",
        "kind": 2,
        "importPath": "maple.maple.samplers.rollout_functions",
        "description": "maple.maple.samplers.rollout_functions",
        "peekOfCode": "def contextual_rollout(\n        env,\n        agent,\n        observation_key=None,\n        context_keys_for_policy=None,\n        obs_processor=None,\n        **kwargs\n):\n    if context_keys_for_policy is None:\n        context_keys_for_policy = ['context']",
        "detail": "maple.maple.samplers.rollout_functions",
        "documentation": {}
    },
    {
        "label": "rollout",
        "kind": 2,
        "importPath": "maple.maple.samplers.rollout_functions",
        "description": "maple.maple.samplers.rollout_functions",
        "peekOfCode": "def rollout(\n        env,\n        agent,\n        max_path_length=np.inf,\n        render=False,\n        render_kwargs=None,\n        preprocess_obs_for_policy_fn=None,\n        get_action_kwargs=None,\n        return_dict_obs=False,\n        full_o_postprocess_func=None,",
        "detail": "maple.maple.samplers.rollout_functions",
        "documentation": {}
    },
    {
        "label": "deprecated_rollout",
        "kind": 2,
        "importPath": "maple.maple.samplers.rollout_functions",
        "description": "maple.maple.samplers.rollout_functions",
        "peekOfCode": "def deprecated_rollout(\n        env,\n        agent,\n        max_path_length=np.inf,\n        render=False,\n        render_kwargs=None,\n):\n    \"\"\"\n    The following value for the following keys will be a 2D array, with the\n    first dimension corresponding to the time dimension.",
        "detail": "maple.maple.samplers.rollout_functions",
        "documentation": {}
    },
    {
        "label": "create_rollout_function",
        "kind": 5,
        "importPath": "maple.maple.samplers.rollout_functions",
        "description": "maple.maple.samplers.rollout_functions",
        "peekOfCode": "create_rollout_function = partial\ndef multitask_rollout(\n        env,\n        agent,\n        max_path_length=np.inf,\n        render=False,\n        render_kwargs=None,\n        observation_key=None,\n        desired_goal_key=None,\n        get_action_kwargs=None,",
        "detail": "maple.maple.samplers.rollout_functions",
        "documentation": {}
    },
    {
        "label": "split_paths",
        "kind": 2,
        "importPath": "maple.maple.samplers.util",
        "description": "maple.maple.samplers.util",
        "peekOfCode": "def split_paths(paths):\n    \"\"\"\n    Stack multiples obs/actions/etc. from different paths\n    :param paths: List of paths, where one path is something returned from\n    the rollout functino above.\n    :return: Tuple. Every element will have shape batch_size X DIM, including\n    the rewards and terminal flags.\n    \"\"\"\n    rewards = [path[\"rewards\"].reshape(-1, 1) for path in paths]\n    terminals = [path[\"terminals\"].reshape(-1, 1) for path in paths]",
        "detail": "maple.maple.samplers.util",
        "documentation": {}
    },
    {
        "label": "split_paths_to_dict",
        "kind": 2,
        "importPath": "maple.maple.samplers.util",
        "description": "maple.maple.samplers.util",
        "peekOfCode": "def split_paths_to_dict(paths):\n    rewards, terminals, obs, actions, next_obs = split_paths(paths)\n    return dict(\n        rewards=rewards,\n        terminals=terminals,\n        observations=obs,\n        actions=actions,\n        next_observations=next_obs,\n    )",
        "detail": "maple.maple.samplers.util",
        "documentation": {}
    },
    {
        "label": "TorchNormalizer",
        "kind": 6,
        "importPath": "maple.maple.torch.data_management.normalizer",
        "description": "maple.maple.torch.data_management.normalizer",
        "peekOfCode": "class TorchNormalizer(Normalizer):\n    \"\"\"\n    Update with np array, but de/normalize pytorch Tensors.\n    \"\"\"\n    def normalize(self, v, clip_range=None):\n        if not self.synchronized:\n            self.synchronize()\n        if clip_range is None:\n            clip_range = self.default_clip_range\n        mean = ptu.from_numpy(self.mean)",
        "detail": "maple.maple.torch.data_management.normalizer",
        "documentation": {}
    },
    {
        "label": "TorchFixedNormalizer",
        "kind": 6,
        "importPath": "maple.maple.torch.data_management.normalizer",
        "description": "maple.maple.torch.data_management.normalizer",
        "peekOfCode": "class TorchFixedNormalizer(FixedNormalizer):\n    def normalize(self, v, clip_range=None):\n        if clip_range is None:\n            clip_range = self.default_clip_range\n        mean = ptu.from_numpy(self.mean)\n        std = ptu.from_numpy(self.std)\n        if v.dim() == 2:\n            # Unsqueeze along the batch use automatic broadcasting\n            mean = mean.unsqueeze(0)\n            std = std.unsqueeze(0)",
        "detail": "maple.maple.torch.data_management.normalizer",
        "documentation": {}
    },
    {
        "label": "VAEPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.lvm.bear_vae",
        "description": "maple.maple.torch.lvm.bear_vae",
        "peekOfCode": "class VAEPolicy(LatentVariableModel):\n    def __init__(\n            self,\n            obs_dim,\n            action_dim,\n            latent_dim,\n    ):\n        encoder = Encoder(obs_dim, latent_dim, action_dim)\n        decoder = Decoder(obs_dim, latent_dim, action_dim)\n        super().__init__(encoder, decoder)",
        "detail": "maple.maple.torch.lvm.bear_vae",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "kind": 6,
        "importPath": "maple.maple.torch.lvm.bear_vae",
        "description": "maple.maple.torch.lvm.bear_vae",
        "peekOfCode": "class Encoder(nn.Module):\n    def __init__(self, obs_dim, latent_dim, action_dim):\n        super().__init__()\n        self.latent_dim = latent_dim\n        self.e1 = torch.nn.Linear(obs_dim + action_dim, 750)\n        self.e2 = torch.nn.Linear(750, 750)\n        self.mean = torch.nn.Linear(750, self.latent_dim)\n        self.log_std = torch.nn.Linear(750, self.latent_dim)\n    def forward(self, state, action):\n        z = F.relu(self.e1(torch.cat([state, action], 1)))",
        "detail": "maple.maple.torch.lvm.bear_vae",
        "documentation": {}
    },
    {
        "label": "Decoder",
        "kind": 6,
        "importPath": "maple.maple.torch.lvm.bear_vae",
        "description": "maple.maple.torch.lvm.bear_vae",
        "peekOfCode": "class Decoder(nn.Module):\n    def __init__(self, obs_dim, latent_dim, action_dim):\n        super().__init__()\n        self.latent_dim = latent_dim\n        self.d1 = torch.nn.Linear(obs_dim + self.latent_dim, 750)\n        self.d2 = torch.nn.Linear(750, 750)\n        self.d3 = torch.nn.Linear(750, action_dim)\n    def forward(self, state, z):\n        a = F.relu(self.d1(torch.cat([state, z], 1)))\n        a = F.relu(self.d2(a))",
        "detail": "maple.maple.torch.lvm.bear_vae",
        "documentation": {}
    },
    {
        "label": "LatentVariableModel",
        "kind": 6,
        "importPath": "maple.maple.torch.lvm.latent_variable_model",
        "description": "maple.maple.torch.lvm.latent_variable_model",
        "peekOfCode": "class LatentVariableModel(nn.Module):\n    def __init__(\n            self,\n            encoder,\n            decoder,\n            **kwargs\n    ):\n        super().__init__()\n        self.encoder = encoder\n        self.decoder = decoder",
        "detail": "maple.maple.torch.lvm.latent_variable_model",
        "documentation": {}
    },
    {
        "label": "DistributionGenerator",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.maple.torch.networks.stochastic.distribution_generator",
        "peekOfCode": "class DistributionGenerator(nn.Module, metaclass=abc.ABCMeta):\n    def forward(self, *input, **kwarg) -> Distribution:\n        raise NotImplementedError\nclass ModuleToDistributionGenerator(\n    MultiInputSequential,\n    DistributionGenerator,\n    metaclass=abc.ABCMeta\n):\n    pass\nclass Beta(ModuleToDistributionGenerator):",
        "detail": "maple.maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "ModuleToDistributionGenerator",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.maple.torch.networks.stochastic.distribution_generator",
        "peekOfCode": "class ModuleToDistributionGenerator(\n    MultiInputSequential,\n    DistributionGenerator,\n    metaclass=abc.ABCMeta\n):\n    pass\nclass Beta(ModuleToDistributionGenerator):\n    def forward(self, *input):\n        alpha, beta = super().forward(*input)\n        return Beta(alpha, beta)",
        "detail": "maple.maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "Beta",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.maple.torch.networks.stochastic.distribution_generator",
        "peekOfCode": "class Beta(ModuleToDistributionGenerator):\n    def forward(self, *input):\n        alpha, beta = super().forward(*input)\n        return Beta(alpha, beta)\nclass Gaussian(ModuleToDistributionGenerator):\n    def __init__(self, module, std=None, reinterpreted_batch_ndims=1):\n        super().__init__(module)\n        self.std = std\n        self.reinterpreted_batch_ndims = reinterpreted_batch_ndims\n    def forward(self, *input):",
        "detail": "maple.maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "Gaussian",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.maple.torch.networks.stochastic.distribution_generator",
        "peekOfCode": "class Gaussian(ModuleToDistributionGenerator):\n    def __init__(self, module, std=None, reinterpreted_batch_ndims=1):\n        super().__init__(module)\n        self.std = std\n        self.reinterpreted_batch_ndims = reinterpreted_batch_ndims\n    def forward(self, *input):\n        if self.std:\n            mean = super().forward(*input)\n            std = self.std\n        else:",
        "detail": "maple.maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "BernoulliGenerator",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.maple.torch.networks.stochastic.distribution_generator",
        "peekOfCode": "class BernoulliGenerator(ModuleToDistributionGenerator):\n    def forward(self, *input):\n        probs = super().forward(*input)\n        return Bernoulli(probs)\nclass IndependentGenerator(ModuleToDistributionGenerator):\n    def __init__(self, *args, reinterpreted_batch_ndims=1):\n        super().__init__(*args)\n        self.reinterpreted_batch_ndims = reinterpreted_batch_ndims\n    def forward(self, *input):\n        distribution = super().forward(*input)",
        "detail": "maple.maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "IndependentGenerator",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.maple.torch.networks.stochastic.distribution_generator",
        "peekOfCode": "class IndependentGenerator(ModuleToDistributionGenerator):\n    def __init__(self, *args, reinterpreted_batch_ndims=1):\n        super().__init__(*args)\n        self.reinterpreted_batch_ndims = reinterpreted_batch_ndims\n    def forward(self, *input):\n        distribution = super().forward(*input)\n        return Independent(\n            distribution,\n            reinterpreted_batch_ndims=self.reinterpreted_batch_ndims,\n        )",
        "detail": "maple.maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "GaussianMixture",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.maple.torch.networks.stochastic.distribution_generator",
        "peekOfCode": "class GaussianMixture(ModuleToDistributionGenerator):\n    def forward(self, *input):\n        mixture_means, mixture_stds, weights = super().forward(*input)\n        return GaussianMixtureDistribution(mixture_means, mixture_stds, weights)\nclass GaussianMixtureFull(ModuleToDistributionGenerator):\n    def forward(self, *input):\n        mixture_means, mixture_stds, weights = super().forward(*input)\n        return GaussianMixtureFullDistribution(mixture_means, mixture_stds, weights)\nclass TanhGaussian(ModuleToDistributionGenerator):\n    def forward(self, *input):",
        "detail": "maple.maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "GaussianMixtureFull",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.maple.torch.networks.stochastic.distribution_generator",
        "peekOfCode": "class GaussianMixtureFull(ModuleToDistributionGenerator):\n    def forward(self, *input):\n        mixture_means, mixture_stds, weights = super().forward(*input)\n        return GaussianMixtureFullDistribution(mixture_means, mixture_stds, weights)\nclass TanhGaussian(ModuleToDistributionGenerator):\n    def forward(self, *input):\n        mean, log_std = super().forward(*input)\n        std = log_std.exp()\n        return TanhNormal(mean, std)",
        "detail": "maple.maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "TanhGaussian",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.stochastic.distribution_generator",
        "description": "maple.maple.torch.networks.stochastic.distribution_generator",
        "peekOfCode": "class TanhGaussian(ModuleToDistributionGenerator):\n    def forward(self, *input):\n        mean, log_std = super().forward(*input)\n        std = log_std.exp()\n        return TanhNormal(mean, std)",
        "detail": "maple.maple.torch.networks.stochastic.distribution_generator",
        "documentation": {}
    },
    {
        "label": "Clamp",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class Clamp(nn.Module):\n    def __init__(self, **kwargs):\n        super().__init__()\n        self.kwargs = kwargs\n        self.__name__ = \"Clamp\"\n    def forward(self, x):\n        return torch.clamp(x, **self.kwargs)\nclass Split(nn.Module):\n    \"\"\"\n    Split input and process each chunk with a separate module.",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "Split",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class Split(nn.Module):\n    \"\"\"\n    Split input and process each chunk with a separate module.\n    \"\"\"\n    def __init__(self, module1, module2, split_idx):\n        super().__init__()\n        self.module1 = module1\n        self.module2 = module2\n        self.split_idx = split_idx\n    def forward(self, x):",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "FlattenEach",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class FlattenEach(nn.Module):\n    def forward(self, inputs):\n        return tuple(x.view(x.size(0), -1) for x in inputs)\nclass FlattenEachParallel(nn.Module):\n    def forward(self, *inputs):\n        return tuple(x.view(x.size(0), -1) for x in inputs)\nclass Flatten(nn.Module):\n    def forward(self, inputs):\n        return inputs.view(inputs.size(0), -1)\nclass Map(nn.Module):",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "FlattenEachParallel",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class FlattenEachParallel(nn.Module):\n    def forward(self, *inputs):\n        return tuple(x.view(x.size(0), -1) for x in inputs)\nclass Flatten(nn.Module):\n    def forward(self, inputs):\n        return inputs.view(inputs.size(0), -1)\nclass Map(nn.Module):\n    \"\"\"Apply a module to each input.\"\"\"\n    def __init__(self, module):\n        super().__init__()",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "Flatten",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class Flatten(nn.Module):\n    def forward(self, inputs):\n        return inputs.view(inputs.size(0), -1)\nclass Map(nn.Module):\n    \"\"\"Apply a module to each input.\"\"\"\n    def __init__(self, module):\n        super().__init__()\n        self.module = module\n    def forward(self, inputs):\n        return tuple(self.module(x) for x in inputs)",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "Map",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class Map(nn.Module):\n    \"\"\"Apply a module to each input.\"\"\"\n    def __init__(self, module):\n        super().__init__()\n        self.module = module\n    def forward(self, inputs):\n        return tuple(self.module(x) for x in inputs)\nclass ApplyMany(nn.Module):\n    \"\"\"Apply many modules to one input.\"\"\"\n    def __init__(self, *modules):",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "ApplyMany",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class ApplyMany(nn.Module):\n    \"\"\"Apply many modules to one input.\"\"\"\n    def __init__(self, *modules):\n        super().__init__()\n        self.modules_to_apply = nn.ModuleList(modules)\n    def forward(self, inputs):\n        return tuple(m(inputs) for m in self.modules_to_apply)\nclass LearnedPositiveConstant(nn.Module):\n    def __init__(self, init_value):\n        super().__init__()",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "LearnedPositiveConstant",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class LearnedPositiveConstant(nn.Module):\n    def __init__(self, init_value):\n        super().__init__()\n        self._constant = nn.Parameter(init_value)\n    def forward(self, _):\n        return self._constant\nclass Reshape(nn.Module):\n    def __init__(self, *output_shape):\n        super().__init__()\n        self._output_shape_with_batch_size = (-1, *output_shape)",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "Reshape",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class Reshape(nn.Module):\n    def __init__(self, *output_shape):\n        super().__init__()\n        self._output_shape_with_batch_size = (-1, *output_shape)\n    def forward(self, inputs):\n        return inputs.view(self._output_shape_with_batch_size)\nclass ConcatTuple(nn.Module):\n    def __init__(self, dim=1):\n        super().__init__()\n        self.dim = dim",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "ConcatTuple",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class ConcatTuple(nn.Module):\n    def __init__(self, dim=1):\n        super().__init__()\n        self.dim = dim\n    def forward(self, inputs):\n        return torch.cat(inputs, dim=self.dim)\nclass Concat(nn.Module):\n    def __init__(self, dim=1):\n        super().__init__()\n        self.dim = dim",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "Concat",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class Concat(nn.Module):\n    def __init__(self, dim=1):\n        super().__init__()\n        self.dim = dim\n    def forward(self, *inputs):\n        return torch.cat(inputs, dim=self.dim)\nclass MultiInputSequential(nn.Sequential):\n    def forward(self, *input):\n        for module in self._modules.values():\n            if isinstance(input, tuple):",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "MultiInputSequential",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class MultiInputSequential(nn.Sequential):\n    def forward(self, *input):\n        for module in self._modules.values():\n            if isinstance(input, tuple):\n                input = module(*input)\n            else:\n                input = module(input)\n        return input\nclass Detach(nn.Module):\n    def __init__(self, wrapped_mlp):",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "Detach",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.basic",
        "description": "maple.maple.torch.networks.basic",
        "peekOfCode": "class Detach(nn.Module):\n    def __init__(self, wrapped_mlp):\n        super().__init__()\n        self.wrapped_mlp = wrapped_mlp\n    def forward(self, inputs):\n        return self.wrapped_mlp.forward(inputs).detach()\n    def __getattr__(self, attr_name):\n        try:\n            return super().__getattr__(attr_name)\n        except AttributeError:",
        "detail": "maple.maple.torch.networks.basic",
        "documentation": {}
    },
    {
        "label": "CNN",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.cnn",
        "description": "maple.maple.torch.networks.cnn",
        "peekOfCode": "class CNN(PyTorchModule):\n    # TODO: remove the FC parts of this code\n    def __init__(\n            self,\n            input_width,\n            input_height,\n            input_channels,\n            output_size,\n            kernel_sizes,\n            n_channels,",
        "detail": "maple.maple.torch.networks.cnn",
        "documentation": {}
    },
    {
        "label": "ConcatCNN",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.cnn",
        "description": "maple.maple.torch.networks.cnn",
        "peekOfCode": "class ConcatCNN(CNN):\n    \"\"\"\n    Concatenate inputs along dimension and then pass through MLP.\n    \"\"\"\n    def __init__(self, *args, dim=1, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.dim = dim\n    def forward(self, *inputs, **kwargs):\n        flat_inputs = torch.cat(inputs, dim=self.dim)\n        return super().forward(flat_inputs, **kwargs)",
        "detail": "maple.maple.torch.networks.cnn",
        "documentation": {}
    },
    {
        "label": "MergedCNN",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.cnn",
        "description": "maple.maple.torch.networks.cnn",
        "peekOfCode": "class MergedCNN(CNN):\n    '''\n    CNN that supports input directly into fully connected layers\n    '''\n    def __init__(self,\n                 added_fc_input_size,\n                 **kwargs\n                 ):\n        super().__init__(added_fc_input_size=added_fc_input_size,\n                         **kwargs)",
        "detail": "maple.maple.torch.networks.cnn",
        "documentation": {}
    },
    {
        "label": "CNNPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.cnn",
        "description": "maple.maple.torch.networks.cnn",
        "peekOfCode": "class CNNPolicy(CNN, Policy):\n    \"\"\"\n    A simpler interface for creating policies.\n    \"\"\"\n    def __init__(\n            self,\n            *args,\n            obs_normalizer: TorchFixedNormalizer = None,\n            **kwargs\n    ):",
        "detail": "maple.maple.torch.networks.cnn",
        "documentation": {}
    },
    {
        "label": "BasicCNN",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.cnn",
        "description": "maple.maple.torch.networks.cnn",
        "peekOfCode": "class BasicCNN(PyTorchModule):\n    # TODO: clean up CNN using this basic CNN\n    def __init__(\n            self,\n            input_width,\n            input_height,\n            input_channels,\n            kernel_sizes,\n            n_channels,\n            strides,",
        "detail": "maple.maple.torch.networks.cnn",
        "documentation": {}
    },
    {
        "label": "TwoHeadDCNN",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.dcnn",
        "description": "maple.maple.torch.networks.dcnn",
        "peekOfCode": "class TwoHeadDCNN(PyTorchModule):\n    def __init__(self,\n                 fc_input_size,\n                 hidden_sizes,\n                 deconv_input_width,\n                 deconv_input_height,\n                 deconv_input_channels,\n                 deconv_output_kernel_size,\n                 deconv_output_strides,\n                 deconv_output_channels,",
        "detail": "maple.maple.torch.networks.dcnn",
        "documentation": {}
    },
    {
        "label": "DCNN",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.dcnn",
        "description": "maple.maple.torch.networks.dcnn",
        "peekOfCode": "class DCNN(TwoHeadDCNN):\n    def forward(self, input):\n        return super().forward(input)[0]\nclass BasicDCNN(PyTorchModule):\n    \"\"\"Deconvolution neural network.\"\"\"\n    # TODO (maybe?): merge with BasicCNN code\n    def __init__(\n            self,\n            input_width,\n            input_height,",
        "detail": "maple.maple.torch.networks.dcnn",
        "documentation": {}
    },
    {
        "label": "BasicDCNN",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.dcnn",
        "description": "maple.maple.torch.networks.dcnn",
        "peekOfCode": "class BasicDCNN(PyTorchModule):\n    \"\"\"Deconvolution neural network.\"\"\"\n    # TODO (maybe?): merge with BasicCNN code\n    def __init__(\n            self,\n            input_width,\n            input_height,\n            input_channels,\n            kernel_sizes,\n            n_channels,",
        "detail": "maple.maple.torch.networks.dcnn",
        "documentation": {}
    },
    {
        "label": "FeatPointMlp",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.feat_point_mlp",
        "description": "maple.maple.torch.networks.feat_point_mlp",
        "peekOfCode": "class FeatPointMlp(PyTorchModule):\n    def __init__(\n            self,\n            downsample_size,\n            input_channels,\n            num_feat_points,\n            temperature=1.0,\n            init_w=1e-3,\n            input_size=32,\n            hidden_init=ptu.fanin_init,",
        "detail": "maple.maple.torch.networks.feat_point_mlp",
        "documentation": {}
    },
    {
        "label": "ImageStatePolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.image_state",
        "description": "maple.maple.torch.networks.image_state",
        "peekOfCode": "class ImageStatePolicy(PyTorchModule, Policy):\n    \"\"\"Switches between image or state inputs\"\"\"\n    def __init__(\n            self,\n            image_conv_net,\n            state_fc_net,\n    ):\n        super().__init__()\n        assert image_conv_net is None or state_fc_net is None\n        self.image_conv_net = image_conv_net",
        "detail": "maple.maple.torch.networks.image_state",
        "documentation": {}
    },
    {
        "label": "ImageStateQ",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.image_state",
        "description": "maple.maple.torch.networks.image_state",
        "peekOfCode": "class ImageStateQ(PyTorchModule):\n    \"\"\"Switches between image or state inputs\"\"\"\n    def __init__(\n            self,\n            # obs_dim,\n            # action_dim,\n            # goal_dim,\n            image_conv_net,  # assumed to be a MergedCNN\n            state_fc_net,\n    ):",
        "detail": "maple.maple.torch.networks.image_state",
        "documentation": {}
    },
    {
        "label": "LinearTransform",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.linear_transform",
        "description": "maple.maple.torch.networks.linear_transform",
        "peekOfCode": "class LinearTransform(PyTorchModule):\n    def __init__(self, m, b):\n        super().__init__()\n        self.m = m\n        self.b = b\n    def __call__(self, t):\n        return self.m * t + self.b",
        "detail": "maple.maple.torch.networks.linear_transform",
        "documentation": {}
    },
    {
        "label": "Mlp",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class Mlp(PyTorchModule):\n    def __init__(\n            self,\n            hidden_sizes,\n            output_size,\n            input_size,\n            init_w=3e-3,\n            hidden_activation=F.relu,\n            output_activation=identity,\n            hidden_init=ptu.fanin_init,",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "MultiHeadedMlp",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class MultiHeadedMlp(Mlp):\n    \"\"\"\n                   .-> linear head 0\n                  /\n    input --> MLP ---> linear head 1\n                  \\\n                   .-> linear head 2\n    \"\"\"\n    def __init__(\n            self,",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "ConcatMultiHeadedMlp",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class ConcatMultiHeadedMlp(MultiHeadedMlp):\n    \"\"\"\n    Concatenate inputs along dimension and then pass through MultiHeadedMlp.\n    \"\"\"\n    def __init__(self, *args, dim=1, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.dim = dim\n    def forward(self, *inputs, **kwargs):\n        flat_inputs = torch.cat(inputs, dim=self.dim)\n        return super().forward(flat_inputs, **kwargs)",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "ConcatMlp",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class ConcatMlp(Mlp):\n    \"\"\"\n    Concatenate inputs along dimension and then pass through MLP.\n    \"\"\"\n    def __init__(self, *args, dim=1, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.dim = dim\n    def forward(self, *inputs, **kwargs):\n        flat_inputs = torch.cat(inputs, dim=self.dim)\n        return super().forward(flat_inputs, **kwargs)",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "MlpPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class MlpPolicy(Mlp, Policy):\n    \"\"\"\n    A simpler interface for creating policies.\n    \"\"\"\n    def __init__(\n            self,\n            *args,\n            obs_normalizer: TorchFixedNormalizer = None,\n            **kwargs\n    ):",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "TanhMlpPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class TanhMlpPolicy(MlpPolicy):\n    \"\"\"\n    A helper class since most policies have a tanh output activation.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, output_activation=torch.tanh, **kwargs)\nclass MlpQf(ConcatMlp):\n    def __init__(\n            self,\n            *args,",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "MlpQf",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class MlpQf(ConcatMlp):\n    def __init__(\n            self,\n            *args,\n            obs_normalizer: TorchFixedNormalizer = None,\n            action_normalizer: TorchFixedNormalizer = None,\n            **kwargs\n    ):\n        super().__init__(*args, **kwargs)\n        self.obs_normalizer = obs_normalizer",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "MlpQfWithObsProcessor",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class MlpQfWithObsProcessor(Mlp):\n    def __init__(self, obs_processor, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.obs_processor = obs_processor\n    def forward(self, obs, actions, **kwargs):\n        h = self.obs_processor(obs)\n        flat_inputs = torch.cat((h, actions), dim=1)\n        return super().forward(flat_inputs, **kwargs)\nclass MlpGoalQfWithObsProcessor(Mlp):\n    def __init__(self, obs_processor, obs_dim,",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "MlpGoalQfWithObsProcessor",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class MlpGoalQfWithObsProcessor(Mlp):\n    def __init__(self, obs_processor, obs_dim,\n                 backprop_into_obs_preprocessor=True,\n                 *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.obs_processor = obs_processor\n        self.backprop_into_obs_preprocessor = backprop_into_obs_preprocessor\n        self.obs_dim = obs_dim\n    def forward(self, obs, actions, **kwargs):\n        h_s = self.obs_processor(obs[:, :self.obs_dim])",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "SplitIntoManyHeads",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class SplitIntoManyHeads(nn.Module):\n    \"\"\"\n           .-> head 0\n          /\n    input ---> head 1\n          \\\n           '-> head 2\n    \"\"\"\n    def __init__(\n            self,",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "ParallelMlp",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.mlp",
        "description": "maple.maple.torch.networks.mlp",
        "peekOfCode": "class ParallelMlp(nn.Module):\n    \"\"\"\n    Efficient implementation of multiple MLPs with identical architectures.\n           .-> mlp 0\n          /\n    input ---> mlp 1\n          \\\n           '-> mlp 2\n    See https://discuss.pytorch.org/t/parallel-execution-of-modules-in-nn-modulelist/43940/7\n    for details",
        "detail": "maple.maple.torch.networks.mlp",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.normalization",
        "description": "maple.maple.torch.networks.normalization",
        "peekOfCode": "class LayerNorm(nn.Module):\n    \"\"\"\n    Simple 1D LayerNorm.\n    \"\"\"\n    def __init__(self, features, center=True, scale=False, eps=1e-6):\n        super().__init__()\n        self.center = center\n        self.scale = scale\n        self.eps = eps\n        if self.scale:",
        "detail": "maple.maple.torch.networks.normalization",
        "documentation": {}
    },
    {
        "label": "PretrainedCNN",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.pretrained_cnn",
        "description": "maple.maple.torch.networks.pretrained_cnn",
        "peekOfCode": "class PretrainedCNN(PyTorchModule):\n    # Uses a pretrained CNN architecture from torchvision\n    def __init__(\n            self,\n            input_width,\n            input_height,\n            input_channels,\n            output_size,\n            hidden_sizes=None,\n            added_fc_input_size=0,",
        "detail": "maple.maple.torch.networks.pretrained_cnn",
        "documentation": {}
    },
    {
        "label": "TwoHeadMlp",
        "kind": 6,
        "importPath": "maple.maple.torch.networks.two_headed_mlp",
        "description": "maple.maple.torch.networks.two_headed_mlp",
        "peekOfCode": "class TwoHeadMlp(PyTorchModule):\n    def __init__(\n            self,\n            hidden_sizes,\n            first_head_size,\n            second_head_size,\n            input_size,\n            init_w=3e-3,\n            hidden_activation=F.relu,\n            output_activation=identity,",
        "detail": "maple.maple.torch.networks.two_headed_mlp",
        "documentation": {}
    },
    {
        "label": "TorchStochasticPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.base",
        "description": "maple.maple.torch.sac.policies.base",
        "peekOfCode": "class TorchStochasticPolicy(\n    DistributionGenerator,\n    ExplorationPolicy, metaclass=abc.ABCMeta\n):\n    def get_action(self, obs_np, return_dist=False):\n        info = {}\n        if return_dist:\n            actions, dist = self.get_actions(obs_np[None], return_dist=return_dist)\n            info['dist'] = dist\n        else:",
        "detail": "maple.maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "PolicyFromDistributionGenerator",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.base",
        "description": "maple.maple.torch.sac.policies.base",
        "peekOfCode": "class PolicyFromDistributionGenerator(\n    MultiInputSequential,\n    TorchStochasticPolicy,\n):\n    \"\"\"\n    Usage:\n    ```\n    distribution_generator = FancyGenerativeModel()\n    policy = PolicyFromBatchDistributionModule(distribution_generator)\n    ```",
        "detail": "maple.maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "MakeDeterministic",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.base",
        "description": "maple.maple.torch.sac.policies.base",
        "peekOfCode": "class MakeDeterministic(TorchStochasticPolicy):\n    def __init__(\n            self,\n            action_distribution_generator: DistributionGenerator,\n    ):\n        super().__init__()\n        self._action_distribution_generator = action_distribution_generator\n    def forward(self, *args, **kwargs):\n        dist = self._action_distribution_generator.forward(*args, **kwargs)\n        return Delta(dist.mle_estimate())",
        "detail": "maple.maple.torch.sac.policies.base",
        "documentation": {}
    },
    {
        "label": "TanhGaussianPolicyAdapter",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.gaussian_policy",
        "description": "maple.maple.torch.sac.policies.gaussian_policy",
        "peekOfCode": "class TanhGaussianPolicyAdapter(TorchStochasticPolicy):\n    \"\"\"\n    Usage:\n    ```\n    obs_processor = ...\n    policy = TanhGaussianPolicyAdapter(obs_processor)\n    ```\n    \"\"\"\n    def __init__(\n            self,",
        "detail": "maple.maple.torch.sac.policies.gaussian_policy",
        "documentation": {}
    },
    {
        "label": "TanhGaussianPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.gaussian_policy",
        "description": "maple.maple.torch.sac.policies.gaussian_policy",
        "peekOfCode": "class TanhGaussianPolicy(Mlp, TorchStochasticPolicy):\n    \"\"\"\n    Usage:\n    ```\n    policy = TanhGaussianPolicy(...)\n    \"\"\"\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,",
        "detail": "maple.maple.torch.sac.policies.gaussian_policy",
        "documentation": {}
    },
    {
        "label": "GaussianPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.gaussian_policy",
        "description": "maple.maple.torch.sac.policies.gaussian_policy",
        "peekOfCode": "class GaussianPolicy(Mlp, TorchStochasticPolicy):\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim,\n            std=None,\n            init_w=1e-3,\n            min_log_std=None,\n            max_log_std=None,",
        "detail": "maple.maple.torch.sac.policies.gaussian_policy",
        "documentation": {}
    },
    {
        "label": "GaussianCNNPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.gaussian_policy",
        "description": "maple.maple.torch.sac.policies.gaussian_policy",
        "peekOfCode": "class GaussianCNNPolicy(CNN, TorchStochasticPolicy):\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim,\n            std=None,\n            init_w=1e-3,\n            min_log_std=None,\n            max_log_std=None,",
        "detail": "maple.maple.torch.sac.policies.gaussian_policy",
        "documentation": {}
    },
    {
        "label": "GaussianMixturePolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.gaussian_policy",
        "description": "maple.maple.torch.sac.policies.gaussian_policy",
        "peekOfCode": "class GaussianMixturePolicy(Mlp, TorchStochasticPolicy):\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim,\n            std=None,\n            init_w=1e-3,\n            min_log_std=None,\n            max_log_std=None,",
        "detail": "maple.maple.torch.sac.policies.gaussian_policy",
        "documentation": {}
    },
    {
        "label": "BinnedGMMPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.gaussian_policy",
        "description": "maple.maple.torch.sac.policies.gaussian_policy",
        "peekOfCode": "class BinnedGMMPolicy(Mlp, TorchStochasticPolicy):\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim,\n            std=None,\n            init_w=1e-3,\n            min_log_std=None,\n            max_log_std=None,",
        "detail": "maple.maple.torch.sac.policies.gaussian_policy",
        "documentation": {}
    },
    {
        "label": "TanhGaussianObsProcessorPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.gaussian_policy",
        "description": "maple.maple.torch.sac.policies.gaussian_policy",
        "peekOfCode": "class TanhGaussianObsProcessorPolicy(TanhGaussianPolicy):\n    def __init__(self, obs_processor, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.pre_obs_dim = obs_processor.input_size\n        self.pre_goal_dim = obs_processor.input_size\n        self.obs_processor = obs_processor\n    def forward(self, obs, *args, **kwargs):\n        obs_and_goal = obs\n        assert obs_and_goal.shape[1] == self.pre_obs_dim + self.pre_goal_dim\n        obs = obs_and_goal[:, :self.pre_obs_dim]",
        "detail": "maple.maple.torch.sac.policies.gaussian_policy",
        "documentation": {}
    },
    {
        "label": "TanhCNNGaussianPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.gaussian_policy",
        "description": "maple.maple.torch.sac.policies.gaussian_policy",
        "peekOfCode": "class TanhCNNGaussianPolicy(CNN, TorchStochasticPolicy):\n    \"\"\"\n    Usage:\n    ```\n    policy = TanhGaussianPolicy(...)\n    \"\"\"\n    def __init__(\n            self,\n            std=None,\n            init_w=1e-3,",
        "detail": "maple.maple.torch.sac.policies.gaussian_policy",
        "documentation": {}
    },
    {
        "label": "LOG_SIG_MAX",
        "kind": 5,
        "importPath": "maple.maple.torch.sac.policies.gaussian_policy",
        "description": "maple.maple.torch.sac.policies.gaussian_policy",
        "peekOfCode": "LOG_SIG_MAX = 2\nLOG_SIG_MIN = -20\n# TODO: deprecate classes below in favor for PolicyFromDistributionModule\nclass TanhGaussianPolicyAdapter(TorchStochasticPolicy):\n    \"\"\"\n    Usage:\n    ```\n    obs_processor = ...\n    policy = TanhGaussianPolicyAdapter(obs_processor)\n    ```",
        "detail": "maple.maple.torch.sac.policies.gaussian_policy",
        "documentation": {}
    },
    {
        "label": "LOG_SIG_MIN",
        "kind": 5,
        "importPath": "maple.maple.torch.sac.policies.gaussian_policy",
        "description": "maple.maple.torch.sac.policies.gaussian_policy",
        "peekOfCode": "LOG_SIG_MIN = -20\n# TODO: deprecate classes below in favor for PolicyFromDistributionModule\nclass TanhGaussianPolicyAdapter(TorchStochasticPolicy):\n    \"\"\"\n    Usage:\n    ```\n    obs_processor = ...\n    policy = TanhGaussianPolicyAdapter(obs_processor)\n    ```\n    \"\"\"",
        "detail": "maple.maple.torch.sac.policies.gaussian_policy",
        "documentation": {}
    },
    {
        "label": "LVMPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.lvm_policy",
        "description": "maple.maple.torch.sac.policies.lvm_policy",
        "peekOfCode": "class LVMPolicy(LatentVariableModel, TorchStochasticPolicy):\n    \"\"\"Expects encoder p(z|s) and decoder p(u|s,z)\"\"\"\n    def forward(self, obs):\n        z_dist = self.encoder(obs)\n        z = z_dist.sample()\n        return self.decoder(obs, z)",
        "detail": "maple.maple.torch.sac.policies.lvm_policy",
        "documentation": {}
    },
    {
        "label": "PAMDPPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.pamdp_policy",
        "description": "maple.maple.torch.sac.policies.pamdp_policy",
        "peekOfCode": "class PAMDPPolicy(PyTorchModule, TorchStochasticPolicy):\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim_s,\n            action_dim_p,\n            one_hot_s,\n    ):\n        super().__init__()",
        "detail": "maple.maple.torch.sac.policies.pamdp_policy",
        "documentation": {}
    },
    {
        "label": "ConcatPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.pamdp_policy",
        "description": "maple.maple.torch.sac.policies.pamdp_policy",
        "peekOfCode": "class ConcatPolicy(PyTorchModule, TorchStochasticPolicy):\n    def __init__(\n            self,\n            policy1,\n            policy2,\n            policy1_obs_dim\n    ):\n        super().__init__()\n        self.policy1 = policy1\n        self.policy2 = policy2",
        "detail": "maple.maple.torch.sac.policies.pamdp_policy",
        "documentation": {}
    },
    {
        "label": "HierarchicalPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.pamdp_policy",
        "description": "maple.maple.torch.sac.policies.pamdp_policy",
        "peekOfCode": "class HierarchicalPolicy(PyTorchModule, TorchStochasticPolicy):\n    def __init__(self, policy1, policy2, policy1_obs_dim):\n        super().__init__()\n        self.policy1 = policy1\n        self.policy2 = policy2\n        self.policy1_obs_dim = policy1_obs_dim\n    def forward(self, obs):\n        assert obs.dim() == 2\n        def distr2_cond_fn(inputs):\n            obs_for_p = obs",
        "detail": "maple.maple.torch.sac.policies.pamdp_policy",
        "documentation": {}
    },
    {
        "label": "CategoricalPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.pamdp_policy",
        "description": "maple.maple.torch.sac.policies.pamdp_policy",
        "peekOfCode": "class CategoricalPolicy(Mlp, TorchStochasticPolicy):\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim,\n            prefix='',\n            init_w=1e-3,\n            one_hot=False,\n            **kwargs",
        "detail": "maple.maple.torch.sac.policies.pamdp_policy",
        "documentation": {}
    },
    {
        "label": "ParallelHybridPolicy",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.pamdp_policy",
        "description": "maple.maple.torch.sac.policies.pamdp_policy",
        "peekOfCode": "class ParallelHybridPolicy(PyTorchModule, TorchStochasticPolicy):\n    \"\"\"\n    Usage:\n    ```\n    policy = ParallelHybridPolicy(...)\n    \"\"\"\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,",
        "detail": "maple.maple.torch.sac.policies.pamdp_policy",
        "documentation": {}
    },
    {
        "label": "LOGITS_SCALE",
        "kind": 5,
        "importPath": "maple.maple.torch.sac.policies.pamdp_policy",
        "description": "maple.maple.torch.sac.policies.pamdp_policy",
        "peekOfCode": "LOGITS_SCALE = 10\nLOG_SIG_MAX = 2\nLOG_SIG_MIN = -20\nclass PAMDPPolicy(PyTorchModule, TorchStochasticPolicy):\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim_s,\n            action_dim_p,",
        "detail": "maple.maple.torch.sac.policies.pamdp_policy",
        "documentation": {}
    },
    {
        "label": "LOG_SIG_MAX",
        "kind": 5,
        "importPath": "maple.maple.torch.sac.policies.pamdp_policy",
        "description": "maple.maple.torch.sac.policies.pamdp_policy",
        "peekOfCode": "LOG_SIG_MAX = 2\nLOG_SIG_MIN = -20\nclass PAMDPPolicy(PyTorchModule, TorchStochasticPolicy):\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim_s,\n            action_dim_p,\n            one_hot_s,",
        "detail": "maple.maple.torch.sac.policies.pamdp_policy",
        "documentation": {}
    },
    {
        "label": "LOG_SIG_MIN",
        "kind": 5,
        "importPath": "maple.maple.torch.sac.policies.pamdp_policy",
        "description": "maple.maple.torch.sac.policies.pamdp_policy",
        "peekOfCode": "LOG_SIG_MIN = -20\nclass PAMDPPolicy(PyTorchModule, TorchStochasticPolicy):\n    def __init__(\n            self,\n            hidden_sizes,\n            obs_dim,\n            action_dim_s,\n            action_dim_p,\n            one_hot_s,\n    ):",
        "detail": "maple.maple.torch.sac.policies.pamdp_policy",
        "documentation": {}
    },
    {
        "label": "PolicyFromQ",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.policies.policy_from_q",
        "description": "maple.maple.torch.sac.policies.policy_from_q",
        "peekOfCode": "class PolicyFromQ(TorchStochasticPolicy):\n    def __init__(\n            self,\n            qf,\n            policy,\n            num_samples=10,\n            **kwargs\n    ):\n        super().__init__()\n        self.qf = qf",
        "detail": "maple.maple.torch.sac.policies.policy_from_q",
        "documentation": {}
    },
    {
        "label": "SACTrainer",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.sac",
        "description": "maple.maple.torch.sac.sac",
        "peekOfCode": "class SACTrainer(TorchTrainer, LossFunction):\n    def __init__(\n            self,\n            env,\n            policy,\n            qf1,\n            qf2,\n            target_qf1,\n            target_qf2,\n            discount=0.99,",
        "detail": "maple.maple.torch.sac.sac",
        "documentation": {}
    },
    {
        "label": "SACLosses",
        "kind": 5,
        "importPath": "maple.maple.torch.sac.sac",
        "description": "maple.maple.torch.sac.sac",
        "peekOfCode": "SACLosses = namedtuple(\n    'SACLosses',\n    'policy_loss qf1_loss qf2_loss alpha_loss',\n)\nclass SACTrainer(TorchTrainer, LossFunction):\n    def __init__(\n            self,\n            env,\n            policy,\n            qf1,",
        "detail": "maple.maple.torch.sac.sac",
        "documentation": {}
    },
    {
        "label": "SACHybridTrainer",
        "kind": 6,
        "importPath": "maple.maple.torch.sac.sac_hybrid",
        "description": "maple.maple.torch.sac.sac_hybrid",
        "peekOfCode": "class SACHybridTrainer(SACTrainer):\n    def __init__(\n            self,\n            target_entropy_s=None,\n            target_entropy_p=None,\n            target_entropy_config=None,\n            **sac_kwargs\n    ):\n        super().__init__(**sac_kwargs)\n        optimizer_class = sac_kwargs.get('optimizer_class', optim.Adam)",
        "detail": "maple.maple.torch.sac.sac_hybrid",
        "documentation": {}
    },
    {
        "label": "SACLosses",
        "kind": 5,
        "importPath": "maple.maple.torch.sac.sac_hybrid",
        "description": "maple.maple.torch.sac.sac_hybrid",
        "peekOfCode": "SACLosses = namedtuple(\n    'SACLosses',\n    'policy_loss qf1_loss qf2_loss alpha_s_loss alpha_p_loss',\n)\nclass SACHybridTrainer(SACTrainer):\n    def __init__(\n            self,\n            target_entropy_s=None,\n            target_entropy_p=None,\n            target_entropy_config=None,",
        "detail": "maple.maple.torch.sac.sac_hybrid",
        "documentation": {}
    },
    {
        "label": "CNN",
        "kind": 6,
        "importPath": "maple.maple.torch.conv_networks",
        "description": "maple.maple.torch.conv_networks",
        "peekOfCode": "class CNN(nn.Module):\n    def __init__(\n            self,\n            input_width,\n            input_height,\n            input_channels,\n            output_size,\n            kernel_sizes,\n            n_channels,\n            strides,",
        "detail": "maple.maple.torch.conv_networks",
        "documentation": {}
    },
    {
        "label": "TwoHeadDCNN",
        "kind": 6,
        "importPath": "maple.maple.torch.conv_networks",
        "description": "maple.maple.torch.conv_networks",
        "peekOfCode": "class TwoHeadDCNN(nn.Module):\n    def __init__(\n            self,\n            fc_input_size,\n            hidden_sizes,\n            deconv_input_width,\n            deconv_input_height,\n            deconv_input_channels,\n            deconv_output_kernel_size,\n            deconv_output_strides,",
        "detail": "maple.maple.torch.conv_networks",
        "documentation": {}
    },
    {
        "label": "DCNN",
        "kind": 6,
        "importPath": "maple.maple.torch.conv_networks",
        "description": "maple.maple.torch.conv_networks",
        "peekOfCode": "class DCNN(TwoHeadDCNN):\n    def forward(self, x):\n        return super().forward(x)[0]",
        "detail": "maple.maple.torch.conv_networks",
        "documentation": {}
    },
    {
        "label": "PyTorchModule",
        "kind": 6,
        "importPath": "maple.maple.torch.core",
        "description": "maple.maple.torch.core",
        "peekOfCode": "class PyTorchModule(nn.Module, metaclass=abc.ABCMeta):\n    \"\"\"\n    Keeping wrapper around to be a bit more future-proof.\n    \"\"\"\n    pass\ndef eval_np(module, *args, **kwargs):\n    \"\"\"\n    Eval this module with a numpy interface\n    Same as a call to __call__ except all Variable input/outputs are\n    replaced with numpy equivalents.",
        "detail": "maple.maple.torch.core",
        "documentation": {}
    },
    {
        "label": "eval_np",
        "kind": 2,
        "importPath": "maple.maple.torch.core",
        "description": "maple.maple.torch.core",
        "peekOfCode": "def eval_np(module, *args, **kwargs):\n    \"\"\"\n    Eval this module with a numpy interface\n    Same as a call to __call__ except all Variable input/outputs are\n    replaced with numpy equivalents.\n    Assumes the output is either a single object or a tuple of objects.\n    \"\"\"\n    torch_args = tuple(torch_ify(x) for x in args)\n    torch_kwargs = {k: torch_ify(v) for k, v in kwargs.items()}\n    outputs = module(*torch_args, **torch_kwargs)",
        "detail": "maple.maple.torch.core",
        "documentation": {}
    },
    {
        "label": "torch_ify",
        "kind": 2,
        "importPath": "maple.maple.torch.core",
        "description": "maple.maple.torch.core",
        "peekOfCode": "def torch_ify(np_array_or_other):\n    if isinstance(np_array_or_other, np.ndarray):\n        return ptu.from_numpy(np_array_or_other)\n    else:\n        return np_array_or_other\ndef np_ify(tensor_or_other):\n    if isinstance(tensor_or_other, torch.autograd.Variable):\n        return ptu.get_numpy(tensor_or_other)\n    else:\n        return tensor_or_other",
        "detail": "maple.maple.torch.core",
        "documentation": {}
    },
    {
        "label": "np_ify",
        "kind": 2,
        "importPath": "maple.maple.torch.core",
        "description": "maple.maple.torch.core",
        "peekOfCode": "def np_ify(tensor_or_other):\n    if isinstance(tensor_or_other, torch.autograd.Variable):\n        return ptu.get_numpy(tensor_or_other)\n    else:\n        return tensor_or_other\ndef _elem_or_tuple_to_variable(elem_or_tuple):\n    if isinstance(elem_or_tuple, tuple):\n        return tuple(\n            _elem_or_tuple_to_variable(e) for e in elem_or_tuple\n        )",
        "detail": "maple.maple.torch.core",
        "documentation": {}
    },
    {
        "label": "elem_or_tuple_to_numpy",
        "kind": 2,
        "importPath": "maple.maple.torch.core",
        "description": "maple.maple.torch.core",
        "peekOfCode": "def elem_or_tuple_to_numpy(elem_or_tuple):\n    if isinstance(elem_or_tuple, tuple):\n        return tuple(np_ify(x) for x in elem_or_tuple)\n    else:\n        return np_ify(elem_or_tuple)\ndef _filter_batch(np_batch):\n    for k, v in np_batch.items():\n        if v.dtype == np.bool:\n            yield k, v.astype(int)\n        else:",
        "detail": "maple.maple.torch.core",
        "documentation": {}
    },
    {
        "label": "np_to_pytorch_batch",
        "kind": 2,
        "importPath": "maple.maple.torch.core",
        "description": "maple.maple.torch.core",
        "peekOfCode": "def np_to_pytorch_batch(np_batch):\n    if isinstance(np_batch, dict):\n        return {\n            k: _elem_or_tuple_to_variable(x)\n            for k, x in _filter_batch(np_batch)\n            if x.dtype != np.dtype('O')  # ignore object (e.g. dictionaries)\n        }\n    else:\n        _elem_or_tuple_to_variable(np_batch)",
        "detail": "maple.maple.torch.core",
        "documentation": {}
    },
    {
        "label": "ImageDataset",
        "kind": 6,
        "importPath": "maple.maple.torch.data",
        "description": "maple.maple.torch.data",
        "peekOfCode": "class ImageDataset(Dataset):\n    def __init__(self, images, should_normalize=True):\n        super().__init__()\n        self.dataset = images\n        self.dataset_len = len(self.dataset)\n        assert should_normalize == (images.dtype == np.uint8)\n        self.should_normalize = should_normalize\n    def __len__(self):\n        return self.dataset_len\n    def __getitem__(self, idxs):",
        "detail": "maple.maple.torch.data",
        "documentation": {}
    },
    {
        "label": "InfiniteRandomSampler",
        "kind": 6,
        "importPath": "maple.maple.torch.data",
        "description": "maple.maple.torch.data",
        "peekOfCode": "class InfiniteRandomSampler(Sampler):\n    def __init__(self, data_source):\n        self.data_source = data_source\n        self.iter = iter(torch.randperm(len(self.data_source)).tolist())\n    def __iter__(self):\n        return self\n    def __next__(self):\n        try:\n            idx = next(self.iter)\n        except StopIteration:",
        "detail": "maple.maple.torch.data",
        "documentation": {}
    },
    {
        "label": "InfiniteWeightedRandomSampler",
        "kind": 6,
        "importPath": "maple.maple.torch.data",
        "description": "maple.maple.torch.data",
        "peekOfCode": "class InfiniteWeightedRandomSampler(Sampler):\n    def __init__(self, data_source, weights):\n        assert len(data_source) == len(weights)\n        assert len(weights.shape) == 1\n        self.data_source = data_source\n        # Always use CPU\n        self._weights = torch.from_numpy(weights)\n        self.iter = self._create_iterator()\n    def update_weights(self, weights):\n        self._weights = weights",
        "detail": "maple.maple.torch.data",
        "documentation": {}
    },
    {
        "label": "Distribution",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class Distribution(TorchDistribution):\n    def sample_and_logprob(self):\n        s = self.sample()\n        log_p = self.log_prob(s)\n        return s, log_p\n    def rsample_and_logprob(self):\n        s = self.rsample()\n        log_p = self.log_prob(s)\n        return s, log_p\n    def mle_estimate(self):",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "TorchDistributionWrapper",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class TorchDistributionWrapper(Distribution):\n    def __init__(self, distribution: TorchDistribution):\n        self.distribution = distribution\n    @property\n    def batch_shape(self):\n        return self.distribution.batch_shape\n    @property\n    def event_shape(self):\n        return self.distribution.event_shape\n    @property",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Delta",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class Delta(Distribution):\n    \"\"\"A deterministic distribution\"\"\"\n    def __init__(self, value):\n        self.value = value\n    def sample(self):\n        return self.value.detach()\n    def rsample(self):\n        return self.value\n    @property\n    def mean(self):",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Bernoulli",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class Bernoulli(Distribution, TorchBernoulli):\n    def get_diagnostics(self):\n        stats = OrderedDict()\n        stats.update(create_stats_ordered_dict(\n            'probability',\n            ptu.get_numpy(self.probs),\n        ))\n        return stats\nclass Independent(Distribution, TorchIndependent):\n    def get_diagnostics(self):",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Independent",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class Independent(Distribution, TorchIndependent):\n    def get_diagnostics(self):\n        return self.base_dist.get_diagnostics()\nclass Beta(Distribution, TorchBeta):\n    def get_diagnostics(self):\n        stats = OrderedDict()\n        stats.update(create_stats_ordered_dict(\n            'alpha',\n            ptu.get_numpy(self.concentration0),\n        ))",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Beta",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class Beta(Distribution, TorchBeta):\n    def get_diagnostics(self):\n        stats = OrderedDict()\n        stats.update(create_stats_ordered_dict(\n            'alpha',\n            ptu.get_numpy(self.concentration0),\n        ))\n        stats.update(create_stats_ordered_dict(\n            'beta',\n            ptu.get_numpy(self.concentration1),",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "MultivariateDiagonalNormal",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class MultivariateDiagonalNormal(TorchDistributionWrapper):\n    from torch.distributions import constraints\n    arg_constraints = {'loc': constraints.real, 'scale': constraints.positive}\n    def __init__(self, loc, scale_diag, reinterpreted_batch_ndims=1):\n        dist = Independent(TorchNormal(loc, scale_diag),\n                           reinterpreted_batch_ndims=reinterpreted_batch_ndims)\n        super().__init__(dist)\n    def get_diagnostics(self):\n        stats = OrderedDict()\n        stats.update(create_stats_ordered_dict(",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixture",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class GaussianMixture(Distribution):\n    def __init__(self, normal_means, normal_stds, weights):\n        self.num_gaussians = weights.shape[1]\n        self.normal_means = normal_means\n        self.normal_stds = normal_stds\n        self.normal = MultivariateDiagonalNormal(normal_means, normal_stds)\n        self.normals = [MultivariateDiagonalNormal(normal_means[:, :, i], normal_stds[:, :, i]) for i in range(self.num_gaussians)]\n        self.weights = weights\n        self.categorical = OneHotCategorical(self.weights[:, :, 0])\n    def log_prob(self, value, ):",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "GaussianMixtureFull",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class GaussianMixtureFull(Distribution):\n    def __init__(self, normal_means, normal_stds, weights):\n        self.num_gaussians = weights.shape[-1]\n        self.normal_means = normal_means\n        self.normal_stds = normal_stds\n        self.normal = MultivariateDiagonalNormal(normal_means, normal_stds)\n        self.normals = [MultivariateDiagonalNormal(normal_means[:, :, i], normal_stds[:, :, i]) for i in range(self.num_gaussians)]\n        self.weights = (weights + epsilon) / (1 + epsilon * self.num_gaussians)\n        assert (self.weights > 0).all()\n        self.categorical = Categorical(self.weights)",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "TanhNormal",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class TanhNormal(Distribution):\n    \"\"\"\n    Represent distribution of X where\n        X ~ tanh(Z)\n        Z ~ N(mean, std)\n    Note: this is not very numerically stable.\n    \"\"\"\n    def __init__(self, normal_mean, normal_std, epsilon=1e-6, prefix=''):\n        \"\"\"\n        :param normal_mean: Mean of the normal distribution",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "Softmax",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class Softmax(Distribution):\n    def __init__(self, logits, one_hot=False, prefix=''):\n        self.logits = logits\n        self.check_logits()\n        self.one_hot = one_hot\n        if one_hot:\n            self.distr = torch.distributions.one_hot_categorical.OneHotCategorical(\n                logits=self.logits,\n            )\n        else:",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "HybridDistribution",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class HybridDistribution(Distribution):\n    def __init__(self, rev_order):\n        super().__init__()\n        self.rev_order = rev_order\n    def concat_values(self, value1, value2):\n        if self.rev_order:\n            return torch.cat([value2, value1], dim=-1)\n        else:\n            return torch.cat([value1, value2], dim=-1)\n    def expand_tensors(self, tensor_list, expand_factor, interleave):",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "ConcatDistribution",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class ConcatDistribution(HybridDistribution):\n    def __init__(self, distr1, distr2, rev_order=False):\n        super().__init__(rev_order=rev_order)\n        self.distr1 = distr1\n        self.distr2 = distr2\n    def sample_n(self, n):\n        raise NotImplementedError\n    def log_prob(self, value):\n        raise NotImplementedError\n    def sample(self):",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "DistributionList",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class DistributionList(Distribution):\n    def __init__(self, distr1, distr2, rev_order=False):\n        super().__init__(rev_order=rev_order)\n        self.distr1 = distr1\n        self.distr2 = distr2\nclass HierarchicalDistribution(HybridDistribution):\n    def __init__(self, distr1, distr2_cond_fn, rev_order=False):\n        super().__init__(rev_order=rev_order)\n        self.distr1 = distr1\n        self.distr2_cond_fn = distr2_cond_fn",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "HierarchicalDistribution",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class HierarchicalDistribution(HybridDistribution):\n    def __init__(self, distr1, distr2_cond_fn, rev_order=False):\n        super().__init__(rev_order=rev_order)\n        self.distr1 = distr1\n        self.distr2_cond_fn = distr2_cond_fn\n        self.distr2_tmp = None\n    def sample_n(self, n):\n        raise NotImplementedError\n    def log_prob(self, value):\n        raise NotImplementedError",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "DistributionConcatValue",
        "kind": 6,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "class DistributionConcatValue(HybridDistribution):\n    def __init__(self, value_fixed, distr, rev_order=False):\n        super().__init__(rev_order=rev_order)\n        self.value_fixed = value_fixed\n        self.distr = distr\n    def sample_n(self, n):\n        raise NotImplementedError\n    def log_prob(self, value):\n        raise NotImplementedError\n    def sample(self):",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "epsilon",
        "kind": 5,
        "importPath": "maple.maple.torch.distributions",
        "description": "maple.maple.torch.distributions",
        "peekOfCode": "epsilon = 0.001\nclass GaussianMixtureFull(Distribution):\n    def __init__(self, normal_means, normal_stds, weights):\n        self.num_gaussians = weights.shape[-1]\n        self.normal_means = normal_means\n        self.normal_stds = normal_stds\n        self.normal = MultivariateDiagonalNormal(normal_means, normal_stds)\n        self.normals = [MultivariateDiagonalNormal(normal_means[:, :, i], normal_stds[:, :, i]) for i in range(self.num_gaussians)]\n        self.weights = (weights + epsilon) / (1 + epsilon * self.num_gaussians)\n        assert (self.weights > 0).all()",
        "detail": "maple.maple.torch.distributions",
        "documentation": {}
    },
    {
        "label": "HuberLoss",
        "kind": 6,
        "importPath": "maple.maple.torch.modules",
        "description": "maple.maple.torch.modules",
        "peekOfCode": "class HuberLoss(nn.Module):\n    def __init__(self, delta=1):\n        super().__init__()\n        self.huber_loss_delta1 = nn.SmoothL1Loss()\n        self.delta = delta\n    def forward(self, x, x_hat):\n        loss = self.huber_loss_delta1(x / self.delta, x_hat / self.delta)\n        return loss * self.delta * self.delta\nclass LayerNorm(nn.Module):\n    \"\"\"",
        "detail": "maple.maple.torch.modules",
        "documentation": {}
    },
    {
        "label": "LayerNorm",
        "kind": 6,
        "importPath": "maple.maple.torch.modules",
        "description": "maple.maple.torch.modules",
        "peekOfCode": "class LayerNorm(nn.Module):\n    \"\"\"\n    Simple 1D LayerNorm.\n    \"\"\"\n    def __init__(self, features, center=True, scale=False, eps=1e-6):\n        super().__init__()\n        self.center = center\n        self.scale = scale\n        self.eps = eps\n        if self.scale:",
        "detail": "maple.maple.torch.modules",
        "documentation": {}
    },
    {
        "label": "identity",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def identity(x):\n    return x\n_str_to_activation = {\n    'identity': identity,\n    'relu': nn.ReLU(),\n    'tanh': nn.Tanh(),\n    'leaky_relu': nn.LeakyReLU(),\n    'sigmoid': nn.Sigmoid(),\n    'selu': nn.SELU(),\n    'softplus': nn.Softplus(),",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "activation_from_string",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def activation_from_string(string):\n    return _str_to_activation[string]\ndef soft_update_from_to(source, target, tau):\n    for target_param, param in zip(target.parameters(), source.parameters()):\n        target_param.data.copy_(\n            target_param.data * (1.0 - tau) + param.data * tau\n        )\ndef copy_model_params_from_to(source, target):\n    for target_param, param in zip(target.parameters(), source.parameters()):\n        target_param.data.copy_(param.data)",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "soft_update_from_to",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def soft_update_from_to(source, target, tau):\n    for target_param, param in zip(target.parameters(), source.parameters()):\n        target_param.data.copy_(\n            target_param.data * (1.0 - tau) + param.data * tau\n        )\ndef copy_model_params_from_to(source, target):\n    for target_param, param in zip(target.parameters(), source.parameters()):\n        target_param.data.copy_(param.data)\ndef maximum_2d(t1, t2):\n    # noinspection PyArgumentList",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "copy_model_params_from_to",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def copy_model_params_from_to(source, target):\n    for target_param, param in zip(target.parameters(), source.parameters()):\n        target_param.data.copy_(param.data)\ndef maximum_2d(t1, t2):\n    # noinspection PyArgumentList\n    return torch.max(\n        torch.cat((t1.unsqueeze(2), t2.unsqueeze(2)), dim=2),\n        dim=2,\n    )[0].squeeze(2)\ndef kronecker_product(t1, t2):",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "maximum_2d",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def maximum_2d(t1, t2):\n    # noinspection PyArgumentList\n    return torch.max(\n        torch.cat((t1.unsqueeze(2), t2.unsqueeze(2)), dim=2),\n        dim=2,\n    )[0].squeeze(2)\ndef kronecker_product(t1, t2):\n    \"\"\"\n    Computes the Kronecker product between two tensors\n    See https://en.wikipedia.org/wiki/Kronecker_product",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "kronecker_product",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def kronecker_product(t1, t2):\n    \"\"\"\n    Computes the Kronecker product between two tensors\n    See https://en.wikipedia.org/wiki/Kronecker_product\n    \"\"\"\n    t1_height, t1_width = t1.size()\n    t2_height, t2_width = t2.size()\n    out_height = t1_height * t2_height\n    out_width = t1_width * t2_width\n    # TODO(vitchyr): see if you can use expand instead of repeat",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "alpha_dropout",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def alpha_dropout(\n        x,\n        p=0.05,\n        alpha=-1.7580993408473766,\n        fixedPointMean=0,\n        fixedPointVar=1,\n        training=False,\n):\n    keep_prob = 1 - p\n    if keep_prob == 1 or not training:",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "alpha_selu",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def alpha_selu(x, training=False):\n    return alpha_dropout(nn.SELU(x), training=training)\ndef double_moments(x, y):\n    \"\"\"\n    Returns the first two moments between x and y.\n    Specifically, for each vector x_i and y_i in x and y, compute their\n    outer-product. Flatten this resulting matrix and return it.\n    The first moments (i.e. x_i and y_i) are included by appending a `1` to x_i\n    and y_i before taking the outer product.\n    :param x: Shape [batch_size, feature_x_dim]",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "double_moments",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def double_moments(x, y):\n    \"\"\"\n    Returns the first two moments between x and y.\n    Specifically, for each vector x_i and y_i in x and y, compute their\n    outer-product. Flatten this resulting matrix and return it.\n    The first moments (i.e. x_i and y_i) are included by appending a `1` to x_i\n    and y_i before taking the outer product.\n    :param x: Shape [batch_size, feature_x_dim]\n    :param y: Shape [batch_size, feature_y_dim]\n    :return: Shape [batch_size, (feature_x_dim + 1) * (feature_y_dim + 1)",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "batch_diag",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def batch_diag(diag_values, diag_mask=None):\n    batch_size, dim = diag_values.size()\n    if diag_mask is None:\n        diag_mask = torch.diag(torch.ones(dim))\n    batch_diag_mask = diag_mask.unsqueeze(0).expand(batch_size, dim, dim)\n    batch_diag_values = diag_values.unsqueeze(1).expand(batch_size, dim, dim)\n    return batch_diag_values * batch_diag_mask\ndef batch_square_vector(vector, M):\n    \"\"\"\n    Compute x^T M x",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "batch_square_vector",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def batch_square_vector(vector, M):\n    \"\"\"\n    Compute x^T M x\n    \"\"\"\n    vector = vector.unsqueeze(2)\n    return torch.bmm(torch.bmm(vector.transpose(2, 1), M), vector).squeeze(2)\ndef fanin_init(tensor):\n    size = tensor.size()\n    if len(size) == 2:\n        fan_in = size[0]",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "fanin_init",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def fanin_init(tensor):\n    size = tensor.size()\n    if len(size) == 2:\n        fan_in = size[0]\n    elif len(size) > 2:\n        fan_in = np.prod(size[1:])\n    else:\n        raise Exception(\"Shape must be have dimension at least 2.\")\n    bound = 1. / np.sqrt(fan_in)\n    return tensor.data.uniform_(-bound, bound)",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "fanin_init_weights_like",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def fanin_init_weights_like(tensor):\n    size = tensor.size()\n    if len(size) == 2:\n        fan_in = size[0]\n    elif len(size) > 2:\n        fan_in = np.prod(size[1:])\n    else:\n        raise Exception(\"Shape must be have dimension at least 2.\")\n    bound = 1. / np.sqrt(fan_in)\n    new_tensor = FloatTensor(tensor.size())",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "almost_identity_weights_like",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def almost_identity_weights_like(tensor):\n    \"\"\"\n    Set W = I + lambda * Gaussian no\n    :param tensor:\n    :return:\n    \"\"\"\n    shape = tensor.size()\n    init_value = np.eye(*shape)\n    init_value += 0.01 * np.random.rand(*shape)\n    return FloatTensor(init_value)",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "clip1",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def clip1(x):\n    return torch.clamp(x, -1, 1)\ndef compute_conv_output_size(h_in, w_in, kernel_size, stride, padding=0):\n    h_out = (h_in + 2 * padding - (kernel_size - 1) - 1) / stride + 1\n    w_out = (w_in + 2 * padding - (kernel_size - 1) - 1) / stride + 1\n    return int(np.floor(h_out)), int(np.floor(w_out))\ndef compute_deconv_output_size(h_in, w_in, kernel_size, stride, padding=0):\n    h_out = (h_in - 1) * stride - 2 * padding + kernel_size\n    w_out = (w_in - 1) * stride - 2 * padding + kernel_size\n    return int(np.floor(h_out)), int(np.floor(w_out))",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "compute_conv_output_size",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def compute_conv_output_size(h_in, w_in, kernel_size, stride, padding=0):\n    h_out = (h_in + 2 * padding - (kernel_size - 1) - 1) / stride + 1\n    w_out = (w_in + 2 * padding - (kernel_size - 1) - 1) / stride + 1\n    return int(np.floor(h_out)), int(np.floor(w_out))\ndef compute_deconv_output_size(h_in, w_in, kernel_size, stride, padding=0):\n    h_out = (h_in - 1) * stride - 2 * padding + kernel_size\n    w_out = (w_in - 1) * stride - 2 * padding + kernel_size\n    return int(np.floor(h_out)), int(np.floor(w_out))\ndef compute_conv_layer_sizes(h_in, w_in, kernel_sizes, strides, paddings=None):\n    if paddings == None:",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "compute_deconv_output_size",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def compute_deconv_output_size(h_in, w_in, kernel_size, stride, padding=0):\n    h_out = (h_in - 1) * stride - 2 * padding + kernel_size\n    w_out = (w_in - 1) * stride - 2 * padding + kernel_size\n    return int(np.floor(h_out)), int(np.floor(w_out))\ndef compute_conv_layer_sizes(h_in, w_in, kernel_sizes, strides, paddings=None):\n    if paddings == None:\n        for kernel, stride in zip(kernel_sizes, strides):\n            h_in, w_in = compute_conv_output_size(h_in, w_in, kernel, stride)\n            print('Output Size:', (h_in, w_in))\n    else:",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "compute_conv_layer_sizes",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def compute_conv_layer_sizes(h_in, w_in, kernel_sizes, strides, paddings=None):\n    if paddings == None:\n        for kernel, stride in zip(kernel_sizes, strides):\n            h_in, w_in = compute_conv_output_size(h_in, w_in, kernel, stride)\n            print('Output Size:', (h_in, w_in))\n    else:\n        for kernel, stride, padding in zip(kernel_sizes, strides, paddings):\n            h_in, w_in = compute_conv_output_size(h_in, w_in, kernel, stride,\n                                                  padding=padding)\n            print('Output Size:', (h_in, w_in))",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "compute_deconv_layer_sizes",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def compute_deconv_layer_sizes(h_in, w_in, kernel_sizes, strides,\n                               paddings=None):\n    if paddings == None:\n        for kernel, stride in zip(kernel_sizes, strides):\n            h_in, w_in = compute_deconv_output_size(h_in, w_in, kernel, stride)\n            print('Output Size:', (h_in, w_in))\n    else:\n        for kernel, stride, padding in zip(kernel_sizes, strides, paddings):\n            h_in, w_in = compute_deconv_output_size(h_in, w_in, kernel, stride,\n                                                    padding=padding)",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "set_gpu_mode",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def set_gpu_mode(mode, gpu_id=0):\n    global _use_gpu\n    global device\n    global _gpu_id\n    _gpu_id = gpu_id\n    _use_gpu = mode\n    device = torch.device(\"cuda:\" + str(gpu_id) if _use_gpu else \"cpu\")\ndef gpu_enabled():\n    return _use_gpu\ndef set_device(gpu_id):",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "gpu_enabled",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def gpu_enabled():\n    return _use_gpu\ndef set_device(gpu_id):\n    torch.cuda.set_device(gpu_id)\n# noinspection PyPep8Naming\ndef FloatTensor(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.FloatTensor(*args, **kwargs, device=torch_device)\ndef from_numpy(*args, **kwargs):",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "set_device",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def set_device(gpu_id):\n    torch.cuda.set_device(gpu_id)\n# noinspection PyPep8Naming\ndef FloatTensor(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.FloatTensor(*args, **kwargs, device=torch_device)\ndef from_numpy(*args, **kwargs):\n    return torch.from_numpy(*args, **kwargs).float().to(device)\ndef get_numpy(tensor):",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "FloatTensor",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def FloatTensor(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.FloatTensor(*args, **kwargs, device=torch_device)\ndef from_numpy(*args, **kwargs):\n    return torch.from_numpy(*args, **kwargs).float().to(device)\ndef get_numpy(tensor):\n    return tensor.to('cpu').detach().numpy()\ndef randint(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "from_numpy",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def from_numpy(*args, **kwargs):\n    return torch.from_numpy(*args, **kwargs).float().to(device)\ndef get_numpy(tensor):\n    return tensor.to('cpu').detach().numpy()\ndef randint(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.randint(*sizes, **kwargs, device=torch_device)\ndef zeros(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "get_numpy",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def get_numpy(tensor):\n    return tensor.to('cpu').detach().numpy()\ndef randint(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.randint(*sizes, **kwargs, device=torch_device)\ndef zeros(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.zeros(*sizes, **kwargs, device=torch_device)",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "randint",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def randint(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.randint(*sizes, **kwargs, device=torch_device)\ndef zeros(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.zeros(*sizes, **kwargs, device=torch_device)\ndef ones(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "zeros",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def zeros(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.zeros(*sizes, **kwargs, device=torch_device)\ndef ones(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.ones(*sizes, **kwargs, device=torch_device)\ndef ones_like(*args, torch_device=None, **kwargs):\n    if torch_device is None:",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "ones",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def ones(*sizes, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.ones(*sizes, **kwargs, device=torch_device)\ndef ones_like(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.ones_like(*args, **kwargs, device=torch_device)\ndef randn(*args, torch_device=None, **kwargs):\n    if torch_device is None:",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "ones_like",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def ones_like(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.ones_like(*args, **kwargs, device=torch_device)\ndef randn(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.randn(*args, **kwargs, device=torch_device)\ndef zeros_like(*args, torch_device=None, **kwargs):\n    if torch_device is None:",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "randn",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def randn(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.randn(*args, **kwargs, device=torch_device)\ndef zeros_like(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.zeros_like(*args, **kwargs, device=torch_device)\ndef tensor(*args, torch_device=None, **kwargs):\n    if torch_device is None:",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "zeros_like",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def zeros_like(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.zeros_like(*args, **kwargs, device=torch_device)\ndef tensor(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.tensor(*args, **kwargs, device=torch_device)\ndef normal(*args, **kwargs):\n    return torch.normal(*args, **kwargs).to(device)",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "tensor",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def tensor(*args, torch_device=None, **kwargs):\n    if torch_device is None:\n        torch_device = device\n    return torch.tensor(*args, **kwargs, device=torch_device)\ndef normal(*args, **kwargs):\n    return torch.normal(*args, **kwargs).to(device)",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "normal",
        "kind": 2,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "def normal(*args, **kwargs):\n    return torch.normal(*args, **kwargs).to(device)",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "_str_to_activation",
        "kind": 5,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "_str_to_activation = {\n    'identity': identity,\n    'relu': nn.ReLU(),\n    'tanh': nn.Tanh(),\n    'leaky_relu': nn.LeakyReLU(),\n    'sigmoid': nn.Sigmoid(),\n    'selu': nn.SELU(),\n    'softplus': nn.Softplus(),\n}\ndef activation_from_string(string):",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "_use_gpu",
        "kind": 5,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "_use_gpu = False\ndevice = None\ndef set_gpu_mode(mode, gpu_id=0):\n    global _use_gpu\n    global device\n    global _gpu_id\n    _gpu_id = gpu_id\n    _use_gpu = mode\n    device = torch.device(\"cuda:\" + str(gpu_id) if _use_gpu else \"cpu\")\ndef gpu_enabled():",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "device",
        "kind": 5,
        "importPath": "maple.maple.torch.pytorch_util",
        "description": "maple.maple.torch.pytorch_util",
        "peekOfCode": "device = None\ndef set_gpu_mode(mode, gpu_id=0):\n    global _use_gpu\n    global device\n    global _gpu_id\n    _gpu_id = gpu_id\n    _use_gpu = mode\n    device = torch.device(\"cuda:\" + str(gpu_id) if _use_gpu else \"cpu\")\ndef gpu_enabled():\n    return _use_gpu",
        "detail": "maple.maple.torch.pytorch_util",
        "documentation": {}
    },
    {
        "label": "TorchOnlineRLAlgorithm",
        "kind": 6,
        "importPath": "maple.maple.torch.torch_rl_algorithm",
        "description": "maple.maple.torch.torch_rl_algorithm",
        "peekOfCode": "class TorchOnlineRLAlgorithm(OnlineRLAlgorithm):\n    def to(self, device):\n        for net in self.trainer.networks:\n            net.to(device)\n    def training_mode(self, mode):\n        for net in self.trainer.networks:\n            net.train(mode)\nclass TorchBatchRLAlgorithm(BatchRLAlgorithm):\n    def to(self, device):\n        for net in self.trainer.networks:",
        "detail": "maple.maple.torch.torch_rl_algorithm",
        "documentation": {}
    },
    {
        "label": "TorchBatchRLAlgorithm",
        "kind": 6,
        "importPath": "maple.maple.torch.torch_rl_algorithm",
        "description": "maple.maple.torch.torch_rl_algorithm",
        "peekOfCode": "class TorchBatchRLAlgorithm(BatchRLAlgorithm):\n    def to(self, device):\n        for net in self.trainer.networks:\n            net.to(device)\n    def training_mode(self, mode):\n        for net in self.trainer.networks:\n            net.train(mode)\nclass TorchTrainer(Trainer, metaclass=abc.ABCMeta):\n    def __init__(self):\n        self._num_train_steps = 0",
        "detail": "maple.maple.torch.torch_rl_algorithm",
        "documentation": {}
    },
    {
        "label": "TorchTrainer",
        "kind": 6,
        "importPath": "maple.maple.torch.torch_rl_algorithm",
        "description": "maple.maple.torch.torch_rl_algorithm",
        "peekOfCode": "class TorchTrainer(Trainer, metaclass=abc.ABCMeta):\n    def __init__(self):\n        self._num_train_steps = 0\n    def train(self, np_batch):\n        self._num_train_steps += 1\n        batch = np_to_pytorch_batch(np_batch)\n        self.train_from_torch(batch)\n    def get_diagnostics(self):\n        return OrderedDict([\n            ('num train calls', self._num_train_steps),",
        "detail": "maple.maple.torch.torch_rl_algorithm",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "kind": 6,
        "importPath": "maple.maple.util.data_processing",
        "description": "maple.maple.util.data_processing",
        "peekOfCode": "class Experiment(object):\n    \"\"\"\n    Represents an experiment, which consists of many Trials.\n    \"\"\"\n    def __init__(self, base_dir, criteria=None):\n        \"\"\"\n        :param base_dir: A path. Directory structure should be something like:\n        ```\n        base_dir/\n            foo/",
        "detail": "maple.maple.util.data_processing",
        "documentation": {}
    },
    {
        "label": "matches_dict",
        "kind": 2,
        "importPath": "maple.maple.util.data_processing",
        "description": "maple.maple.util.data_processing",
        "peekOfCode": "def matches_dict(criteria_dict, test_dict):\n    for k, v in criteria_dict.items():\n        if k not in test_dict:\n            return False\n        else:\n            if test_dict[k] != v:\n                return False\n    return True\nclass Experiment(object):\n    \"\"\"",
        "detail": "maple.maple.util.data_processing",
        "documentation": {}
    },
    {
        "label": "get_dirs",
        "kind": 2,
        "importPath": "maple.maple.util.data_processing",
        "description": "maple.maple.util.data_processing",
        "peekOfCode": "def get_dirs(root):\n    \"\"\"\n    Get a list of all the directories under this directory.\n    \"\"\"\n    yield root\n    for root, directories, filenames in os.walk(root):\n        for directory in directories:\n            yield os.path.join(root, directory)\ndef get_trials(base_dir, verbose=False, criteria=None, excluded_seeds=()):\n    \"\"\"",
        "detail": "maple.maple.util.data_processing",
        "documentation": {}
    },
    {
        "label": "get_trials",
        "kind": 2,
        "importPath": "maple.maple.util.data_processing",
        "description": "maple.maple.util.data_processing",
        "peekOfCode": "def get_trials(base_dir, verbose=False, criteria=None, excluded_seeds=()):\n    \"\"\"\n    Get a list of (data, variant, directory) tuples, loaded from\n        - process.csv\n        - variant.json\n    files under this directory.\n    :param base_dir: root directory\n    :param criteria: dictionary of keys and values. Only load experiemnts\n    that match this criteria.\n    :return: List of tuples. Each tuple has:",
        "detail": "maple.maple.util.data_processing",
        "documentation": {}
    },
    {
        "label": "get_all_csv",
        "kind": 2,
        "importPath": "maple.maple.util.data_processing",
        "description": "maple.maple.util.data_processing",
        "peekOfCode": "def get_all_csv(base_dir, verbose=False):\n    \"\"\"\n    Get a list of all csv data under a directory.\n    :param base_dir: root directory\n    \"\"\"\n    data = []\n    delimiter = ','\n    for dir_name in get_dirs(base_dir):\n        for data_file_name in os.listdir(dir_name):\n            if data_file_name.endswith(\".csv\"):",
        "detail": "maple.maple.util.data_processing",
        "documentation": {}
    },
    {
        "label": "get_unique_param_to_values",
        "kind": 2,
        "importPath": "maple.maple.util.data_processing",
        "description": "maple.maple.util.data_processing",
        "peekOfCode": "def get_unique_param_to_values(all_variants):\n    variant_key_to_values = defaultdict(set)\n    for variant in all_variants:\n        for k, v in variant.items():\n            if type(v) == list:\n                v = str(v)\n            variant_key_to_values[k].add(v)\n    unique_key_to_values = {\n        k: variant_key_to_values[k]\n        for k in variant_key_to_values",
        "detail": "maple.maple.util.data_processing",
        "documentation": {}
    },
    {
        "label": "Trial",
        "kind": 5,
        "importPath": "maple.maple.util.data_processing",
        "description": "maple.maple.util.data_processing",
        "peekOfCode": "Trial = namedtuple(\"Trial\", [\"data\", \"variant\", \"directory\"])\ndef matches_dict(criteria_dict, test_dict):\n    for k, v in criteria_dict.items():\n        if k not in test_dict:\n            return False\n        else:\n            if test_dict[k] != v:\n                return False\n    return True\nclass Experiment(object):",
        "detail": "maple.maple.util.data_processing",
        "documentation": {}
    },
    {
        "label": "Hyperparameter",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class Hyperparameter(metaclass=abc.ABCMeta):\n    def __init__(self, name):\n        self._name = name\n    @property\n    def name(self):\n        return self._name\nclass RandomHyperparameter(Hyperparameter):\n    def __init__(self, name):\n        super().__init__(name)\n        self._last_value = None",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "RandomHyperparameter",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class RandomHyperparameter(Hyperparameter):\n    def __init__(self, name):\n        super().__init__(name)\n        self._last_value = None\n    @abc.abstractmethod\n    def generate_next_value(self):\n        \"\"\"Return a value for the hyperparameter\"\"\"\n        return\n    def generate(self):\n        self._last_value = self.generate_next_value()",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "EnumParam",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class EnumParam(RandomHyperparameter):\n    def __init__(self, name, possible_values):\n        super().__init__(name)\n        self.possible_values = possible_values\n    def generate_next_value(self):\n        return random.choice(self.possible_values)\nclass LogFloatParam(RandomHyperparameter):\n    \"\"\"\n    Return something ranging from [min_value + offset, max_value + offset],\n    distributed with a log.",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "LogFloatParam",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class LogFloatParam(RandomHyperparameter):\n    \"\"\"\n    Return something ranging from [min_value + offset, max_value + offset],\n    distributed with a log.\n    \"\"\"\n    def __init__(self, name, min_value, max_value, *, offset=0):\n        super(LogFloatParam, self).__init__(name)\n        self._linear_float_param = LinearFloatParam(\"log_\" + name,\n                                                    math.log(min_value),\n                                                    math.log(max_value))",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "LinearFloatParam",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class LinearFloatParam(RandomHyperparameter):\n    def __init__(self, name, min_value, max_value):\n        super(LinearFloatParam, self).__init__(name)\n        self._min = min_value\n        self._delta = max_value - min_value\n    def generate_next_value(self):\n        return random.random() * self._delta + self._min\nclass LogIntParam(RandomHyperparameter):\n    def __init__(self, name, min_value, max_value, *, offset=0):\n        super().__init__(name)",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "LogIntParam",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class LogIntParam(RandomHyperparameter):\n    def __init__(self, name, min_value, max_value, *, offset=0):\n        super().__init__(name)\n        self._linear_float_param = LinearFloatParam(\"log_\" + name,\n                                                    math.log(min_value),\n                                                    math.log(max_value))\n        self.offset = offset\n    def generate_next_value(self):\n        return int(\n            math.e ** (self._linear_float_param.generate()) + self.offset",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "LinearIntParam",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class LinearIntParam(RandomHyperparameter):\n    def __init__(self, name, min_value, max_value):\n        super(LinearIntParam, self).__init__(name)\n        self._min = min_value\n        self._max = max_value\n    def generate_next_value(self):\n        return random.randint(self._min, self._max)\nclass FixedParam(RandomHyperparameter):\n    def __init__(self, name, value):\n        super().__init__(name)",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "FixedParam",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class FixedParam(RandomHyperparameter):\n    def __init__(self, name, value):\n        super().__init__(name)\n        self._value = value\n    def generate_next_value(self):\n        return self._value\nclass Sweeper(object):\n    pass\nclass RandomHyperparameterSweeper(Sweeper):\n    def __init__(self, hyperparameters=None, default_kwargs=None):",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "Sweeper",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class Sweeper(object):\n    pass\nclass RandomHyperparameterSweeper(Sweeper):\n    def __init__(self, hyperparameters=None, default_kwargs=None):\n        if default_kwargs is None:\n            default_kwargs = {}\n        self._hyperparameters = hyperparameters or []\n        self._validate_hyperparameters()\n        self._default_kwargs = default_kwargs\n    def _validate_hyperparameters(self):",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "RandomHyperparameterSweeper",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class RandomHyperparameterSweeper(Sweeper):\n    def __init__(self, hyperparameters=None, default_kwargs=None):\n        if default_kwargs is None:\n            default_kwargs = {}\n        self._hyperparameters = hyperparameters or []\n        self._validate_hyperparameters()\n        self._default_kwargs = default_kwargs\n    def _validate_hyperparameters(self):\n        names = set()\n        for hp in self._hyperparameters:",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "DeterministicHyperparameterSweeper",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class DeterministicHyperparameterSweeper(Sweeper):\n    \"\"\"\n    Do a grid search over hyperparameters based on a predefined set of\n    hyperparameters.\n    \"\"\"\n    def __init__(self, hyperparameters, default_parameters=None):\n        \"\"\"\n        :param hyperparameters: A dictionary of the form\n        ```\n        {",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "DeterministicSweeperCombiner",
        "kind": 6,
        "importPath": "maple.maple.util.hyperparameter",
        "description": "maple.maple.util.hyperparameter",
        "peekOfCode": "class DeterministicSweeperCombiner(object):\n    \"\"\"\n    A simple wrapper to combiner multiple DeterministicHyperParameterSweeper's\n    \"\"\"\n    def __init__(self, sweepers: List[DeterministicHyperparameterSweeper]):\n        self._sweepers = sweepers\n    def iterate_list_of_hyperparameters(self):\n        \"\"\"\n        Usage:\n        ```",
        "detail": "maple.maple.util.hyperparameter",
        "documentation": {}
    },
    {
        "label": "CPU_Unpickler",
        "kind": 6,
        "importPath": "maple.maple.util.io",
        "description": "maple.maple.util.io",
        "peekOfCode": "class CPU_Unpickler(pickle.Unpickler):\n    \"\"\"Utility for loading a pickled model on CPU machine saved from a GPU\"\"\"\n    def find_class(self, module, name):\n        if module == 'torch.storage' and name == '_load_from_bytes':\n            return lambda b: torch.load(io.BytesIO(b), map_location='cpu')\n        else: return super().find_class(module, name)\ndef load_local_or_remote_file(filepath, file_type=None):\n    local_path = local_path_from_s3_or_local_path(filepath)\n    if file_type is None:\n        extension = local_path.split('.')[-1]",
        "detail": "maple.maple.util.io",
        "documentation": {}
    },
    {
        "label": "local_path_from_s3_or_local_path",
        "kind": 2,
        "importPath": "maple.maple.util.io",
        "description": "maple.maple.util.io",
        "peekOfCode": "def local_path_from_s3_or_local_path(filename):\n    relative_filename = os.path.join(LOCAL_LOG_DIR, filename)\n    if os.path.isfile(filename):\n        return filename\n    elif os.path.isfile(relative_filename):\n        return relative_filename\n    else:\n        return sync_down(filename)\ndef sync_down(path, check_exists=True):\n    is_docker = os.path.isfile(\"/.dockerenv\")",
        "detail": "maple.maple.util.io",
        "documentation": {}
    },
    {
        "label": "sync_down",
        "kind": 2,
        "importPath": "maple.maple.util.io",
        "description": "maple.maple.util.io",
        "peekOfCode": "def sync_down(path, check_exists=True):\n    is_docker = os.path.isfile(\"/.dockerenv\")\n    if is_docker:\n        local_path = \"/tmp/%s\" % (path)\n    else:\n        local_path = \"%s/%s\" % (LOCAL_LOG_DIR, path)\n    if check_exists and os.path.isfile(local_path):\n        return local_path\n    local_dir = os.path.dirname(local_path)\n    os.makedirs(local_dir, exist_ok=True)",
        "detail": "maple.maple.util.io",
        "documentation": {}
    },
    {
        "label": "sync_down_folder",
        "kind": 2,
        "importPath": "maple.maple.util.io",
        "description": "maple.maple.util.io",
        "peekOfCode": "def sync_down_folder(path):\n    is_docker = os.path.isfile(\"/.dockerenv\")\n    if is_docker:\n        local_path = \"/tmp/%s\" % (path)\n    else:\n        local_path = \"%s/%s\" % (LOCAL_LOG_DIR, path)\n    local_dir = os.path.dirname(local_path)\n    os.makedirs(local_dir, exist_ok=True)\n    if is_docker:\n        from doodad.ec2.autoconfig import AUTOCONFIG",
        "detail": "maple.maple.util.io",
        "documentation": {}
    },
    {
        "label": "split_s3_full_path",
        "kind": 2,
        "importPath": "maple.maple.util.io",
        "description": "maple.maple.util.io",
        "peekOfCode": "def split_s3_full_path(s3_path):\n    \"\"\"\n    Split \"s3://foo/bar/baz\" into \"foo\" and \"bar/baz\"\n    \"\"\"\n    bucket_name_and_directories = s3_path.split('//')[1]\n    bucket_name, *directories = bucket_name_and_directories.split('/')\n    directory_path = '/'.join(directories)\n    return bucket_name, directory_path\nclass CPU_Unpickler(pickle.Unpickler):\n    \"\"\"Utility for loading a pickled model on CPU machine saved from a GPU\"\"\"",
        "detail": "maple.maple.util.io",
        "documentation": {}
    },
    {
        "label": "load_local_or_remote_file",
        "kind": 2,
        "importPath": "maple.maple.util.io",
        "description": "maple.maple.util.io",
        "peekOfCode": "def load_local_or_remote_file(filepath, file_type=None):\n    local_path = local_path_from_s3_or_local_path(filepath)\n    if file_type is None:\n        extension = local_path.split('.')[-1]\n        if extension == 'npy':\n            file_type = NUMPY\n        else:\n            file_type = PICKLE\n    else:\n        file_type = PICKLE",
        "detail": "maple.maple.util.io",
        "documentation": {}
    },
    {
        "label": "get_absolute_path",
        "kind": 2,
        "importPath": "maple.maple.util.io",
        "description": "maple.maple.util.io",
        "peekOfCode": "def get_absolute_path(path):\n    if path[0] == \"/\":\n        return path\n    else:\n        is_docker = os.path.isfile(\"/.dockerenv\")\n        if is_docker:\n            local_path = \"/tmp/%s\" % (path)\n        else:\n            local_path = \"%s/%s\" % (LOCAL_LOG_DIR, path)\n        return local_path",
        "detail": "maple.maple.util.io",
        "documentation": {}
    },
    {
        "label": "PICKLE",
        "kind": 5,
        "importPath": "maple.maple.util.io",
        "description": "maple.maple.util.io",
        "peekOfCode": "PICKLE = 'pickle'\nNUMPY = 'numpy'\nJOBLIB = 'joblib'\ndef local_path_from_s3_or_local_path(filename):\n    relative_filename = os.path.join(LOCAL_LOG_DIR, filename)\n    if os.path.isfile(filename):\n        return filename\n    elif os.path.isfile(relative_filename):\n        return relative_filename\n    else:",
        "detail": "maple.maple.util.io",
        "documentation": {}
    },
    {
        "label": "NUMPY",
        "kind": 5,
        "importPath": "maple.maple.util.io",
        "description": "maple.maple.util.io",
        "peekOfCode": "NUMPY = 'numpy'\nJOBLIB = 'joblib'\ndef local_path_from_s3_or_local_path(filename):\n    relative_filename = os.path.join(LOCAL_LOG_DIR, filename)\n    if os.path.isfile(filename):\n        return filename\n    elif os.path.isfile(relative_filename):\n        return relative_filename\n    else:\n        return sync_down(filename)",
        "detail": "maple.maple.util.io",
        "documentation": {}
    },
    {
        "label": "JOBLIB",
        "kind": 5,
        "importPath": "maple.maple.util.io",
        "description": "maple.maple.util.io",
        "peekOfCode": "JOBLIB = 'joblib'\ndef local_path_from_s3_or_local_path(filename):\n    relative_filename = os.path.join(LOCAL_LOG_DIR, filename)\n    if os.path.isfile(filename):\n        return filename\n    elif os.path.isfile(relative_filename):\n        return relative_filename\n    else:\n        return sync_down(filename)\ndef sync_down(path, check_exists=True):",
        "detail": "maple.maple.util.io",
        "documentation": {}
    },
    {
        "label": "ScalarSchedule",
        "kind": 6,
        "importPath": "maple.maple.util.ml_util",
        "description": "maple.maple.util.ml_util",
        "peekOfCode": "class ScalarSchedule(object, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def get_value(self, t):\n        pass\nclass ConstantSchedule(ScalarSchedule):\n    def __init__(self, value):\n        self._value = value\n    def get_value(self, t):\n        return self._value\nclass LinearSchedule(ScalarSchedule):",
        "detail": "maple.maple.util.ml_util",
        "documentation": {}
    },
    {
        "label": "ConstantSchedule",
        "kind": 6,
        "importPath": "maple.maple.util.ml_util",
        "description": "maple.maple.util.ml_util",
        "peekOfCode": "class ConstantSchedule(ScalarSchedule):\n    def __init__(self, value):\n        self._value = value\n    def get_value(self, t):\n        return self._value\nclass LinearSchedule(ScalarSchedule):\n    \"\"\"\n    Linearly interpolate and then stop at a final value.\n    \"\"\"\n    def __init__(",
        "detail": "maple.maple.util.ml_util",
        "documentation": {}
    },
    {
        "label": "LinearSchedule",
        "kind": 6,
        "importPath": "maple.maple.util.ml_util",
        "description": "maple.maple.util.ml_util",
        "peekOfCode": "class LinearSchedule(ScalarSchedule):\n    \"\"\"\n    Linearly interpolate and then stop at a final value.\n    \"\"\"\n    def __init__(\n            self,\n            init_value,\n            final_value,\n            ramp_duration,\n    ):",
        "detail": "maple.maple.util.ml_util",
        "documentation": {}
    },
    {
        "label": "IntLinearSchedule",
        "kind": 6,
        "importPath": "maple.maple.util.ml_util",
        "description": "maple.maple.util.ml_util",
        "peekOfCode": "class IntLinearSchedule(LinearSchedule):\n    \"\"\"\n    Same as RampUpSchedule but round output to an int\n    \"\"\"\n    def get_value(self, t):\n        return int(super().get_value(t))\nclass PiecewiseLinearSchedule(ScalarSchedule):\n    \"\"\"\n    Given a list of (x, t) value-time pairs, return value x at time t,\n    and linearly interpolate between the two",
        "detail": "maple.maple.util.ml_util",
        "documentation": {}
    },
    {
        "label": "PiecewiseLinearSchedule",
        "kind": 6,
        "importPath": "maple.maple.util.ml_util",
        "description": "maple.maple.util.ml_util",
        "peekOfCode": "class PiecewiseLinearSchedule(ScalarSchedule):\n    \"\"\"\n    Given a list of (x, t) value-time pairs, return value x at time t,\n    and linearly interpolate between the two\n    \"\"\"\n    def __init__(\n            self,\n            x_values,\n            y_values,\n    ):",
        "detail": "maple.maple.util.ml_util",
        "documentation": {}
    },
    {
        "label": "IntPiecewiseLinearSchedule",
        "kind": 6,
        "importPath": "maple.maple.util.ml_util",
        "description": "maple.maple.util.ml_util",
        "peekOfCode": "class IntPiecewiseLinearSchedule(PiecewiseLinearSchedule):\n    def get_value(self, t):\n        return int(super().get_value(t))\ndef none_to_infty(bounds):\n    if bounds is None:\n        bounds = -math.inf, math.inf\n    lb, ub = bounds\n    if lb is None:\n        lb = -math.inf\n    if ub is None:",
        "detail": "maple.maple.util.ml_util",
        "documentation": {}
    },
    {
        "label": "none_to_infty",
        "kind": 2,
        "importPath": "maple.maple.util.ml_util",
        "description": "maple.maple.util.ml_util",
        "peekOfCode": "def none_to_infty(bounds):\n    if bounds is None:\n        bounds = -math.inf, math.inf\n    lb, ub = bounds\n    if lb is None:\n        lb = -math.inf\n    if ub is None:\n        ub = math.inf\n    return lb, ub",
        "detail": "maple.maple.util.ml_util",
        "documentation": {}
    },
    {
        "label": "create_sbatch_script",
        "kind": 2,
        "importPath": "maple.maple.util.slurm_util",
        "description": "maple.maple.util.slurm_util",
        "peekOfCode": "def create_sbatch_script(args, use_variants=True):\n    # Create a new directory path if it doesn't exist and create a new filename that we will write to\n    exp_dir = args.exp_dir\n    sbatch_dir = os.path.join(exp_dir, \"sbatch\")\n    new_sbatch_fpath = os.path.join(sbatch_dir, \"{}.sbatch\".format(args.job_name))\n    if not os.path.isdir(sbatch_dir):\n        os.mkdir(sbatch_dir)\n    if use_variants:\n        base_variant = os.path.join(exp_dir, \"variants\", args.env, \"base.json\")\n        variant_update = os.path.join(exp_dir, \"variants\", args.env, \"{}.json\".format(args.config))",
        "detail": "maple.maple.util.slurm_util",
        "documentation": {}
    },
    {
        "label": "IntIdDict",
        "kind": 6,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "class IntIdDict(collections.defaultdict):\n    \"\"\"\n    Automatically assign int IDs to hashable objects.\n    Usage:\n    ```\n    id_map = IntIdDict()\n    print(id_map['a'])\n    print(id_map['b'])\n    print(id_map['c'])\n    print(id_map['a'])",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "ConditionTimer",
        "kind": 6,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "class ConditionTimer(object):\n    \"\"\"\n    A timer that goes off after the a fixed time period.\n    The catch: you need to poll it and provide it the time!\n    Usage:\n    ```\n    timer = PollTimer(100)  # next check will be true at 100\n    timer.check(90)  # False\n    timer.check(110) # True. Next check will go off at 110 + 100 = 210\n    timer.check(205) # False",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "_Logger",
        "kind": 6,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "class _Logger(object):\n    def __init__(self):\n        self.n_chars = 0\n        self.lines = []\n    def print_over(self, *strings):\n        \"\"\"\n        Remove anything printed in the last printover call. Then print `string`\n        \"\"\"\n        string = string_tuple_to_string(strings)\n        sys.stdout.write(\"\\r\" * self.n_chars)",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "identity",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def identity(x):\n    return x\ndef clip_magnitude(value, magnitude):\n    \"\"\"\n    Clip the magnitude of value to be within some value.\n    :param value:\n    :param magnitude:\n    :return:\n    \"\"\"\n    return min(max(value, -magnitude), magnitude)",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "clip_magnitude",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def clip_magnitude(value, magnitude):\n    \"\"\"\n    Clip the magnitude of value to be within some value.\n    :param value:\n    :param magnitude:\n    :return:\n    \"\"\"\n    return min(max(value, -magnitude), magnitude)\ndef is_numeric(x):\n    return not isinstance(x, bool) and (",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "is_numeric",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def is_numeric(x):\n    return not isinstance(x, bool) and (\n        isinstance(x, int) or isinstance(x, float)\n    )\n\"\"\"\nDictionary methods\n\"\"\"\ndef dot_map_dict_to_nested_dict(dot_map_dict):\n    \"\"\"\n    Convert something like",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "dot_map_dict_to_nested_dict",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def dot_map_dict_to_nested_dict(dot_map_dict):\n    \"\"\"\n    Convert something like\n    ```\n    {\n        'one.two.three.four': 4,\n        'one.six.seven.eight': None,\n        'five.nine.ten': 10,\n        'five.zero': 'foo',\n    }",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "nested_dict_to_dot_map_dict",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def nested_dict_to_dot_map_dict(d, parent_key=''):\n    \"\"\"\n    Convert a recursive dictionary into a flat, dot-map dictionary.\n    :param d: e.g. {'a': {'b': 2, 'c': 3}}\n    :param parent_key: Used for recursion\n    :return: e.g. {'a.b': 2, 'a.c': 3}\n    \"\"\"\n    items = []\n    for k, v in d.items():\n        new_key = parent_key + \".\" + k if parent_key else k",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "merge_recursive_dicts",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def merge_recursive_dicts(a, b, path=None,\n                          ignore_duplicate_keys_in_second_dict=False):\n    \"\"\"\n    Merge two dicts that may have nested dicts.\n    \"\"\"\n    if path is None: path = []\n    for key in b:\n        if key in a:\n            if isinstance(a[key], dict) and isinstance(b[key], dict):\n                merge_recursive_dicts(a[key], b[key], path + [str(key)],",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "dict_of_list__to__list_of_dicts",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def dict_of_list__to__list_of_dicts(dict, n_items):\n    \"\"\"\n    ```\n    x = {'foo': [3, 4, 5], 'bar': [1, 2, 3]}\n    ppp.dict_of_list__to__list_of_dicts(x, 3)\n    # Output:\n    # [\n    #     {'foo': 3, 'bar': 1},\n    #     {'foo': 4, 'bar': 2},\n    #     {'foo': 5, 'bar': 3},",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "list_of_dicts__to__dict_of_lists",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def list_of_dicts__to__dict_of_lists(lst):\n    \"\"\"\n    ```\n    x = [\n        {'foo': 3, 'bar': 1},\n        {'foo': 4, 'bar': 2},\n        {'foo': 5, 'bar': 3},\n    ]\n    ppp.list_of_dicts__to__dict_of_lists(x)\n    # Output:",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "safe_json",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def safe_json(data):\n    if data is None:\n        return True\n    elif isinstance(data, (bool, int, float)):\n        return True\n    elif isinstance(data, (tuple, list)):\n        return all(safe_json(x) for x in data)\n    elif isinstance(data, dict):\n        return all(isinstance(k, str) and safe_json(v) for k, v in data.items())\n    return False",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "dict_to_safe_json",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def dict_to_safe_json(d, sort=False):\n    \"\"\"\n    Convert each value in the dictionary into a JSON'able primitive.\n    :param d:\n    :return:\n    \"\"\"\n    if isinstance(d, collections.OrderedDict):\n        new_d = collections.OrderedDict()\n    else:\n        new_d = {}",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "recursive_items",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def recursive_items(dictionary):\n    \"\"\"\n    Get all (key, item) recursively in a potentially recursive dictionary.\n    Usage:\n    ```\n    x = {\n        'foo' : {\n            'bar' : 5\n        }\n    }",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "map_recursive",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def map_recursive(fctn, x_or_iterable):\n    \"\"\"\n    Apply `fctn` to each element in x_or_iterable.\n    This is a generalization of the map function since this will work\n    recursively for iterables.\n    :param fctn: Function from element of iterable to something.\n    :param x_or_iterable: An element or an Iterable of an element.\n    :return: The same (potentially recursive) iterable but with\n    all the elements transformed by fctn.\n    \"\"\"",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "filter_recursive",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def filter_recursive(x_or_iterable):\n    \"\"\"\n    Filter out elements that are Falsy (where bool(x) is False) from\n    potentially recursive lists.\n    :param x_or_iterable: An element or a list.\n    :return: If x_or_iterable is not an Iterable, then return x_or_iterable.\n    Otherwise, return a filtered version of x_or_iterable.\n    \"\"\"\n    if isinstance(x_or_iterable, list):\n        new_items = []",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "batch",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def batch(iterable, n=1):\n    \"\"\"\n    Split an interable into batches of size `n`. If `n` does not evenly divide\n    `iterable`, the last slice will be smaller.\n    https://stackoverflow.com/questions/8290397/how-to-split-an-iterable-in-constant-size-chunks\n    Usage:\n    ```\n        for i in batch(range(0,10), 3):\n            print i\n        [0,1,2]",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "takespread",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def takespread(sequence, num):\n    \"\"\"\n    Get `num` elements from the sequence that are as spread out as possible.\n    https://stackoverflow.com/questions/9873626/choose-m-evenly-spaced-elements-from-a-sequence-of-length-n\n    :param sequence:\n    :param num:\n    :return:\n    \"\"\"\n    length = float(len(sequence))\n    for i in range(num):",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "string_tuple_to_string",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def string_tuple_to_string(strings):\n    if len(strings) == 0:\n        string = \"\"\n    elif len(strings) == 1:\n        string = strings[0]\n    else:\n        string = \" \".join([str(s) for s in strings])\n    return string\nclass _Logger(object):\n    def __init__(self):",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "find_key_recursive",
        "kind": 2,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "def find_key_recursive(obj, key):\n    if key in obj:\n        return obj[key]\n    for k, v in obj.items():\n        if isinstance(v, dict):\n            result = find_key_recursive(v, key)\n            if result is not None:\n                return result",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "line_logger",
        "kind": 5,
        "importPath": "maple.maple.pythonplusplus",
        "description": "maple.maple.pythonplusplus",
        "peekOfCode": "line_logger = _Logger()\ndef find_key_recursive(obj, key):\n    if key in obj:\n        return obj[key]\n    for k, v in obj.items():\n        if isinstance(v, dict):\n            result = find_key_recursive(v, key)\n            if result is not None:\n                return result",
        "detail": "maple.maple.pythonplusplus",
        "documentation": {}
    },
    {
        "label": "process_variant",
        "kind": 2,
        "importPath": "maple.scripts.eval",
        "description": "maple.scripts.eval",
        "peekOfCode": "def process_variant(eval_variant):\n    ckpt_path = eval_variant['ckpt_path']\n    json_path = osp.join(LOCAL_LOG_DIR, ckpt_path, 'variant.json')\n    with open(json_path) as f:\n        ckpt_variant = json.load(f)\n    deep_update(ckpt_variant, eval_variant)\n    variant = copy.deepcopy(ckpt_variant)\n    if args.debug:\n        mpl = variant['algorithm_kwargs']['max_path_length']\n        variant['algorithm_kwargs']['num_eval_steps_per_epoch'] = mpl * 3",
        "detail": "maple.scripts.eval",
        "documentation": {}
    },
    {
        "label": "deep_update",
        "kind": 2,
        "importPath": "maple.scripts.eval",
        "description": "maple.scripts.eval",
        "peekOfCode": "def deep_update(source, overrides):\n    '''\n    Update a nested dictionary or similar mapping.\n    Modify ``source`` in place.\n    Copied from: https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth\n    '''\n    for key, value in overrides.items():\n        if isinstance(value, collections.Mapping) and value:\n            returned = deep_update(source.get(key, {}), value)\n            source[key] = returned",
        "detail": "maple.scripts.eval",
        "documentation": {}
    },
    {
        "label": "base_variant",
        "kind": 5,
        "importPath": "maple.scripts.eval",
        "description": "maple.scripts.eval",
        "peekOfCode": "base_variant = dict(\n    algorithm_kwargs=dict(\n        eval_only=True,\n        num_epochs=5000,\n        eval_epoch_freq=100,\n    ),\n    replay_buffer_size=int(1E2),\n    vis_expl=False,\n    dump_video_kwargs=dict(\n        rows=1,",
        "detail": "maple.scripts.eval",
        "documentation": {}
    },
    {
        "label": "env_params",
        "kind": 5,
        "importPath": "maple.scripts.eval",
        "description": "maple.scripts.eval",
        "peekOfCode": "env_params = dict(\n    lift={\n        'ckpt_path': [\n            ### Add paths here ###\n        ],\n    },\n    door={\n        'ckpt_path': [\n            ### Add paths here ###\n        ],",
        "detail": "maple.scripts.eval",
        "documentation": {}
    },
    {
        "label": "process_variant",
        "kind": 2,
        "importPath": "maple.scripts.train",
        "description": "maple.scripts.train",
        "peekOfCode": "def process_variant(variant):\n    if args.debug:\n        variant['algorithm_kwargs']['num_epochs'] = 3\n        variant['algorithm_kwargs']['batch_size'] = 64\n        steps = 50\n        variant['algorithm_kwargs']['max_path_length'] = steps\n        variant['algorithm_kwargs']['num_eval_steps_per_epoch'] = steps\n        variant['algorithm_kwargs']['num_expl_steps_per_train_loop'] = steps\n        variant['algorithm_kwargs']['min_num_steps_before_training'] = steps\n        variant['algorithm_kwargs']['num_trains_per_train_loop'] = 50",
        "detail": "maple.scripts.train",
        "documentation": {}
    },
    {
        "label": "deep_update",
        "kind": 2,
        "importPath": "maple.scripts.train",
        "description": "maple.scripts.train",
        "peekOfCode": "def deep_update(source, overrides):\n    \"\"\"\n    Copied from https://stackoverflow.com/questions/3232943/update-value-of-a-nested-dictionary-of-varying-depth\n    \"\"\"\n    for key, value in overrides.items():\n        if isinstance(value, collections.Mapping) and value:\n            returned = deep_update(source.get(key, {}), value)\n            source[key] = returned\n        else:\n            source[key] = overrides[key]",
        "detail": "maple.scripts.train",
        "documentation": {}
    },
    {
        "label": "base_variant",
        "kind": 5,
        "importPath": "maple.scripts.train",
        "description": "maple.scripts.train",
        "peekOfCode": "base_variant = dict(\n    layer_size=256,\n    replay_buffer_size=int(1E6),\n    rollout_fn_kwargs=dict(\n        terminals_all_false=True,\n    ),\n    algorithm_kwargs=dict(\n        num_epochs=10000,\n        num_expl_steps_per_train_loop=3000,\n        num_eval_steps_per_epoch=3000,",
        "detail": "maple.scripts.train",
        "documentation": {}
    },
    {
        "label": "env_params",
        "kind": 5,
        "importPath": "maple.scripts.train",
        "description": "maple.scripts.train",
        "peekOfCode": "env_params = dict(\n    lift={\n        'env_variant.env_type': ['Lift'],\n    },\n    door={\n        'env_variant.env_type': ['Door'],\n        'env_variant.controller_type': ['OSC_POSITION'],\n        'env_variant.controller_config_update.position_limits': [[[-0.25, -0.25, 0.90], [0.05, 0.05, 1.20]]],\n        'env_variant.env_kwargs.skill_config.base_config.global_xyz_bounds': [\n            [[-0.25, -0.25, 0.90], [0.05, 0.05, 1.20]]],",
        "detail": "maple.scripts.train",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "extensions = [\n    'sphinx.ext.napoleon',\n    'sphinx_rtd_theme',\n    'sphinx_markdown_tables',\n    'sphinx.ext.mathjax',\n    'sphinx.ext.githubpages',\n    'sphinx.ext.autodoc',\n    'recommonmark', # use Sphinx-1.4 or newer\n    'nbsphinx',\n]",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "apidoc_module_dir",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "apidoc_module_dir = \"../robosuite\"\napidoc_output_dir = \"reference\"\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# source_parsers = {\n#     '.md': CommonMarkParser,\n# }\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\nsource_suffix = ['.rst', '.md', '.ipynb']",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "apidoc_output_dir",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "apidoc_output_dir = \"reference\"\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# source_parsers = {\n#     '.md': CommonMarkParser,\n# }\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\nsource_suffix = ['.rst', '.md', '.ipynb']\n# The master toctree document.",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "templates_path = ['_templates']\n# source_parsers = {\n#     '.md': CommonMarkParser,\n# }\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\nsource_suffix = ['.rst', '.md', '.ipynb']\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "source_suffix = ['.rst', '.md', '.ipynb']\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = u'robosuite'\ncopyright = u'Stanford Univeristy and The University of Texas at Austin 2020'\nauthor = u'Yuke Zhu, Josiah Wong, Jiren Zhu, Ajay Mandlekar, Roberto Martín-Martín'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "master_doc",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "master_doc = 'index'\n# General information about the project.\nproject = u'robosuite'\ncopyright = u'Stanford Univeristy and The University of Texas at Austin 2020'\nauthor = u'Yuke Zhu, Josiah Wong, Jiren Zhu, Ajay Mandlekar, Roberto Martín-Martín'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "project = u'robosuite'\ncopyright = u'Stanford Univeristy and The University of Texas at Austin 2020'\nauthor = u'Yuke Zhu, Josiah Wong, Jiren Zhu, Ajay Mandlekar, Roberto Martín-Martín'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = robosuite.__version__\n# The full version, including alpha/beta/rc tags.",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "copyright = u'Stanford Univeristy and The University of Texas at Austin 2020'\nauthor = u'Yuke Zhu, Josiah Wong, Jiren Zhu, Ajay Mandlekar, Roberto Martín-Martín'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = robosuite.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = robosuite.__version__",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "author",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "author = u'Yuke Zhu, Josiah Wong, Jiren Zhu, Ajay Mandlekar, Roberto Martín-Martín'\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = robosuite.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = robosuite.__version__\n# The language for content autogenerated by Sphinx. Refer to documentation",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "version = robosuite.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = robosuite.__version__\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# List of patterns, relative to source directory, that match files and",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "release = robosuite.__version__\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "language",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "language = None\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'sphinx_rtd_theme'",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "pygments_style",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "pygments_style = 'sphinx'\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'sphinx_rtd_theme'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "todo_include_todos",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "todo_include_todos = False\n# -- Options for HTML output ----------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'sphinx_rtd_theme'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "html_theme = 'sphinx_rtd_theme'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "html_static_path = ['_static']\nhtml_context = {\n    'css_files': [\n        '_static/theme_overrides.css',  # override wide tables in RTD theme\n    ],\n}\n# -- Options for HTMLHelp output ------------------------------------------\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'robosuitedoc'\n# -- Options for LaTeX output ---------------------------------------------",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_context",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "html_context = {\n    'css_files': [\n        '_static/theme_overrides.css',  # override wide tables in RTD theme\n    ],\n}\n# -- Options for HTMLHelp output ------------------------------------------\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'robosuitedoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "htmlhelp_basename",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "htmlhelp_basename = 'robosuitedoc'\n# -- Options for LaTeX output ---------------------------------------------\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_elements",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "latex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_documents",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "latex_documents = [\n    (master_doc, 'robosuite.tex', u'robosuite Documentation', author, 'manual'),\n]\n# -- Options for manual page output ---------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, 'robosuite', u'robosuite Documentation',\n     [author], 1)\n]",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "man_pages",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "man_pages = [\n    (master_doc, 'robosuite', u'robosuite Documentation',\n     [author], 1)\n]\n# -- Options for Texinfo output -------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, 'robosuite', u'robosuite Documentation',",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "texinfo_documents",
        "kind": 5,
        "importPath": "robosuite.docs.conf",
        "description": "robosuite.docs.conf",
        "peekOfCode": "texinfo_documents = [\n    (master_doc, 'robosuite', u'robosuite Documentation',\n     author, 'robosuite', 'ARISE',\n     'Miscellaneous'),\n]",
        "detail": "robosuite.docs.conf",
        "documentation": {}
    },
    {
        "label": "Interpolator",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.interpolators.base_interpolator",
        "description": "robosuite.robosuite.controllers.interpolators.base_interpolator",
        "peekOfCode": "class Interpolator(object, metaclass=abc.ABCMeta):\n    \"\"\"\n    General interpolator interface.\n    \"\"\"\n    @abc.abstractmethod\n    def get_interpolated_goal(self):\n        \"\"\"\n        Provides the next step in interpolation given the remaining steps.\n        Returns:\n            np.array: Next interpolated step",
        "detail": "robosuite.robosuite.controllers.interpolators.base_interpolator",
        "documentation": {}
    },
    {
        "label": "LinearInterpolator",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.interpolators.linear_interpolator",
        "description": "robosuite.robosuite.controllers.interpolators.linear_interpolator",
        "peekOfCode": "class LinearInterpolator(Interpolator):\n    \"\"\"\n    Simple class for implementing a linear interpolator.\n    Abstracted to interpolate n-dimensions\n    Args:\n        ndim (int): Number of dimensions to interpolate\n        controller_freq (float): Frequency (Hz) of the controller\n        policy_freq (float): Frequency (Hz) of the policy model\n        ramp_ratio (float): Percentage of interpolation timesteps across which we will interpolate to a goal position.\n            :Note: Num total interpolation steps will be equal to np.floor(ramp_ratio * controller_freq / policy_freq)",
        "detail": "robosuite.robosuite.controllers.interpolators.linear_interpolator",
        "documentation": {}
    },
    {
        "label": "Controller",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.base_controller",
        "description": "robosuite.robosuite.controllers.base_controller",
        "peekOfCode": "class Controller(object, metaclass=abc.ABCMeta):\n    \"\"\"\n    General controller interface.\n    Requires reference to mujoco sim object, eef_name of specific robot, relevant joint_indexes to that robot, and\n    whether an initial_joint is used for nullspace torques or not\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from\n        eef_name (str): Name of controlled robot arm's end effector (from robot XML)\n        joint_indexes (dict): Each key contains sim reference indexes to relevant robot joint information, namely:\n            :`'joints'`: list of indexes to relevant robot joints",
        "detail": "robosuite.robosuite.controllers.base_controller",
        "documentation": {}
    },
    {
        "label": "reset_controllers",
        "kind": 2,
        "importPath": "robosuite.robosuite.controllers.controller_factory",
        "description": "robosuite.robosuite.controllers.controller_factory",
        "peekOfCode": "def reset_controllers():\n    \"\"\"\n    Global function for doing one-time clears and restarting of any global controller-related\n    specifics before re-initializing each individual controller again\n    \"\"\"\n    global pybullet_server\n    # Disconnect and reconnect to pybullet server if it exists\n    if pybullet_server is not None:\n        pybullet_server.disconnect()\n        pybullet_server.connect()",
        "detail": "robosuite.robosuite.controllers.controller_factory",
        "documentation": {}
    },
    {
        "label": "get_pybullet_server",
        "kind": 2,
        "importPath": "robosuite.robosuite.controllers.controller_factory",
        "description": "robosuite.robosuite.controllers.controller_factory",
        "peekOfCode": "def get_pybullet_server():\n    \"\"\"\n    Getter to return reference to pybullet server module variable\n    Returns:\n        PyBulletServer: Server instance running PyBullet\n    \"\"\"\n    global pybullet_server\n    return pybullet_server\ndef load_controller_config(custom_fpath=None, default_controller=None):\n    \"\"\"",
        "detail": "robosuite.robosuite.controllers.controller_factory",
        "documentation": {}
    },
    {
        "label": "load_controller_config",
        "kind": 2,
        "importPath": "robosuite.robosuite.controllers.controller_factory",
        "description": "robosuite.robosuite.controllers.controller_factory",
        "peekOfCode": "def load_controller_config(custom_fpath=None, default_controller=None):\n    \"\"\"\n    Utility function that loads the desired controller and returns the loaded configuration as a dict\n    If @default_controller is specified, any value inputted to @custom_fpath is overridden and the default controller\n    configuration is automatically loaded. See specific arg description below for available default controllers.\n    Args:\n        custom_fpath (str): Absolute filepath to the custom controller configuration .json file to be loaded\n        default_controller (str): If specified, overrides @custom_fpath and loads a default configuration file for the\n            specified controller.\n            Choices are: {\"JOINT_POSITION\", \"JOINT_TORQUE\", \"JOINT_VELOCITY\", \"OSC_POSITION\", \"OSC_POSE\", \"IK_POSE\"}",
        "detail": "robosuite.robosuite.controllers.controller_factory",
        "documentation": {}
    },
    {
        "label": "controller_factory",
        "kind": 2,
        "importPath": "robosuite.robosuite.controllers.controller_factory",
        "description": "robosuite.robosuite.controllers.controller_factory",
        "peekOfCode": "def controller_factory(name, params):\n    \"\"\"\n    Generator for controllers\n    Creates a Controller instance with the provided @name and relevant @params.\n    Args:\n        name (str): the name of the controller. Must be one of: {JOINT_POSITION, JOINT_TORQUE, JOINT_VELOCITY,\n            OSC_POSITION, OSC_POSE, IK_POSE}\n        params (dict): dict containing the relevant params to pass to the controller\n        sim (MjSim): Mujoco sim reference to pass to the controller\n    Returns:",
        "detail": "robosuite.robosuite.controllers.controller_factory",
        "documentation": {}
    },
    {
        "label": "pybullet_server",
        "kind": 5,
        "importPath": "robosuite.robosuite.controllers.controller_factory",
        "description": "robosuite.robosuite.controllers.controller_factory",
        "peekOfCode": "pybullet_server = None\ndef reset_controllers():\n    \"\"\"\n    Global function for doing one-time clears and restarting of any global controller-related\n    specifics before re-initializing each individual controller again\n    \"\"\"\n    global pybullet_server\n    # Disconnect and reconnect to pybullet server if it exists\n    if pybullet_server is not None:\n        pybullet_server.disconnect()",
        "detail": "robosuite.robosuite.controllers.controller_factory",
        "documentation": {}
    },
    {
        "label": "PyBulletServer",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.ik",
        "description": "robosuite.robosuite.controllers.ik",
        "peekOfCode": "class PyBulletServer(object):\n    \"\"\"\n    Helper class to encapsulate an alias for a single pybullet server\n    \"\"\"\n    def __init__(self):\n        # Attributes\n        self.server_id = None\n        self.is_active = False\n        # Bodies: Dict of <bullet_robot_id : robot_name> active in pybullet simulation\n        self.bodies = {}",
        "detail": "robosuite.robosuite.controllers.ik",
        "documentation": {}
    },
    {
        "label": "InverseKinematicsController",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.ik",
        "description": "robosuite.robosuite.controllers.ik",
        "peekOfCode": "class InverseKinematicsController(JointVelocityController):\n    \"\"\"\n    Controller for controlling robot arm via inverse kinematics. Allows position and orientation control of the\n    robot's end effector.\n    Inverse kinematics solving is handled by pybullet.\n    NOTE: Control input actions are assumed to be relative to the current position / orientation of the end effector\n    and are taken as the array (x_dpos, y_dpos, z_dpos, x_rot, y_rot, z_rot).\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from\n        eef_name (str): Name of controlled robot arm's end effector (from robot XML)",
        "detail": "robosuite.robosuite.controllers.ik",
        "documentation": {}
    },
    {
        "label": "SUPPORTED_IK_ROBOTS",
        "kind": 5,
        "importPath": "robosuite.robosuite.controllers.ik",
        "description": "robosuite.robosuite.controllers.ik",
        "peekOfCode": "SUPPORTED_IK_ROBOTS = {\"Baxter\", \"Sawyer\", \"Panda\"}\nclass PyBulletServer(object):\n    \"\"\"\n    Helper class to encapsulate an alias for a single pybullet server\n    \"\"\"\n    def __init__(self):\n        # Attributes\n        self.server_id = None\n        self.is_active = False\n        # Bodies: Dict of <bullet_robot_id : robot_name> active in pybullet simulation",
        "detail": "robosuite.robosuite.controllers.ik",
        "documentation": {}
    },
    {
        "label": "JointPositionController",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.joint_pos",
        "description": "robosuite.robosuite.controllers.joint_pos",
        "peekOfCode": "class JointPositionController(Controller):\n    \"\"\"\n    Controller for controlling robot arm via impedance control. Allows position control of the robot's joints.\n    NOTE: Control input actions assumed to be taken relative to the current joint positions. A given action to this\n    controller is assumed to be of the form: (dpos_j0, dpos_j1, ... , dpos_jn-1) for an n-joint robot\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from\n        eef_name (str): Name of controlled robot arm's end effector (from robot XML)\n        joint_indexes (dict): Each key contains sim reference indexes to relevant robot joint information, namely:\n            :`'joints'`: list of indexes to relevant robot joints",
        "detail": "robosuite.robosuite.controllers.joint_pos",
        "documentation": {}
    },
    {
        "label": "IMPEDANCE_MODES",
        "kind": 5,
        "importPath": "robosuite.robosuite.controllers.joint_pos",
        "description": "robosuite.robosuite.controllers.joint_pos",
        "peekOfCode": "IMPEDANCE_MODES = {\"fixed\", \"variable\", \"variable_kp\"}\nclass JointPositionController(Controller):\n    \"\"\"\n    Controller for controlling robot arm via impedance control. Allows position control of the robot's joints.\n    NOTE: Control input actions assumed to be taken relative to the current joint positions. A given action to this\n    controller is assumed to be of the form: (dpos_j0, dpos_j1, ... , dpos_jn-1) for an n-joint robot\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from\n        eef_name (str): Name of controlled robot arm's end effector (from robot XML)\n        joint_indexes (dict): Each key contains sim reference indexes to relevant robot joint information, namely:",
        "detail": "robosuite.robosuite.controllers.joint_pos",
        "documentation": {}
    },
    {
        "label": "JointTorqueController",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.joint_tor",
        "description": "robosuite.robosuite.controllers.joint_tor",
        "peekOfCode": "class JointTorqueController(Controller):\n    \"\"\"\n    Controller for controlling the robot arm's joint torques. As the actuators at the mujoco sim level are already\n    torque actuators, this \"controller\" usually simply \"passes through\" desired torques, though it also includes the\n    typical input / output scaling and clipping, as well as interpolator features seen in other controllers classes\n    as well\n    NOTE: Control input actions assumed to be taken as absolute joint torques. A given action to this\n    controller is assumed to be of the form: (torq_j0, torq_j1, ... , torq_jn-1) for an n-joint robot\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from",
        "detail": "robosuite.robosuite.controllers.joint_tor",
        "documentation": {}
    },
    {
        "label": "JointVelocityController",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.joint_vel",
        "description": "robosuite.robosuite.controllers.joint_vel",
        "peekOfCode": "class JointVelocityController(Controller):\n    \"\"\"\n    Controller for controlling the robot arm's joint velocities. This is simply a P controller with desired torques\n    (pre gravity compensation) taken to be proportional to the velocity error of the robot joints.\n    NOTE: Control input actions assumed to be taken as absolute joint velocities. A given action to this\n    controller is assumed to be of the form: (vel_j0, vel_j1, ... , vel_jn-1) for an n-joint robot\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from\n        eef_name (str): Name of controlled robot arm's end effector (from robot XML)\n        joint_indexes (dict): Each key contains sim reference indexes to relevant robot joint information, namely:",
        "detail": "robosuite.robosuite.controllers.joint_vel",
        "documentation": {}
    },
    {
        "label": "OperationalSpaceController",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.osc",
        "description": "robosuite.robosuite.controllers.osc",
        "peekOfCode": "class OperationalSpaceController(Controller):\n    \"\"\"\n    Controller for controlling robot arm via operational space control. Allows position and / or orientation control\n    of the robot's end effector. For detailed information as to the mathematical foundation for this controller, please\n    reference http://khatib.stanford.edu/publications/pdfs/Khatib_1987_RA.pdf\n    NOTE: Control input actions can either be taken to be relative to the current position / orientation of the\n    end effector or absolute values. In either case, a given action to this controller is assumed to be of the form:\n    (x, y, z, ax, ay, az) if controlling pos and ori or simply (x, y, z) if only controlling pos\n    Args:\n        sim (MjSim): Simulator instance this controller will pull robot state updates from",
        "detail": "robosuite.robosuite.controllers.osc",
        "documentation": {}
    },
    {
        "label": "IMPEDANCE_MODES",
        "kind": 5,
        "importPath": "robosuite.robosuite.controllers.osc",
        "description": "robosuite.robosuite.controllers.osc",
        "peekOfCode": "IMPEDANCE_MODES = {\"fixed\", \"variable\", \"variable_kp\"}\n# TODO: Maybe better naming scheme to differentiate between input / output min / max and pos/ori limits, etc.\nclass OperationalSpaceController(Controller):\n    \"\"\"\n    Controller for controlling robot arm via operational space control. Allows position and / or orientation control\n    of the robot's end effector. For detailed information as to the mathematical foundation for this controller, please\n    reference http://khatib.stanford.edu/publications/pdfs/Khatib_1987_RA.pdf\n    NOTE: Control input actions can either be taken to be relative to the current position / orientation of the\n    end effector or absolute values. In either case, a given action to this controller is assumed to be of the form:\n    (x, y, z, ax, ay, az) if controlling pos and ori or simply (x, y, z) if only controlling pos",
        "detail": "robosuite.robosuite.controllers.osc",
        "documentation": {}
    },
    {
        "label": "SkillController",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.skill_controller",
        "description": "robosuite.robosuite.controllers.skill_controller",
        "peekOfCode": "class SkillController:\n    SKILL_NAMES = [\n        'atomic',\n        'reach_osc', 'reach',\n        'grasp',\n        'push',\n        'open', 'close',\n    ]\n    def __init__(\n            self,",
        "detail": "robosuite.robosuite.controllers.skill_controller",
        "documentation": {}
    },
    {
        "label": "BaseSkill",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.skills",
        "description": "robosuite.robosuite.controllers.skills",
        "peekOfCode": "class BaseSkill:\n    def __init__(\n            self,\n            skill_type,\n            ### common settings ###\n            global_xyz_bounds=np.array([\n                [-0.30, -0.30, 0.80],\n                [0.15, 0.30, 0.90]\n            ]),\n            delta_xyz_scale=np.array([0.15, 0.15, 0.05]),",
        "detail": "robosuite.robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "AtomicSkill",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.skills",
        "description": "robosuite.robosuite.controllers.skills",
        "peekOfCode": "class AtomicSkill(BaseSkill):\n    def __init__(\n            self,\n            skill_type,\n            use_ori_params=True,\n            use_gripper_params=True,\n            **config\n    ):\n        super().__init__(\n            skill_type,",
        "detail": "robosuite.robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "GripperSkill",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.skills",
        "description": "robosuite.robosuite.controllers.skills",
        "peekOfCode": "class GripperSkill(BaseSkill):\n    def __init__(\n            self,\n            skill_type,\n            max_ac_calls=4,\n            **config\n    ):\n        super().__init__(\n            skill_type,\n            max_ac_calls=max_ac_calls,",
        "detail": "robosuite.robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "ReachOSCSkill",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.skills",
        "description": "robosuite.robosuite.controllers.skills",
        "peekOfCode": "class ReachOSCSkill(BaseSkill):\n    def __init__(\n            self,\n            skill_type,\n            use_gripper_params=True,\n            use_ori_params=False,\n            max_ac_calls=15,\n            use_delta=False, # only applicable for skill_type=r1\n            **config\n    ):",
        "detail": "robosuite.robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "ReachSkill",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.skills",
        "description": "robosuite.robosuite.controllers.skills",
        "peekOfCode": "class ReachSkill(BaseSkill):\n    STATES = ['INIT', 'LIFTED', 'HOVERING', 'REACHED']\n    def __init__(\n            self,\n            skill_type,\n            use_gripper_params=True,\n            use_ori_params=False,\n            max_ac_calls=15,\n            **config\n    ):",
        "detail": "robosuite.robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "GraspSkill",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.skills",
        "description": "robosuite.robosuite.controllers.skills",
        "peekOfCode": "class GraspSkill(BaseSkill):\n    STATES = ['INIT', 'LIFTED', 'HOVERING', 'REACHED', 'GRASPED']\n    def __init__(\n            self,\n            skill_type,\n            use_ori_params=True,\n            max_ac_calls=15,\n            num_reach_steps=1,\n            num_grasp_steps=1,\n            **config",
        "detail": "robosuite.robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "PushSkill",
        "kind": 6,
        "importPath": "robosuite.robosuite.controllers.skills",
        "description": "robosuite.robosuite.controllers.skills",
        "peekOfCode": "class PushSkill(BaseSkill):\n    STATES = ['INIT', 'LIFTED', 'HOVERING', 'REACHED', 'PUSHED']\n    def __init__(\n            self,\n            skill_type,\n            max_ac_calls=20,\n            use_ori_params=True,\n            **config\n    ):\n        super().__init__(",
        "detail": "robosuite.robosuite.controllers.skills",
        "documentation": {}
    },
    {
        "label": "collect_random_trajectory",
        "kind": 2,
        "importPath": "robosuite.robosuite.demos.demo_collect_and_playback_data",
        "description": "robosuite.robosuite.demos.demo_collect_and_playback_data",
        "peekOfCode": "def collect_random_trajectory(env, timesteps=1000):\n    \"\"\"Run a random policy to collect trajectories.\n    The rollout trajectory is saved to files in npz format.\n    Modify the DataCollectionWrapper wrapper to add new fields or change data formats.\n    Args:\n        env (MujocoEnv): environment instance to collect trajectories from\n        timesteps(int): how many environment timesteps to run for a given trajectory\n    \"\"\"\n    env.reset()\n    dof = env.action_dim",
        "detail": "robosuite.robosuite.demos.demo_collect_and_playback_data",
        "documentation": {}
    },
    {
        "label": "playback_trajectory",
        "kind": 2,
        "importPath": "robosuite.robosuite.demos.demo_collect_and_playback_data",
        "description": "robosuite.robosuite.demos.demo_collect_and_playback_data",
        "peekOfCode": "def playback_trajectory(env, ep_dir):\n    \"\"\"Playback data from an episode.\n    Args:\n        env (MujocoEnv): environment instance to playback trajectory in\n        ep_dir (str): The path to the directory containing data for an episode.\n    \"\"\"\n    # first reload the model from the xml\n    xml_path = os.path.join(ep_dir, \"model.xml\")\n    with open(xml_path, \"r\") as f:\n        env.reset_from_xml_string(f.read())",
        "detail": "robosuite.robosuite.demos.demo_collect_and_playback_data",
        "documentation": {}
    },
    {
        "label": "macros.USING_INSTANCE_RANDOMIZATION",
        "kind": 5,
        "importPath": "robosuite.robosuite.demos.demo_domain_randomization",
        "description": "robosuite.robosuite.demos.demo_domain_randomization",
        "peekOfCode": "macros.USING_INSTANCE_RANDOMIZATION = True\nif __name__ == \"__main__\":\n    # Create dict to hold options that will be passed to env creation call\n    options = {}\n    # print welcome info\n    print(\"Welcome to robosuite v{}!\".format(suite.__version__))\n    print(suite.__logo__)\n    # Choose environment and add it to options\n    options[\"env_name\"] = choose_environment()\n    # If a multi-arm environment has been chosen, choose configuration and appropriate robot(s)",
        "detail": "robosuite.robosuite.demos.demo_domain_randomization",
        "documentation": {}
    },
    {
        "label": "macros.IMAGE_CONVENTION",
        "kind": 5,
        "importPath": "robosuite.robosuite.demos.demo_video_recording",
        "description": "robosuite.robosuite.demos.demo_video_recording",
        "peekOfCode": "macros.IMAGE_CONVENTION = \"opencv\"\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--environment\", type=str, default=\"Stack\")\n    parser.add_argument(\"--robots\", nargs=\"+\", type=str, default=\"Panda\", help=\"Which robot(s) to use in the env\")\n    parser.add_argument(\"--camera\", type=str, default=\"agentview\", help=\"Name of camera to render\")\n    parser.add_argument(\"--video_path\", type=str, default=\"video.mp4\")\n    parser.add_argument(\"--timesteps\", type=int, default=500)\n    parser.add_argument(\"--height\", type=int, default=512)\n    parser.add_argument(\"--width\", type=int, default=512)",
        "detail": "robosuite.robosuite.demos.demo_video_recording",
        "documentation": {}
    },
    {
        "label": "Device",
        "kind": 6,
        "importPath": "robosuite.robosuite.devices.device",
        "description": "robosuite.robosuite.devices.device",
        "peekOfCode": "class Device(metaclass=abc.ABCMeta):\n    \"\"\"\n    Base class for all robot controllers.\n    Defines basic interface for all controllers to adhere to.\n    \"\"\"\n    @abc.abstractmethod\n    def start_control(self):\n        \"\"\"\n        Method that should be called externally before controller can \n        start receiving commands. ",
        "detail": "robosuite.robosuite.devices.device",
        "documentation": {}
    },
    {
        "label": "Keyboard",
        "kind": 6,
        "importPath": "robosuite.robosuite.devices.keyboard",
        "description": "robosuite.robosuite.devices.keyboard",
        "peekOfCode": "class Keyboard(Device):\n    \"\"\"\n    A minimalistic driver class for a Keyboard.\n    Args:\n        pos_sensitivity (float): Magnitude of input position command scaling\n        rot_sensitivity (float): Magnitude of scale input rotation commands scaling\n    \"\"\"\n    def __init__(self,\n                 pos_sensitivity=1.0,\n                 rot_sensitivity=1.0",
        "detail": "robosuite.robosuite.devices.keyboard",
        "documentation": {}
    },
    {
        "label": "SpaceMouse",
        "kind": 6,
        "importPath": "robosuite.robosuite.devices.spacemouse",
        "description": "robosuite.robosuite.devices.spacemouse",
        "peekOfCode": "class SpaceMouse(Device):\n    \"\"\"\n    A minimalistic driver class for SpaceMouse with HID library.\n    Note: Use hid.enumerate() to view all USB human interface devices (HID).\n    Make sure SpaceMouse is detected before running the script.\n    You can look up its vendor/product id from this method.\n    Args:\n        vendor_id (int): HID device vendor id\n        product_id (int): HID device product id\n        pos_sensitivity (float): Magnitude of input position command scaling",
        "detail": "robosuite.robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "to_int16",
        "kind": 2,
        "importPath": "robosuite.robosuite.devices.spacemouse",
        "description": "robosuite.robosuite.devices.spacemouse",
        "peekOfCode": "def to_int16(y1, y2):\n    \"\"\"\n    Convert two 8 bit bytes to a signed 16 bit integer.\n    Args:\n        y1 (int): 8-bit byte\n        y2 (int): 8-bit byte\n    Returns:\n        int: 16-bit integer\n    \"\"\"\n    x = (y1) | (y2 << 8)",
        "detail": "robosuite.robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "scale_to_control",
        "kind": 2,
        "importPath": "robosuite.robosuite.devices.spacemouse",
        "description": "robosuite.robosuite.devices.spacemouse",
        "peekOfCode": "def scale_to_control(x, axis_scale=350., min_v=-1.0, max_v=1.0):\n    \"\"\"\n    Normalize raw HID readings to target range.\n    Args:\n        x (int): Raw reading from HID\n        axis_scale (float): (Inverted) scaling factor for mapping raw input value\n        min_v (float): Minimum limit after scaling\n        max_v (float): Maximum limit after scaling\n    Returns:\n        float: Clipped, scaled input from HID",
        "detail": "robosuite.robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "robosuite.robosuite.devices.spacemouse",
        "description": "robosuite.robosuite.devices.spacemouse",
        "peekOfCode": "def convert(b1, b2):\n    \"\"\"\n    Converts SpaceMouse message to commands.\n    Args:\n        b1 (int): 8-bit byte\n        b2 (int): 8-bit byte\n    Returns:\n        float: Scaled value from Spacemouse message\n    \"\"\"\n    return scale_to_control(to_int16(b1, b2))",
        "detail": "robosuite.robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "AxisSpec",
        "kind": 5,
        "importPath": "robosuite.robosuite.devices.spacemouse",
        "description": "robosuite.robosuite.devices.spacemouse",
        "peekOfCode": "AxisSpec = namedtuple(\"AxisSpec\", [\"channel\", \"byte1\", \"byte2\", \"scale\"])\nSPACE_MOUSE_SPEC = {\n    \"x\": AxisSpec(channel=1, byte1=1, byte2=2, scale=1),\n    \"y\": AxisSpec(channel=1, byte1=3, byte2=4, scale=-1),\n    \"z\": AxisSpec(channel=1, byte1=5, byte2=6, scale=-1),\n    \"roll\": AxisSpec(channel=1, byte1=7, byte2=8, scale=-1),\n    \"pitch\": AxisSpec(channel=1, byte1=9, byte2=10, scale=-1),\n    \"yaw\": AxisSpec(channel=1, byte1=11, byte2=12, scale=1),\n}\ndef to_int16(y1, y2):",
        "detail": "robosuite.robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "SPACE_MOUSE_SPEC",
        "kind": 5,
        "importPath": "robosuite.robosuite.devices.spacemouse",
        "description": "robosuite.robosuite.devices.spacemouse",
        "peekOfCode": "SPACE_MOUSE_SPEC = {\n    \"x\": AxisSpec(channel=1, byte1=1, byte2=2, scale=1),\n    \"y\": AxisSpec(channel=1, byte1=3, byte2=4, scale=-1),\n    \"z\": AxisSpec(channel=1, byte1=5, byte2=6, scale=-1),\n    \"roll\": AxisSpec(channel=1, byte1=7, byte2=8, scale=-1),\n    \"pitch\": AxisSpec(channel=1, byte1=9, byte2=10, scale=-1),\n    \"yaw\": AxisSpec(channel=1, byte1=11, byte2=12, scale=1),\n}\ndef to_int16(y1, y2):\n    \"\"\"",
        "detail": "robosuite.robosuite.devices.spacemouse",
        "documentation": {}
    },
    {
        "label": "Cleanup",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.cleanup",
        "description": "robosuite.robosuite.environments.manipulation.cleanup",
        "peekOfCode": "class Cleanup(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the stacking task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.robosuite.environments.manipulation.cleanup",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CLEANUP_CONFIG",
        "kind": 5,
        "importPath": "robosuite.robosuite.environments.manipulation.cleanup",
        "description": "robosuite.robosuite.environments.manipulation.cleanup",
        "peekOfCode": "DEFAULT_CLEANUP_CONFIG = {\n    'use_pnp_rew': True,\n    'use_push_rew': True,\n    'rew_type': 'sum',\n    'num_pnp_objs': 1,\n    'num_push_objs': 1,\n    'shaped_push_rew': False,\n    'push_scale_fac': 5.0,\n}\nclass Cleanup(SingleArmEnv):",
        "detail": "robosuite.robosuite.environments.manipulation.cleanup",
        "documentation": {}
    },
    {
        "label": "Door",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.door",
        "description": "robosuite.robosuite.environments.manipulation.door",
        "peekOfCode": "class Door(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the door opening task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.robosuite.environments.manipulation.door",
        "documentation": {}
    },
    {
        "label": "Lift",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.lift",
        "description": "robosuite.robosuite.environments.manipulation.lift",
        "peekOfCode": "class Lift(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the lifting task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.robosuite.environments.manipulation.lift",
        "documentation": {}
    },
    {
        "label": "ManipulationEnv",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.manipulation_env",
        "description": "robosuite.robosuite.environments.manipulation.manipulation_env",
        "peekOfCode": "class ManipulationEnv(RobotEnv):\n    \"\"\"\n    Initializes a manipulation-specific robot environment in Mujoco.\n    Args:\n        robots: Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n        env_configuration (str): Specifies how to position the robot(s) within the environment. Default is \"default\",\n            which should be interpreted accordingly by any subclasses.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a\n            custom controller. Else, uses the default controller for this specific task. Should either be single",
        "detail": "robosuite.robosuite.environments.manipulation.manipulation_env",
        "documentation": {}
    },
    {
        "label": "NutAssembly",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "description": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "peekOfCode": "class NutAssembly(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the nut assembly task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "documentation": {}
    },
    {
        "label": "NutAssemblySingle",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "description": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "peekOfCode": "class NutAssemblySingle(NutAssembly):\n    \"\"\"\n    Easier version of task - place either one round nut or one square nut into its peg.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert \"single_object_mode\" not in kwargs, \"invalid set of arguments\"\n        super().__init__(single_object_mode=1, **kwargs)\nclass NutAssemblySquare(NutAssembly):\n    \"\"\"\n    Easier version of task - place one square nut into its peg.",
        "detail": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "documentation": {}
    },
    {
        "label": "NutAssemblySquare",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "description": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "peekOfCode": "class NutAssemblySquare(NutAssembly):\n    \"\"\"\n    Easier version of task - place one square nut into its peg.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"nut_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, nut_type=\"square\", **kwargs)\nclass NutAssemblyRound(NutAssembly):",
        "detail": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "documentation": {}
    },
    {
        "label": "NutAssemblyRound",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "description": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "peekOfCode": "class NutAssemblyRound(NutAssembly):\n    \"\"\"\n    Easier version of task - place one round nut into its peg.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"nut_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, nut_type=\"round\", **kwargs)\n    def _get_skill_info(self):",
        "detail": "robosuite.robosuite.environments.manipulation.nut_assembly",
        "documentation": {}
    },
    {
        "label": "PegInHole",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.peg_in_hole",
        "description": "robosuite.robosuite.environments.manipulation.peg_in_hole",
        "peekOfCode": "class PegInHole(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the stacking task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.robosuite.environments.manipulation.peg_in_hole",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PEG_IN_HOLE_CONFIG",
        "kind": 5,
        "importPath": "robosuite.robosuite.environments.manipulation.peg_in_hole",
        "description": "robosuite.robosuite.environments.manipulation.peg_in_hole",
        "peekOfCode": "DEFAULT_PEG_IN_HOLE_CONFIG = {\n    'large_hole': False,\n    'd_weight': 1,\n    't_weight': 5,\n    'cos_weight': 1,\n    'scale_by_cos': True,\n    'scale_by_d': True,\n    'cos_tanh_mult': 3.0,\n    'd_tanh_mult': 15.0,\n    't_tanh_mult': 7.5,",
        "detail": "robosuite.robosuite.environments.manipulation.peg_in_hole",
        "documentation": {}
    },
    {
        "label": "PickPlace",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.pick_place",
        "description": "robosuite.robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlace(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the pick place task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "PickPlaceSingle",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.pick_place",
        "description": "robosuite.robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlaceSingle(PickPlace):\n    \"\"\"\n    Easier version of task - place one object into its bin.\n    A new object is sampled on every reset.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert \"single_object_mode\" not in kwargs, \"invalid set of arguments\"\n        super().__init__(single_object_mode=1, **kwargs)\nclass PickPlaceMilk(PickPlace):\n    \"\"\"",
        "detail": "robosuite.robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "PickPlaceMilk",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.pick_place",
        "description": "robosuite.robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlaceMilk(PickPlace):\n    \"\"\"\n    Easier version of task - place one milk into its bin.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"object_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, object_type=\"milk\", **kwargs)\nclass PickPlaceBread(PickPlace):",
        "detail": "robosuite.robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "PickPlaceBread",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.pick_place",
        "description": "robosuite.robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlaceBread(PickPlace):\n    \"\"\"\n    Easier version of task - place one bread into its bin.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"object_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, object_type=\"bread\", **kwargs)\nclass PickPlaceCereal(PickPlace):",
        "detail": "robosuite.robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "PickPlaceCereal",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.pick_place",
        "description": "robosuite.robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlaceCereal(PickPlace):\n    \"\"\"\n    Easier version of task - place one cereal into its bin.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"object_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, object_type=\"cereal\", **kwargs)\nclass PickPlaceCan(PickPlace):",
        "detail": "robosuite.robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "PickPlaceCan",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.pick_place",
        "description": "robosuite.robosuite.environments.manipulation.pick_place",
        "peekOfCode": "class PickPlaceCan(PickPlace):\n    \"\"\"\n    Easier version of task - place one can into its bin.\n    \"\"\"\n    def __init__(self, **kwargs):\n        assert (\n                \"single_object_mode\" not in kwargs and \"object_type\" not in kwargs\n        ), \"invalid set of arguments\"\n        super().__init__(single_object_mode=2, object_type=\"can\", **kwargs)",
        "detail": "robosuite.robosuite.environments.manipulation.pick_place",
        "documentation": {}
    },
    {
        "label": "SingleArmEnv",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.single_arm_env",
        "description": "robosuite.robosuite.environments.manipulation.single_arm_env",
        "peekOfCode": "class SingleArmEnv(ManipulationEnv):\n    \"\"\"\n    A manipulation environment intended for a single robot arm.\n    \"\"\"\n    def _load_model(self):\n        \"\"\"\n        Verifies correct robot model is loaded\n        \"\"\"\n        super()._load_model()\n        # Verify the correct robot has been loaded",
        "detail": "robosuite.robosuite.environments.manipulation.single_arm_env",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.stack",
        "description": "robosuite.robosuite.environments.manipulation.stack",
        "peekOfCode": "class Stack(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the stacking task for a single robot arm.\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.robosuite.environments.manipulation.stack",
        "documentation": {}
    },
    {
        "label": "Wipe",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.manipulation.wipe",
        "description": "robosuite.robosuite.environments.manipulation.wipe",
        "peekOfCode": "class Wipe(SingleArmEnv):\n    \"\"\"\n    This class corresponds to the Wiping task for a single robot arm\n    Args:\n        robots (str or list of str): Specification for specific robot arm(s) to be instantiated within this env\n            (e.g: \"Sawyer\" would generate one arm; [\"Panda\", \"Panda\", \"Sawyer\"] would generate three robot arms)\n            Note: Must be a single single-arm robot!\n        env_configuration (str): Specifies how to position the robots within the environment (default is \"default\").\n            For most single arm environments, this argument has no impact on the robot setup.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a",
        "detail": "robosuite.robosuite.environments.manipulation.wipe",
        "documentation": {}
    },
    {
        "label": "DEFAULT_WIPE_CONFIG",
        "kind": 5,
        "importPath": "robosuite.robosuite.environments.manipulation.wipe",
        "description": "robosuite.robosuite.environments.manipulation.wipe",
        "peekOfCode": "DEFAULT_WIPE_CONFIG = {\n    # settings for reward\n    \"wipe_contact_reward\": 0.05,                    # reward for contacting something with the wiping tool\n    \"distance_multiplier\": 0.05,                     # multiplier for the dense reward inversely proportional to the mean location of the pegs to wipe\n    \"distance_th_multiplier\": 5.0,                  # multiplier in the tanh function for the aforementioned reward\n    \"task_complete_reward\": 1.5,\n    \"success_th\": 1.00,\n    \"excess_force_penalty_mul\": 0.01,\n    # settings for table top\n    \"table_full_size\": [0.5, 0.8, 0.05],            # Size of tabletop",
        "detail": "robosuite.robosuite.environments.manipulation.wipe",
        "documentation": {}
    },
    {
        "label": "EnvMeta",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.base",
        "description": "robosuite.robosuite.environments.base",
        "peekOfCode": "class EnvMeta(type):\n    \"\"\"Metaclass for registering environments\"\"\"\n    def __new__(meta, name, bases, class_dict):\n        cls = super().__new__(meta, name, bases, class_dict)\n        # List all environments that should not be registered here.\n        _unregistered_envs = [\"MujocoEnv\", \"RobotEnv\", \"ManipulationEnv\", \"SingleArmEnv\"]\n        if cls.__name__ not in _unregistered_envs:\n            register_env(cls)\n        return cls\nclass MujocoEnv(metaclass=EnvMeta):",
        "detail": "robosuite.robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "MujocoEnv",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.base",
        "description": "robosuite.robosuite.environments.base",
        "peekOfCode": "class MujocoEnv(metaclass=EnvMeta):\n    \"\"\"\n    Initializes a Mujoco Environment.\n    Args:\n        has_renderer (bool): If true, render the simulation state in\n            a viewer instead of headless mode.\n        has_offscreen_renderer (bool): True if using off-screen rendering.\n        render_camera (str): Name of camera to render if `has_renderer` is True. Setting this value to 'None'\n            will result in the default angle being applied, which is useful as it can be dragged / panned by\n            the user using the mouse",
        "detail": "robosuite.robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "register_env",
        "kind": 2,
        "importPath": "robosuite.robosuite.environments.base",
        "description": "robosuite.robosuite.environments.base",
        "peekOfCode": "def register_env(target_class):\n    REGISTERED_ENVS[target_class.__name__] = target_class\ndef make(env_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a robosuite environment.\n    This method attempts to mirror the equivalent functionality of gym.make in a somewhat sloppy way.\n    Args:\n        env_name (str): Name of the robosuite environment to initialize\n        *args: Additional arguments to pass to the specific environment class initializer\n        **kwargs: Additional arguments to pass to the specific environment class initializer",
        "detail": "robosuite.robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "robosuite.robosuite.environments.base",
        "description": "robosuite.robosuite.environments.base",
        "peekOfCode": "def make(env_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a robosuite environment.\n    This method attempts to mirror the equivalent functionality of gym.make in a somewhat sloppy way.\n    Args:\n        env_name (str): Name of the robosuite environment to initialize\n        *args: Additional arguments to pass to the specific environment class initializer\n        **kwargs: Additional arguments to pass to the specific environment class initializer\n    Returns:\n        MujocoEnv: Desired robosuite environment",
        "detail": "robosuite.robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "REGISTERED_ENVS",
        "kind": 5,
        "importPath": "robosuite.robosuite.environments.base",
        "description": "robosuite.robosuite.environments.base",
        "peekOfCode": "REGISTERED_ENVS = {}\ndef register_env(target_class):\n    REGISTERED_ENVS[target_class.__name__] = target_class\ndef make(env_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a robosuite environment.\n    This method attempts to mirror the equivalent functionality of gym.make in a somewhat sloppy way.\n    Args:\n        env_name (str): Name of the robosuite environment to initialize\n        *args: Additional arguments to pass to the specific environment class initializer",
        "detail": "robosuite.robosuite.environments.base",
        "documentation": {}
    },
    {
        "label": "RobotEnv",
        "kind": 6,
        "importPath": "robosuite.robosuite.environments.robot_env",
        "description": "robosuite.robosuite.environments.robot_env",
        "peekOfCode": "class RobotEnv(MujocoEnv):\n    \"\"\"\n    Initializes a robot environment in Mujoco.\n    Args:\n        robots: Specification for specific robot(s) to be instantiated within this env\n        env_configuration (str): Specifies how to position the robot(s) within the environment. Default is \"default\",\n            which should be interpreted accordingly by any subclasses.\n        controller_configs (str or list of dict): If set, contains relevant controller parameters for creating a\n            custom controller. Else, uses the default controller for this specific task. Should either be single\n            dict if same controller is to be used for all robots or else it should be a list of the same length as",
        "detail": "robosuite.robosuite.environments.robot_env",
        "documentation": {}
    },
    {
        "label": "Arena",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.arenas.arena",
        "description": "robosuite.robosuite.models.arenas.arena",
        "peekOfCode": "class Arena(MujocoXML):\n    \"\"\"Base arena class.\"\"\"\n    def __init__(self, fname):\n        super().__init__(fname)\n        # Get references to floor and bottom\n        self.bottom_pos = np.zeros(3)\n        self.floor = self.worldbody.find(\"./geom[@name='floor']\")\n        # Recolor all geoms\n        recolor_collision_geoms(root=self.worldbody, rgba=ENVIRONMENT_COLLISION_COLOR,\n                                exclude=lambda e: True if e.get(\"name\", None) == \"floor\" else False)",
        "detail": "robosuite.robosuite.models.arenas.arena",
        "documentation": {}
    },
    {
        "label": "BinsArena",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.arenas.bins_arena",
        "description": "robosuite.robosuite.models.arenas.bins_arena",
        "peekOfCode": "class BinsArena(Arena):\n    \"\"\"\n    Workspace that contains two bins placed side by side.\n    Args:\n        bin1_pos (3-tuple): (x,y,z) position to place bin1\n        table_full_size (3-tuple): (L,W,H) full dimensions of the table\n        table_friction (3-tuple): (sliding, torsional, rolling) friction parameters of the table\n    \"\"\"\n    def __init__(\n        self, bin1_pos=(0.1, -0.5, 0.8), table_full_size=(0.39, 0.49, 0.82), table_friction=(1, 0.005, 0.0001)",
        "detail": "robosuite.robosuite.models.arenas.bins_arena",
        "documentation": {}
    },
    {
        "label": "BlockArena",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.arenas.block_arena",
        "description": "robosuite.robosuite.models.arenas.block_arena",
        "peekOfCode": "class BlockArena(Arena):\n    \"\"\"\n    Workspace that contains an empty table.\n    Args:\n        table_full_size (3-tuple): (L,W,H) full dimensions of the table\n        table_friction (3-tuple): (sliding, torsional, rolling) friction parameters of the table\n        table_offset (3-tuple): (x,y,z) offset from center of arena when placing table.\n            Note that the z value sets the upper limit of the table\n        has_legs (bool): whether the table has legs or not\n        xml (str): xml file to load arena",
        "detail": "robosuite.robosuite.models.arenas.block_arena",
        "documentation": {}
    },
    {
        "label": "EmptyArena",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.arenas.empty_arena",
        "description": "robosuite.robosuite.models.arenas.empty_arena",
        "peekOfCode": "class EmptyArena(Arena):\n    \"\"\"Empty workspace.\"\"\"\n    def __init__(self):\n        super().__init__(xml_path_completion(\"arenas/empty_arena.xml\"))",
        "detail": "robosuite.robosuite.models.arenas.empty_arena",
        "documentation": {}
    },
    {
        "label": "PegsArena",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.arenas.pegs_arena",
        "description": "robosuite.robosuite.models.arenas.pegs_arena",
        "peekOfCode": "class PegsArena(TableArena):\n    \"\"\"\n    Workspace that contains a tabletop with two fixed pegs.\n    Args:\n        table_full_size (3-tuple): (L,W,H) full dimensions of the table\n        table_friction (3-tuple): (sliding, torsional, rolling) friction parameters of the table\n        table_offset (3-tuple): (x,y,z) offset from center of arena when placing table.\n            Note that the z value sets the upper limit of the table\n    \"\"\"\n    def __init__(",
        "detail": "robosuite.robosuite.models.arenas.pegs_arena",
        "documentation": {}
    },
    {
        "label": "TableArena",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.arenas.table_arena",
        "description": "robosuite.robosuite.models.arenas.table_arena",
        "peekOfCode": "class TableArena(Arena):\n    \"\"\"\n    Workspace that contains an empty table.\n    Args:\n        table_full_size (3-tuple): (L,W,H) full dimensions of the table\n        table_friction (3-tuple): (sliding, torsional, rolling) friction parameters of the table\n        table_offset (3-tuple): (x,y,z) offset from center of arena when placing table.\n            Note that the z value sets the upper limit of the table\n        has_legs (bool): whether the table has legs or not\n        xml (str): xml file to load arena",
        "detail": "robosuite.robosuite.models.arenas.table_arena",
        "documentation": {}
    },
    {
        "label": "WipeArena",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.arenas.wipe_arena",
        "description": "robosuite.robosuite.models.arenas.wipe_arena",
        "peekOfCode": "class WipeArena(TableArena):\n    \"\"\"\n    Workspace that contains an empty table with visual markers on its surface.\n    Args:\n        table_full_size (3-tuple): (L,W,H) full dimensions of the table\n        table_friction (3-tuple): (sliding, torsional, rolling) friction parameters of the table\n        table_offset (3-tuple): (x,y,z) offset from center of arena when placing table.\n            Note that the z value sets the upper limit of the table\n        coverage_factor (float): Fraction of table that will be sampled for dirt placement\n        num_markers (int): Number of dirt (peg) particles to generate in a path on the table",
        "detail": "robosuite.robosuite.models.arenas.wipe_arena",
        "documentation": {}
    },
    {
        "label": "gripper_factory",
        "kind": 2,
        "importPath": "robosuite.robosuite.models.grippers.gripper_factory",
        "description": "robosuite.robosuite.models.grippers.gripper_factory",
        "peekOfCode": "def gripper_factory(name, idn=0):\n    \"\"\"\n    Generator for grippers\n    Creates a GripperModel instance with the provided name.\n    Args:\n        name (None or str): the name of the gripper class\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    Returns:\n        GripperModel: requested gripper instance\n    Raises:",
        "detail": "robosuite.robosuite.models.grippers.gripper_factory",
        "documentation": {}
    },
    {
        "label": "GripperModel",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.gripper_model",
        "description": "robosuite.robosuite.models.grippers.gripper_model",
        "peekOfCode": "class GripperModel(MujocoXMLModel):\n    \"\"\"\n    Base class for grippers\n    Args:\n        fname (str): Path to relevant xml file to create this gripper instance\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, fname, idn=0):\n        super().__init__(fname, idn=idn)\n        # Set variable to hold current action being outputted",
        "detail": "robosuite.robosuite.models.grippers.gripper_model",
        "documentation": {}
    },
    {
        "label": "GripperTester",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.gripper_tester",
        "description": "robosuite.robosuite.models.grippers.gripper_tester",
        "peekOfCode": "class GripperTester:\n    \"\"\"\n    A class that is used to test gripper\n    Args:\n        gripper (GripperModel): A gripper instance to be tested\n        pos (str): (x y z) position to place the gripper in string form, e.g. '0 0 0.3'\n        quat (str): rotation to apply to gripper in string form, e.g. '0 0 1 0' to flip z axis\n        gripper_low_pos (float): controls the gipper y position, larger -> higher\n        gripper_high_pos (float): controls the gipper y high position larger -> higher,\n            must be larger than gripper_low_pos",
        "detail": "robosuite.robosuite.models.grippers.gripper_tester",
        "documentation": {}
    },
    {
        "label": "JacoThreeFingerGripperBase",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.jaco_three_finger_gripper",
        "description": "robosuite.robosuite.models.grippers.jaco_three_finger_gripper",
        "peekOfCode": "class JacoThreeFingerGripperBase(GripperModel):\n    \"\"\"\n    Gripper for Kinova's Jaco robot arm (has three fingers).\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/jaco_three_finger_gripper.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.robosuite.models.grippers.jaco_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "JacoThreeFingerGripper",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.jaco_three_finger_gripper",
        "description": "robosuite.robosuite.models.grippers.jaco_three_finger_gripper",
        "peekOfCode": "class JacoThreeFingerGripper(JacoThreeFingerGripperBase):\n    \"\"\"\n    Modifies JacoThreeFingerGripperBase to only take one action.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.robosuite.models.grippers.jaco_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "JacoThreeFingerDexterousGripper",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.jaco_three_finger_gripper",
        "description": "robosuite.robosuite.models.grippers.jaco_three_finger_gripper",
        "peekOfCode": "class JacoThreeFingerDexterousGripper(JacoThreeFingerGripperBase):\n    \"\"\"\n    Dexterous variation of the Jaco gripper in which all finger are actuated independently\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        all -1 => open, all 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.robosuite.models.grippers.jaco_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "NullGripper",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.null_gripper",
        "description": "robosuite.robosuite.models.grippers.null_gripper",
        "peekOfCode": "class NullGripper(GripperModel):\n    \"\"\"\n    Dummy Gripper class to represent no gripper\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/null_gripper.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.robosuite.models.grippers.null_gripper",
        "documentation": {}
    },
    {
        "label": "PandaGripperBase",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.panda_gripper",
        "description": "robosuite.robosuite.models.grippers.panda_gripper",
        "peekOfCode": "class PandaGripperBase(GripperModel):\n    \"\"\"\n    Gripper for Franka's Panda (has two fingers).\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/panda_gripper.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.robosuite.models.grippers.panda_gripper",
        "documentation": {}
    },
    {
        "label": "PandaGripper",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.panda_gripper",
        "description": "robosuite.robosuite.models.grippers.panda_gripper",
        "peekOfCode": "class PandaGripper(PandaGripperBase):\n    \"\"\"\n    Modifies PandaGripperBase to only take one action.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.robosuite.models.grippers.panda_gripper",
        "documentation": {}
    },
    {
        "label": "RethinkGripperBase",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.rethink_gripper",
        "description": "robosuite.robosuite.models.grippers.rethink_gripper",
        "peekOfCode": "class RethinkGripperBase(GripperModel):\n    \"\"\"\n    Gripper with long two-fingered parallel jaw.\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/rethink_gripper.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.robosuite.models.grippers.rethink_gripper",
        "documentation": {}
    },
    {
        "label": "RethinkGripper",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.rethink_gripper",
        "description": "robosuite.robosuite.models.grippers.rethink_gripper",
        "peekOfCode": "class RethinkGripper(RethinkGripperBase):\n    \"\"\"\n    Modifies two finger base to only take one action.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.robosuite.models.grippers.rethink_gripper",
        "documentation": {}
    },
    {
        "label": "Robotiq140GripperBase",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.robotiq_140_gripper",
        "description": "robosuite.robosuite.models.grippers.robotiq_140_gripper",
        "peekOfCode": "class Robotiq140GripperBase(GripperModel):\n    \"\"\"\n    Gripper with 140mm Jaw width from Robotiq (has two fingers).\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/robotiq_gripper_140.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.robosuite.models.grippers.robotiq_140_gripper",
        "documentation": {}
    },
    {
        "label": "Robotiq140Gripper",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.robotiq_140_gripper",
        "description": "robosuite.robosuite.models.grippers.robotiq_140_gripper",
        "peekOfCode": "class Robotiq140Gripper(Robotiq140GripperBase):\n    \"\"\"\n    Modifies Robotiq140GripperBase to only take one action.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.robosuite.models.grippers.robotiq_140_gripper",
        "documentation": {}
    },
    {
        "label": "Robotiq85GripperBase",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.robotiq_85_gripper",
        "description": "robosuite.robosuite.models.grippers.robotiq_85_gripper",
        "peekOfCode": "class Robotiq85GripperBase(GripperModel):\n    \"\"\"\n    6-DoF Robotiq gripper.\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/robotiq_gripper_85.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.robosuite.models.grippers.robotiq_85_gripper",
        "documentation": {}
    },
    {
        "label": "Robotiq85Gripper",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.robotiq_85_gripper",
        "description": "robosuite.robosuite.models.grippers.robotiq_85_gripper",
        "peekOfCode": "class Robotiq85Gripper(Robotiq85GripperBase):\n    \"\"\"\n    1-DoF variant of RobotiqGripperBase.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.robosuite.models.grippers.robotiq_85_gripper",
        "documentation": {}
    },
    {
        "label": "RobotiqThreeFingerGripperBase",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.robotiq_three_finger_gripper",
        "description": "robosuite.robosuite.models.grippers.robotiq_three_finger_gripper",
        "peekOfCode": "class RobotiqThreeFingerGripperBase(GripperModel):\n    \"\"\"\n    Gripper with 11 dof controlling three fingers.\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"grippers/robotiq_gripper_s.xml\"), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.robosuite.models.grippers.robotiq_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "RobotiqThreeFingerGripper",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.robotiq_three_finger_gripper",
        "description": "robosuite.robosuite.models.grippers.robotiq_three_finger_gripper",
        "peekOfCode": "class RobotiqThreeFingerGripper(RobotiqThreeFingerGripperBase):\n    \"\"\"\n    1-DoF variant of RobotiqThreeFingerGripperBase.\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        -1 => open, 1 => closed\n        Args:\n            action (np.array): gripper-specific action",
        "detail": "robosuite.robosuite.models.grippers.robotiq_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "RobotiqThreeFingerDexterousGripper",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.robotiq_three_finger_gripper",
        "description": "robosuite.robosuite.models.grippers.robotiq_three_finger_gripper",
        "peekOfCode": "class RobotiqThreeFingerDexterousGripper(RobotiqThreeFingerGripperBase):\n    \"\"\"\n    Dexterous variation of the 3-finger Robotiq gripper in which all finger are actuated independently as well\n    as the scissor joint between fingers 1 and 2\n    \"\"\"\n    def format_action(self, action):\n        \"\"\"\n        Maps continuous action into binary output\n        all -1 => open, all 1 => closed\n        Args:",
        "detail": "robosuite.robosuite.models.grippers.robotiq_three_finger_gripper",
        "documentation": {}
    },
    {
        "label": "WipingGripper",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.grippers.wiping_gripper",
        "description": "robosuite.robosuite.models.grippers.wiping_gripper",
        "peekOfCode": "class WipingGripper(GripperModel):\n    \"\"\"\n    A Wiping Gripper with no actuation and enabled with sensors to detect contact forces\n    Args:\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion('grippers/wiping_gripper.xml'), idn=idn)\n    def format_action(self, action):\n        return action",
        "detail": "robosuite.robosuite.models.grippers.wiping_gripper",
        "documentation": {}
    },
    {
        "label": "mount_factory",
        "kind": 2,
        "importPath": "robosuite.robosuite.models.mounts.mount_factory",
        "description": "robosuite.robosuite.models.mounts.mount_factory",
        "peekOfCode": "def mount_factory(name, idn=0):\n    \"\"\"\n    Generator for grippers\n    Creates a MountModel instance with the provided name.\n    Args:\n        name (None or str): the name of the mount class\n        idn (int or str): Number or some other unique identification string for this mount instance\n    Returns:\n        MountModel: requested mount instance\n    Raises:",
        "detail": "robosuite.robosuite.models.mounts.mount_factory",
        "documentation": {}
    },
    {
        "label": "MountModel",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.mounts.mount_model",
        "description": "robosuite.robosuite.models.mounts.mount_model",
        "peekOfCode": "class MountModel(MujocoXMLModel):\n    \"\"\"\n    Base class for mounts that will be attached to robots. Note that this model's root body will be directly\n    appended to the robot's root body, so all offsets should be taken relative to that.\n    Args:\n        fname (str): Path to relevant xml file to create this mount instance\n        idn (int or str): Number or some other unique identification string for this gripper instance\n    \"\"\"\n    def __init__(self, fname, idn=0):\n        super().__init__(fname, idn=idn)",
        "detail": "robosuite.robosuite.models.mounts.mount_model",
        "documentation": {}
    },
    {
        "label": "NullMount",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.mounts.null_mount",
        "description": "robosuite.robosuite.models.mounts.null_mount",
        "peekOfCode": "class NullMount(MountModel):\n    \"\"\"\n    Dummy Mount to signify no mount.\n    Args:\n        idn (int or str): Number or some other unique identification string for this mount instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"mounts/null_mount.xml\"), idn=idn)\n    @property\n    def top_offset(self):",
        "detail": "robosuite.robosuite.models.mounts.null_mount",
        "documentation": {}
    },
    {
        "label": "RethinkMinimalMount",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.mounts.rethink_minimal_mount",
        "description": "robosuite.robosuite.models.mounts.rethink_minimal_mount",
        "peekOfCode": "class RethinkMinimalMount(MountModel):\n    \"\"\"\n    Mount officially used for Rethink's Baxter Robot. Includes only a wheeled pedestal.\n    Args:\n        idn (int or str): Number or some other unique identification string for this mount instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"mounts/rethink_minimal_mount.xml\"), idn=idn)\n    @property\n    def top_offset(self):",
        "detail": "robosuite.robosuite.models.mounts.rethink_minimal_mount",
        "documentation": {}
    },
    {
        "label": "RethinkMount",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.mounts.rethink_mount",
        "description": "robosuite.robosuite.models.mounts.rethink_mount",
        "peekOfCode": "class RethinkMount(MountModel):\n    \"\"\"\n    Mount officially used for Rethink's Sawyer Robot. Includes a controller box and wheeled pedestal.\n    Args:\n        idn (int or str): Number or some other unique identification string for this mount instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"mounts/rethink_mount.xml\"), idn=idn)\n    @property\n    def top_offset(self):",
        "detail": "robosuite.robosuite.models.mounts.rethink_mount",
        "documentation": {}
    },
    {
        "label": "HammerObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.composite.hammer",
        "description": "robosuite.robosuite.models.objects.composite.hammer",
        "peekOfCode": "class HammerObject(CompositeObject):\n    \"\"\"\n    Generates a Hammer object with a cylindrical or box-shaped handle, cubic head, cylindrical face and triangular claw\n    (used in Handover task)\n    Args:\n        name (str): Name of this Hammer object\n        handle_shape (str): Either \"box\", for a box-shaped handle, or \"cylinder\", for a cylindrically-shaped handle\n        handle_radius (float or 2-array of float): Either specific or range of values to draw randomly from\n            uniformly for the handle radius\n        handle_length (float or 2-array of float): Either specific or range of values to draw randomly from",
        "detail": "robosuite.robosuite.models.objects.composite.hammer",
        "documentation": {}
    },
    {
        "label": "PotWithHandlesObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.composite.pot_with_handles",
        "description": "robosuite.robosuite.models.objects.composite.pot_with_handles",
        "peekOfCode": "class PotWithHandlesObject(CompositeObject):\n    \"\"\"\n    Generates the Pot object with side handles (used in TwoArmLift)\n    Args:\n        name (str): Name of this Pot object\n        body_half_size (3-array of float): If specified, defines the (x,y,z) half-dimensions of the main pot\n            body. Otherwise, defaults to [0.07, 0.07, 0.07]\n        handle_radius (float): Determines the pot handle radius\n        handle_length (float): Determines the pot handle length\n        handle_width (float): Determines the pot handle width",
        "detail": "robosuite.robosuite.models.objects.composite.pot_with_handles",
        "documentation": {}
    },
    {
        "label": "HingedBoxObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.composite_body.hinged_box",
        "description": "robosuite.robosuite.models.objects.composite_body.hinged_box",
        "peekOfCode": "class HingedBoxObject(CompositeBodyObject):\n    \"\"\"\n    An example object that demonstrates the CompositeBodyObject functionality. This object consists of two cube bodies\n    joined together by a hinge joint.\n    Args:\n        name (str): Name of this object\n        box1_size (3-array): (L, W, H) half-sizes for the first box\n        box2_size (3-array): (L, W, H) half-sizes for the second box\n        use_texture (bool): set True if using wood textures for the blocks\n    \"\"\"",
        "detail": "robosuite.robosuite.models.objects.composite_body.hinged_box",
        "documentation": {}
    },
    {
        "label": "BallObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.primitive.ball",
        "description": "robosuite.robosuite.models.objects.primitive.ball",
        "peekOfCode": "class BallObject(PrimitiveObject):\n    \"\"\"\n    A ball (sphere) object.\n    Args:\n        size (1-tuple of float): (radius) size parameters for this ball object\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        size=None,",
        "detail": "robosuite.robosuite.models.objects.primitive.ball",
        "documentation": {}
    },
    {
        "label": "BoxObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.primitive.box",
        "description": "robosuite.robosuite.models.objects.primitive.box",
        "peekOfCode": "class BoxObject(PrimitiveObject):\n    \"\"\"\n    A box object.\n    Args:\n        size (3-tuple of float): (half-x, half-y, half-z) size parameters for this box object\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        size=None,",
        "detail": "robosuite.robosuite.models.objects.primitive.box",
        "documentation": {}
    },
    {
        "label": "CapsuleObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.primitive.capsule",
        "description": "robosuite.robosuite.models.objects.primitive.capsule",
        "peekOfCode": "class CapsuleObject(PrimitiveObject):\n    \"\"\"\n    A capsule object.\n    Args:\n        size (2-tuple of float): (radius, half-length) size parameters for this capsule object\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        size=None,",
        "detail": "robosuite.robosuite.models.objects.primitive.capsule",
        "documentation": {}
    },
    {
        "label": "CylinderObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.primitive.cylinder",
        "description": "robosuite.robosuite.models.objects.primitive.cylinder",
        "peekOfCode": "class CylinderObject(PrimitiveObject):\n    \"\"\"\n    A cylinder object.\n    Args:\n        size (2-tuple of float): (radius, half-length) size parameters for this cylinder object\n    \"\"\"\n    def __init__(\n        self,\n        name,\n        size=None,",
        "detail": "robosuite.robosuite.models.objects.primitive.cylinder",
        "documentation": {}
    },
    {
        "label": "CompositeBodyObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.generated_objects",
        "description": "robosuite.robosuite.models.objects.generated_objects",
        "peekOfCode": "class CompositeBodyObject(MujocoGeneratedObject):\n    \"\"\"\n    An object constructed out of multiple bodies to make more complex shapes.\n    Args:\n        name (str): Name of overall object\n        objects (MujocoObject or list of MujocoObjects): object(s) to combine to form the composite body object.\n            Note that these objects will be added sequentially, so if an object is required to be nested relative to\n            another object, that nested object should be listed after the parent object. Note that all top-level joints\n            for any inputted objects are automatically stripped\n        object_locations (list): list of body locations in the composite. Each",
        "detail": "robosuite.robosuite.models.objects.generated_objects",
        "documentation": {}
    },
    {
        "label": "CompositeObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.generated_objects",
        "description": "robosuite.robosuite.models.objects.generated_objects",
        "peekOfCode": "class CompositeObject(MujocoGeneratedObject):\n    \"\"\"\n    An object constructed out of basic geoms to make more intricate shapes.\n    Note that by default, specifying None for a specific geom element will usually set a value to the mujoco defaults.\n    Args:\n        name (str): Name of overall object\n        total_size (list): (x, y, z) half-size in each dimension for the bounding box for\n            this Composite object\n        geom_types (list): list of geom types in the composite. Must correspond\n            to MuJoCo geom primitives, such as \"box\" or \"capsule\".",
        "detail": "robosuite.robosuite.models.objects.generated_objects",
        "documentation": {}
    },
    {
        "label": "PrimitiveObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.generated_objects",
        "description": "robosuite.robosuite.models.objects.generated_objects",
        "peekOfCode": "class PrimitiveObject(MujocoGeneratedObject):\n    \"\"\"\n    Base class for all programmatically generated mujoco object\n    i.e., every MujocoObject that does not have an corresponding xml file\n    Args:\n        name (str): (unique) name to identify this generated object\n        size (n-tuple of float): relevant size parameters for the object, should be of size 1 - 3\n        rgba (4-tuple of float): Color\n        density (float): Density\n        friction (3-tuple of float): (sliding friction, torsional friction, and rolling friction).",
        "detail": "robosuite.robosuite.models.objects.generated_objects",
        "documentation": {}
    },
    {
        "label": "MujocoObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.objects",
        "description": "robosuite.robosuite.models.objects.objects",
        "peekOfCode": "class MujocoObject(MujocoModel):\n    \"\"\"\n    Base class for all objects.\n    We use Mujoco Objects to implement all objects that:\n        1) may appear for multiple times in a task\n        2) can be swapped between different tasks\n    Typical methods return copy so the caller can all joints/attributes as wanted\n    Args:\n        obj_type (str): Geom elements to generate / extract for this object. Must be one of:\n            :`'collision'`: Only collision geoms are returned (this corresponds to group 0 geoms)",
        "detail": "robosuite.robosuite.models.objects.objects",
        "documentation": {}
    },
    {
        "label": "MujocoXMLObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.objects",
        "description": "robosuite.robosuite.models.objects.objects",
        "peekOfCode": "class MujocoXMLObject(MujocoXML, MujocoObject):\n    \"\"\"\n    MujocoObjects that are loaded from xml files\n    Args:\n        fname (str): XML File path\n        name (str): Name of this MujocoXMLObject\n        joints (None or str or list of dict): each dictionary corresponds to a joint that will be created for this\n            object. The dictionary should specify the joint attributes (type, pos, etc.) according to the MuJoCo xml\n            specification. If \"default\", a single free-joint will be automatically generated. If None, no joints will\n            be created.",
        "detail": "robosuite.robosuite.models.objects.objects",
        "documentation": {}
    },
    {
        "label": "MujocoGeneratedObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.objects",
        "description": "robosuite.robosuite.models.objects.objects",
        "peekOfCode": "class MujocoGeneratedObject(MujocoObject):\n    \"\"\"\n    Base class for all procedurally generated objects.\n    Args:\n        obj_type (str): Geom elements to generate / extract for this object. Must be one of:\n            :`'collision'`: Only collision geoms are returned (this corresponds to group 0 geoms)\n            :`'visual'`: Only visual geoms are returned (this corresponds to group 1 geoms)\n            :`'all'`: All geoms are returned\n        duplicate_collision_geoms (bool): If set, will guarantee that each collision geom has a\n            visual geom copy",
        "detail": "robosuite.robosuite.models.objects.objects",
        "documentation": {}
    },
    {
        "label": "GEOMTYPE2GROUP",
        "kind": 5,
        "importPath": "robosuite.robosuite.models.objects.objects",
        "description": "robosuite.robosuite.models.objects.objects",
        "peekOfCode": "GEOMTYPE2GROUP = {\n    \"collision\": {0},                 # If we want to use a geom for physics, but NOT visualize\n    \"visual\": {1},                    # If we want to use a geom for visualization, but NOT physics\n    \"all\": {0, 1},                    # If we want to use a geom for BOTH physics + visualization\n}\nGEOM_GROUPS = GEOMTYPE2GROUP.keys()\nclass MujocoObject(MujocoModel):\n    \"\"\"\n    Base class for all objects.\n    We use Mujoco Objects to implement all objects that:",
        "detail": "robosuite.robosuite.models.objects.objects",
        "documentation": {}
    },
    {
        "label": "GEOM_GROUPS",
        "kind": 5,
        "importPath": "robosuite.robosuite.models.objects.objects",
        "description": "robosuite.robosuite.models.objects.objects",
        "peekOfCode": "GEOM_GROUPS = GEOMTYPE2GROUP.keys()\nclass MujocoObject(MujocoModel):\n    \"\"\"\n    Base class for all objects.\n    We use Mujoco Objects to implement all objects that:\n        1) may appear for multiple times in a task\n        2) can be swapped between different tasks\n    Typical methods return copy so the caller can all joints/attributes as wanted\n    Args:\n        obj_type (str): Geom elements to generate / extract for this object. Must be one of:",
        "detail": "robosuite.robosuite.models.objects.objects",
        "documentation": {}
    },
    {
        "label": "BottleObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class BottleObject(MujocoXMLObject):\n    \"\"\"\n    Bottle object\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/bottle.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\nclass CanObject(MujocoXMLObject):\n    \"\"\"",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "CanObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class CanObject(MujocoXMLObject):\n    \"\"\"\n    Coke can object (used in PickPlace)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/can.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\nclass LemonObject(MujocoXMLObject):\n    \"\"\"",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "LemonObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class LemonObject(MujocoXMLObject):\n    \"\"\"\n    Lemon object\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/lemon.xml\"),\n                         name=name, obj_type=\"all\", duplicate_collision_geoms=True)\nclass MilkObject(MujocoXMLObject):\n    \"\"\"\n    Milk carton object (used in PickPlace)",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "MilkObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class MilkObject(MujocoXMLObject):\n    \"\"\"\n    Milk carton object (used in PickPlace)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/milk.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\nclass BreadObject(MujocoXMLObject):\n    \"\"\"",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "BreadObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class BreadObject(MujocoXMLObject):\n    \"\"\"\n    Bread loaf object (used in PickPlace)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/bread.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\nclass CerealObject(MujocoXMLObject):\n    \"\"\"",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "CerealObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class CerealObject(MujocoXMLObject):\n    \"\"\"\n    Cereal box object (used in PickPlace)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/cereal.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\nclass PegObject(MujocoXMLObject):\n    def __init__(self, name):",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "PegObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class PegObject(MujocoXMLObject):\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/peg.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\n    @property\n    def important_sites(self):\n        # Get dict from super call and add to it\n        dic = super().important_sites\n        dic.update({",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "SquareNutObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class SquareNutObject(MujocoXMLObject):\n    \"\"\"\n    Square nut object (used in NutAssembly)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/square-nut.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\n    @property\n    def important_sites(self):",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "RoundNutObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class RoundNutObject(MujocoXMLObject):\n    \"\"\"\n    Round nut (used in NutAssembly)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/round-nut.xml\"),\n                         name=name, joints=[dict(type=\"free\", damping=\"0.0005\")],\n                         obj_type=\"all\", duplicate_collision_geoms=True)\n    @property\n    def important_sites(self):",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "MilkVisualObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class MilkVisualObject(MujocoXMLObject):\n    \"\"\"\n    Visual fiducial of milk carton (used in PickPlace).\n    Fiducial objects are not involved in collision physics.\n    They provide a point of reference to indicate a position.\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/milk-visual.xml\"),\n                         name=name, joints=None, obj_type=\"visual\", duplicate_collision_geoms=True)\nclass BreadVisualObject(MujocoXMLObject):",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "BreadVisualObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class BreadVisualObject(MujocoXMLObject):\n    \"\"\"\n    Visual fiducial of bread loaf (used in PickPlace)\n    Fiducial objects are not involved in collision physics.\n    They provide a point of reference to indicate a position.\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/bread-visual.xml\"),\n                         name=name, joints=None, obj_type=\"visual\", duplicate_collision_geoms=True)\nclass CerealVisualObject(MujocoXMLObject):",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "CerealVisualObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class CerealVisualObject(MujocoXMLObject):\n    \"\"\"\n    Visual fiducial of cereal box (used in PickPlace)\n    Fiducial objects are not involved in collision physics.\n    They provide a point of reference to indicate a position.\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/cereal-visual.xml\"),\n                         name=name, joints=None, obj_type=\"visual\", duplicate_collision_geoms=True)\nclass CanVisualObject(MujocoXMLObject):",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "CanVisualObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class CanVisualObject(MujocoXMLObject):\n    \"\"\"\n    Visual fiducial of coke can (used in PickPlace)\n    Fiducial objects are not involved in collision physics.\n    They provide a point of reference to indicate a position.\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/can-visual.xml\"),\n                         name=name, joints=None, obj_type=\"visual\", duplicate_collision_geoms=True)\nclass PlateWithHoleObject(MujocoXMLObject):",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "PlateWithHoleObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class PlateWithHoleObject(MujocoXMLObject):\n    \"\"\"\n    Square plate with a hole in the center (used in PegInHole)\n    \"\"\"\n    def __init__(self, name):\n        super().__init__(xml_path_completion(\"objects/plate-with-hole.xml\"),\n                         name=name, joints=None, obj_type=\"all\", duplicate_collision_geoms=True)\nclass DoorObject(MujocoXMLObject):\n    \"\"\"\n    Door with handle (used in Door)",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "DoorObject",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.objects.xml_objects",
        "description": "robosuite.robosuite.models.objects.xml_objects",
        "peekOfCode": "class DoorObject(MujocoXMLObject):\n    \"\"\"\n    Door with handle (used in Door)\n    Args:\n        friction (3-tuple of float): friction parameters to override the ones specified in the XML\n        damping (float): damping parameter to override the ones specified in the XML\n        lock (bool): Whether to use the locked door variation object or not\n    \"\"\"\n    def __init__(self, name, friction=None, damping=None, lock=False):\n        xml_path = \"objects/door.xml\"",
        "detail": "robosuite.robosuite.models.objects.xml_objects",
        "documentation": {}
    },
    {
        "label": "Baxter",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.robots.manipulators.baxter_robot",
        "description": "robosuite.robosuite.models.robots.manipulators.baxter_robot",
        "peekOfCode": "class Baxter(ManipulatorModel):\n    \"\"\"\n    Baxter is a hunky bimanual robot designed by Rethink Robotics.\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/baxter/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.robosuite.models.robots.manipulators.baxter_robot",
        "documentation": {}
    },
    {
        "label": "IIWA",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.robots.manipulators.iiwa_robot",
        "description": "robosuite.robosuite.models.robots.manipulators.iiwa_robot",
        "peekOfCode": "class IIWA(ManipulatorModel):\n    \"\"\"\n    IIWA is a bright and spunky robot created by KUKA\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/iiwa/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.robosuite.models.robots.manipulators.iiwa_robot",
        "documentation": {}
    },
    {
        "label": "Jaco",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.robots.manipulators.jaco_robot",
        "description": "robosuite.robosuite.models.robots.manipulators.jaco_robot",
        "peekOfCode": "class Jaco(ManipulatorModel):\n    \"\"\"\n    Jaco is a kind and assistive robot created by Kinova\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/jaco/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.robosuite.models.robots.manipulators.jaco_robot",
        "documentation": {}
    },
    {
        "label": "Kinova3",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.robots.manipulators.kinova3_robot",
        "description": "robosuite.robosuite.models.robots.manipulators.kinova3_robot",
        "peekOfCode": "class Kinova3(ManipulatorModel):\n    \"\"\"\n    The Gen3 robot is the sparkly newest addition to the Kinova line\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/kinova3/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.robosuite.models.robots.manipulators.kinova3_robot",
        "documentation": {}
    },
    {
        "label": "ManipulatorModel",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.robots.manipulators.manipulator_model",
        "description": "robosuite.robosuite.models.robots.manipulators.manipulator_model",
        "peekOfCode": "class ManipulatorModel(RobotModel):\n    \"\"\"\n    Base class for all manipulator models (robot arm(s) with gripper(s)).\n    Args:\n        fname (str): Path to relevant xml file from which to create this robot instance\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, fname, idn=0):\n        # Always run super init first\n        super().__init__(fname, idn=idn)",
        "detail": "robosuite.robosuite.models.robots.manipulators.manipulator_model",
        "documentation": {}
    },
    {
        "label": "Panda",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.robots.manipulators.panda_robot",
        "description": "robosuite.robosuite.models.robots.manipulators.panda_robot",
        "peekOfCode": "class Panda(ManipulatorModel):\n    \"\"\"\n    Panda is a sensitive single-arm robot designed by Franka.\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/panda/robot.xml\"), idn=idn)\n        # Set joint damping\n        self.set_joint_attribute(attrib=\"damping\", values=np.array((0.1, 0.1, 0.1, 0.1, 0.1, 0.01, 0.01)))",
        "detail": "robosuite.robosuite.models.robots.manipulators.panda_robot",
        "documentation": {}
    },
    {
        "label": "Sawyer",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.robots.manipulators.sawyer_robot",
        "description": "robosuite.robosuite.models.robots.manipulators.sawyer_robot",
        "peekOfCode": "class Sawyer(ManipulatorModel):\n    \"\"\"\n    Sawyer is a witty single-arm robot designed by Rethink Robotics.\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/sawyer/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.robosuite.models.robots.manipulators.sawyer_robot",
        "documentation": {}
    },
    {
        "label": "UR5e",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.robots.manipulators.ur5e_robot",
        "description": "robosuite.robosuite.models.robots.manipulators.ur5e_robot",
        "peekOfCode": "class UR5e(ManipulatorModel):\n    \"\"\"\n    UR5e is a sleek and elegant new robot created by Universal Robots\n    Args:\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, idn=0):\n        super().__init__(xml_path_completion(\"robots/ur5e/robot.xml\"), idn=idn)\n    @property\n    def default_mount(self):",
        "detail": "robosuite.robosuite.models.robots.manipulators.ur5e_robot",
        "documentation": {}
    },
    {
        "label": "RobotModelMeta",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.robots.robot_model",
        "description": "robosuite.robosuite.models.robots.robot_model",
        "peekOfCode": "class RobotModelMeta(type):\n    \"\"\"Metaclass for registering robot arms\"\"\"\n    def __new__(meta, name, bases, class_dict):\n        cls = super().__new__(meta, name, bases, class_dict)\n        # List all environments that should not be registered here.\n        _unregistered_envs = [\"RobotModel\", \"ManipulatorModel\"]\n        if cls.__name__ not in _unregistered_envs:\n            register_robot(cls)\n        return cls\nclass RobotModel(MujocoXMLModel, metaclass=RobotModelMeta):",
        "detail": "robosuite.robosuite.models.robots.robot_model",
        "documentation": {}
    },
    {
        "label": "RobotModel",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.robots.robot_model",
        "description": "robosuite.robosuite.models.robots.robot_model",
        "peekOfCode": "class RobotModel(MujocoXMLModel, metaclass=RobotModelMeta):\n    \"\"\"\n    Base class for all robot models.\n    Args:\n        fname (str): Path to relevant xml file from which to create this robot instance\n        idn (int or str): Number or some other unique identification string for this robot instance\n    \"\"\"\n    def __init__(self, fname, idn=0):\n        super().__init__(fname, idn=idn)\n        # Define other variables that get filled later",
        "detail": "robosuite.robosuite.models.robots.robot_model",
        "documentation": {}
    },
    {
        "label": "register_robot",
        "kind": 2,
        "importPath": "robosuite.robosuite.models.robots.robot_model",
        "description": "robosuite.robosuite.models.robots.robot_model",
        "peekOfCode": "def register_robot(target_class):\n    REGISTERED_ROBOTS[target_class.__name__] = target_class\ndef create_robot(robot_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a Robot object.\n    Args:\n        robot_name (str): Name of the robot to initialize\n        *args: Additional arguments to pass to the specific Robot class initializer\n        **kwargs: Additional arguments to pass to the specific Robot class initializer\n    Returns:",
        "detail": "robosuite.robosuite.models.robots.robot_model",
        "documentation": {}
    },
    {
        "label": "create_robot",
        "kind": 2,
        "importPath": "robosuite.robosuite.models.robots.robot_model",
        "description": "robosuite.robosuite.models.robots.robot_model",
        "peekOfCode": "def create_robot(robot_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a Robot object.\n    Args:\n        robot_name (str): Name of the robot to initialize\n        *args: Additional arguments to pass to the specific Robot class initializer\n        **kwargs: Additional arguments to pass to the specific Robot class initializer\n    Returns:\n        Robot: Desired robot\n    Raises:",
        "detail": "robosuite.robosuite.models.robots.robot_model",
        "documentation": {}
    },
    {
        "label": "REGISTERED_ROBOTS",
        "kind": 5,
        "importPath": "robosuite.robosuite.models.robots.robot_model",
        "description": "robosuite.robosuite.models.robots.robot_model",
        "peekOfCode": "REGISTERED_ROBOTS = {}\ndef register_robot(target_class):\n    REGISTERED_ROBOTS[target_class.__name__] = target_class\ndef create_robot(robot_name, *args, **kwargs):\n    \"\"\"\n    Instantiates a Robot object.\n    Args:\n        robot_name (str): Name of the robot to initialize\n        *args: Additional arguments to pass to the specific Robot class initializer\n        **kwargs: Additional arguments to pass to the specific Robot class initializer",
        "detail": "robosuite.robosuite.models.robots.robot_model",
        "documentation": {}
    },
    {
        "label": "ManipulationTask",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.tasks.manipulation_task",
        "description": "robosuite.robosuite.models.tasks.manipulation_task",
        "peekOfCode": "class ManipulationTask(Task):\n    \"\"\"\n    A manipulation-specific task. This is currently a future-proofing placeholder.\n    \"\"\"",
        "detail": "robosuite.robosuite.models.tasks.manipulation_task",
        "documentation": {}
    },
    {
        "label": "Task",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.tasks.task",
        "description": "robosuite.robosuite.models.tasks.task",
        "peekOfCode": "class Task(MujocoWorldBase):\n    \"\"\"\n    Creates MJCF model for a task performed.\n    A task consists of one or more robots interacting with a variable number of\n    objects. This class combines the robot(s), the arena, and the objects\n    into a single MJCF model.\n    Args:\n        mujoco_arena (Arena): MJCF model of robot workspace\n        mujoco_robots (RobotModel or list of RobotModel): MJCF model of robot model(s) (list)\n        mujoco_objects (None or MujocoObject or list of MujocoObject): a list of MJCF models of physical objects",
        "detail": "robosuite.robosuite.models.tasks.task",
        "documentation": {}
    },
    {
        "label": "MujocoXML",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.base",
        "description": "robosuite.robosuite.models.base",
        "peekOfCode": "class MujocoXML(object):\n    \"\"\"\n    Base class of Mujoco xml file\n    Wraps around ElementTree and provides additional functionality for merging different models.\n    Specially, we keep track of <worldbody/>, <actuator/> and <asset/>\n    When initialized, loads a mujoco xml from file.\n    Args:\n        fname (str): path to the MJCF xml file.\n    \"\"\"\n    def __init__(self, fname):",
        "detail": "robosuite.robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoModel",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.base",
        "description": "robosuite.robosuite.models.base",
        "peekOfCode": "class MujocoModel(object):\n    \"\"\"\n    Base class for all simulation models used in mujoco.\n    Standardizes core API for accessing models' relevant geoms, names, etc.\n    \"\"\"\n    def correct_naming(self, names):\n        \"\"\"\n        Corrects all strings in @names by adding the naming prefix to it and returns the name-corrected values\n        Args:\n            names (str, list, or dict): Name(s) to be corrected",
        "detail": "robosuite.robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoXMLModel",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.base",
        "description": "robosuite.robosuite.models.base",
        "peekOfCode": "class MujocoXMLModel(MujocoXML, MujocoModel):\n    \"\"\"\n    Base class for all MujocoModels that are based on a raw XML file.\n    Args:\n        fname (str): Path to relevant xml file from which to create this robot instance\n        idn (int or str): Number or some other unique identification string for this model instance\n    \"\"\"\n    def __init__(self, fname, idn=0):\n        super().__init__(fname)\n        # Set id and add prefixes to all body names to prevent naming clashes",
        "detail": "robosuite.robosuite.models.base",
        "documentation": {}
    },
    {
        "label": "MujocoWorldBase",
        "kind": 6,
        "importPath": "robosuite.robosuite.models.world",
        "description": "robosuite.robosuite.models.world",
        "peekOfCode": "class MujocoWorldBase(MujocoXML):\n    \"\"\"Base class to inherit all mujoco worlds from.\"\"\"\n    def __init__(self):\n        super().__init__(xml_path_completion(\"base.xml\"))",
        "detail": "robosuite.robosuite.models.world",
        "documentation": {}
    },
    {
        "label": "Bimanual",
        "kind": 6,
        "importPath": "robosuite.robosuite.robots.bimanual",
        "description": "robosuite.robosuite.robots.bimanual",
        "peekOfCode": "class Bimanual(Manipulator):\n    \"\"\"\n    Initializes a bimanual robot simulation object.\n    Args:\n        robot_type (str): Specification for specific robot arm to be instantiated within this env (e.g: \"Panda\")\n        idn (int or str): Unique ID of this robot. Should be different from others\n        controller_config (dict or list of dict --> dict of dict): If set, contains relevant controller parameters\n            for creating custom controllers. Else, uses the default controller for this specific task. Should either\n            be single dict if same controller is to be used for both robot arms or else it should be a list of length 2.\n            :NOTE: In the latter case, assumes convention of [right, left]",
        "detail": "robosuite.robosuite.robots.bimanual",
        "documentation": {}
    },
    {
        "label": "Manipulator",
        "kind": 6,
        "importPath": "robosuite.robosuite.robots.manipulator",
        "description": "robosuite.robosuite.robots.manipulator",
        "peekOfCode": "class Manipulator(Robot):\n    \"\"\"\n    Initializes a manipulator robot simulation object, as defined by a single corresponding robot arm XML and\n    associated gripper XML\n    \"\"\"\n    def _load_controller(self):\n        raise NotImplementedError\n    def control(self, action, policy_step=False):\n        raise NotImplementedError\n    def grip_action(self, gripper, gripper_action):",
        "detail": "robosuite.robosuite.robots.manipulator",
        "documentation": {}
    },
    {
        "label": "Robot",
        "kind": 6,
        "importPath": "robosuite.robosuite.robots.robot",
        "description": "robosuite.robosuite.robots.robot",
        "peekOfCode": "class Robot(object):\n    \"\"\"\n    Initializes a robot simulation object, as defined by a single corresponding robot XML\n    Args:\n        robot_type (str): Specification for specific robot arm to be instantiated within this env (e.g: \"Panda\")\n        idn (int or str): Unique ID of this robot. Should be different from others\n        initial_qpos (sequence of float): If set, determines the initial joint positions of the robot to be\n            instantiated for the task\n        initialization_noise (dict): Dict containing the initialization noise parameters. The expected keys and\n            corresponding value types are specified below:",
        "detail": "robosuite.robosuite.robots.robot",
        "documentation": {}
    },
    {
        "label": "SingleArm",
        "kind": 6,
        "importPath": "robosuite.robosuite.robots.single_arm",
        "description": "robosuite.robosuite.robots.single_arm",
        "peekOfCode": "class SingleArm(Manipulator):\n    \"\"\"\n    Initializes a single-armed robot simulation object.\n    Args:\n        robot_type (str): Specification for specific robot arm to be instantiated within this env (e.g: \"Panda\")\n        idn (int or str): Unique ID of this robot. Should be different from others\n        controller_config (dict): If set, contains relevant controller parameters for creating a custom controller.\n            Else, uses the default controller for this specific task\n        initial_qpos (sequence of float): If set, determines the initial joint positions of the robot to be\n            instantiated for the task",
        "detail": "robosuite.robosuite.robots.single_arm",
        "documentation": {}
    },
    {
        "label": "collect_human_trajectory",
        "kind": 2,
        "importPath": "robosuite.robosuite.scripts.collect_human_demonstrations",
        "description": "robosuite.robosuite.scripts.collect_human_demonstrations",
        "peekOfCode": "def collect_human_trajectory(env, device, arm, env_configuration):\n    \"\"\"\n    Use the device (keyboard or SpaceNav 3D mouse) to collect a demonstration.\n    The rollout trajectory is saved to files in npz format.\n    Modify the DataCollectionWrapper wrapper to add new fields or change data formats.\n    Args:\n        env (MujocoEnv): environment to control\n        device (Device): to receive controls from the device\n        arms (str): which arm to control (eg bimanual) 'right' or 'left'\n        env_configuration (str): specified environment configuration",
        "detail": "robosuite.robosuite.scripts.collect_human_demonstrations",
        "documentation": {}
    },
    {
        "label": "gather_demonstrations_as_hdf5",
        "kind": 2,
        "importPath": "robosuite.robosuite.scripts.collect_human_demonstrations",
        "description": "robosuite.robosuite.scripts.collect_human_demonstrations",
        "peekOfCode": "def gather_demonstrations_as_hdf5(directory, out_dir, env_info):\n    \"\"\"\n    Gathers the demonstrations saved in @directory into a\n    single hdf5 file.\n    The strucure of the hdf5 file is as follows.\n    data (group)\n        date (attribute) - date of collection\n        time (attribute) - time of collection\n        repository_version (attribute) - repository version used during collection\n        env (attribute) - environment name on which demos were collected",
        "detail": "robosuite.robosuite.scripts.collect_human_demonstrations",
        "documentation": {}
    },
    {
        "label": "print_usage",
        "kind": 2,
        "importPath": "robosuite.robosuite.scripts.compile_mjcf_model",
        "description": "robosuite.robosuite.scripts.compile_mjcf_model",
        "peekOfCode": "def print_usage():\n    print(\"\"\"python compile_mjcf_model.py input_file output_file\"\"\")\nif __name__ == \"__main__\":\n    if len(sys.argv) != 3:\n        print_usage()\n        exit(0)\n    input_file = sys.argv[1]\n    output_file = sys.argv[2]\n    input_folder = os.path.dirname(input_file)\n    tempfile = os.path.join(input_folder, \".robosuite_temp_model.xml\")",
        "detail": "robosuite.robosuite.scripts.compile_mjcf_model",
        "documentation": {}
    },
    {
        "label": "KeyboardHandler",
        "kind": 6,
        "importPath": "robosuite.robosuite.scripts.tune_camera",
        "description": "robosuite.robosuite.scripts.tune_camera",
        "peekOfCode": "class KeyboardHandler:\n    def __init__(self, env, camera_id):\n        \"\"\"\n        Store internal state here.\n        Args:\n            env (MujocoEnv): Environment to use\n            camera_id (int): which camera to modify\n        \"\"\"\n        self.env = env\n        self.camera_id = camera_id",
        "detail": "robosuite.robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "modify_xml_for_camera_movement",
        "kind": 2,
        "importPath": "robosuite.robosuite.scripts.tune_camera",
        "description": "robosuite.robosuite.scripts.tune_camera",
        "peekOfCode": "def modify_xml_for_camera_movement(xml, camera_name):\n    \"\"\"\n    Cameras in mujoco are 'fixed', so they can't be moved by default.\n    Although it's possible to hack position movement, rotation movement\n    does not work. An alternative is to attach a camera to a mocap body,\n    and move the mocap body.\n    This function modifies the camera with name @camera_name in the xml\n    by attaching it to a mocap body that can move around freely. In this\n    way, we can move the camera by moving the mocap body.\n    See http://www.mujoco.org/forum/index.php?threads/move-camera.2201/ for",
        "detail": "robosuite.robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "move_camera",
        "kind": 2,
        "importPath": "robosuite.robosuite.scripts.tune_camera",
        "description": "robosuite.robosuite.scripts.tune_camera",
        "peekOfCode": "def move_camera(env, direction, scale, camera_id):\n    \"\"\"\n    Move the camera view along a direction (in the camera frame).\n    Args:\n        direction (np.arry): 3-array for where to move camera in camera frame\n        scale (float): how much to move along that direction\n        camera_id (int): which camera to modify\n    \"\"\"\n    # current camera pose\n    camera_pos = np.array(env.sim.data.get_mocap_pos(\"cameramover\"))",
        "detail": "robosuite.robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "rotate_camera",
        "kind": 2,
        "importPath": "robosuite.robosuite.scripts.tune_camera",
        "description": "robosuite.robosuite.scripts.tune_camera",
        "peekOfCode": "def rotate_camera(env, direction, angle, camera_id):\n    \"\"\"\n    Rotate the camera view about a direction (in the camera frame).\n    Args:\n        direction (np.array): 3-array for where to move camera in camera frame\n        angle (float): how much to rotate about that direction\n        camera_id (int): which camera to modify\n    \"\"\"\n    # current camera rotation\n    camera_rot = T.quat2mat(T.convert_quat(env.sim.data.get_mocap_quat(\"cameramover\"), to='xyzw'))",
        "detail": "robosuite.robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "print_command",
        "kind": 2,
        "importPath": "robosuite.robosuite.scripts.tune_camera",
        "description": "robosuite.robosuite.scripts.tune_camera",
        "peekOfCode": "def print_command(char, info):\n    \"\"\"\n    Prints out the command + relevant info entered by user\n    Args:\n        char (str): Command entered\n        info (str): Any additional info to print\n    \"\"\"\n    char += \" \" * (10 - len(char))\n    print(\"{}\\t{}\".format(char, info))\nif __name__ == \"__main__\":",
        "detail": "robosuite.robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "DELTA_POS_KEY_PRESS",
        "kind": 5,
        "importPath": "robosuite.robosuite.scripts.tune_camera",
        "description": "robosuite.robosuite.scripts.tune_camera",
        "peekOfCode": "DELTA_POS_KEY_PRESS = 0.05      # delta camera position per key press\nDELTA_ROT_KEY_PRESS = 1         # delta camera angle per key press\ndef modify_xml_for_camera_movement(xml, camera_name):\n    \"\"\"\n    Cameras in mujoco are 'fixed', so they can't be moved by default.\n    Although it's possible to hack position movement, rotation movement\n    does not work. An alternative is to attach a camera to a mocap body,\n    and move the mocap body.\n    This function modifies the camera with name @camera_name in the xml\n    by attaching it to a mocap body that can move around freely. In this",
        "detail": "robosuite.robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "DELTA_ROT_KEY_PRESS",
        "kind": 5,
        "importPath": "robosuite.robosuite.scripts.tune_camera",
        "description": "robosuite.robosuite.scripts.tune_camera",
        "peekOfCode": "DELTA_ROT_KEY_PRESS = 1         # delta camera angle per key press\ndef modify_xml_for_camera_movement(xml, camera_name):\n    \"\"\"\n    Cameras in mujoco are 'fixed', so they can't be moved by default.\n    Although it's possible to hack position movement, rotation movement\n    does not work. An alternative is to attach a camera to a mocap body,\n    and move the mocap body.\n    This function modifies the camera with name @camera_name in the xml\n    by attaching it to a mocap body that can move around freely. In this\n    way, we can move the camera by moving the mocap body.",
        "detail": "robosuite.robosuite.scripts.tune_camera",
        "documentation": {}
    },
    {
        "label": "KeyboardHandler",
        "kind": 6,
        "importPath": "robosuite.robosuite.scripts.tune_joints",
        "description": "robosuite.robosuite.scripts.tune_joints",
        "peekOfCode": "class KeyboardHandler:\n    def __init__(self, env, delta=0.05):\n        \"\"\"\n        Store internal state here.\n        Args:\n            env (MujocoEnv): Environment to use\n            delta (float): initial joint tuning increment\n        \"\"\"\n        self.env = env\n        self.delta = delta",
        "detail": "robosuite.robosuite.scripts.tune_joints",
        "documentation": {}
    },
    {
        "label": "print_command",
        "kind": 2,
        "importPath": "robosuite.robosuite.scripts.tune_joints",
        "description": "robosuite.robosuite.scripts.tune_joints",
        "peekOfCode": "def print_command(char, info):\n    \"\"\"\n    Prints out the command + relevant info entered by user\n    Args:\n        char (str): Command entered\n        info (str): Any additional info to print\n    \"\"\"\n    char += \" \" * (10 - len(char))\n    print(\"{}\\t{}\".format(char, info))\nif __name__ == \"__main__\":",
        "detail": "robosuite.robosuite.scripts.tune_joints",
        "documentation": {}
    },
    {
        "label": "Buffer",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.control_utils",
        "description": "robosuite.robosuite.utils.control_utils",
        "peekOfCode": "class Buffer(object):\n    \"\"\"\n    Abstract class for different kinds of data buffers. Minimum API should have a \"push\" and \"clear\" method\n    \"\"\"\n    def push(self, value):\n        \"\"\"\n        Pushes a new @value to the buffer\n        Args:\n            value: Value to push to the buffer\n        \"\"\"",
        "detail": "robosuite.robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "RingBuffer",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.control_utils",
        "description": "robosuite.robosuite.utils.control_utils",
        "peekOfCode": "class RingBuffer(Buffer):\n    \"\"\"\n    Simple RingBuffer object to hold values to average (useful for, e.g.: filtering D component in PID control)\n    Note that the buffer object is a 2D numpy array, where each row corresponds to\n    individual entries into the buffer\n    Args:\n        dim (int): Size of entries being added. This is, e.g.: the size of a state vector that is to be stored\n        length (int): Size of the ring buffer\n    \"\"\"\n    def __init__(self, dim, length):",
        "detail": "robosuite.robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "DeltaBuffer",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.control_utils",
        "description": "robosuite.robosuite.utils.control_utils",
        "peekOfCode": "class DeltaBuffer(Buffer):\n    \"\"\"\n    Simple 2-length buffer object to streamline grabbing delta values between \"current\" and \"last\" values\n    Constructs delta object.\n    Args:\n        dim (int): Size of numerical arrays being inputted\n        init_value (None or Iterable): Initial value to fill \"last\" value with initially.\n            If None (default), last array will be filled with zeros\n    \"\"\"\n    def __init__(self, dim, init_value=None):",
        "detail": "robosuite.robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "nullspace_torques",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.control_utils",
        "description": "robosuite.robosuite.utils.control_utils",
        "peekOfCode": "def nullspace_torques(mass_matrix, nullspace_matrix, initial_joint, joint_pos, joint_vel, joint_kp=10):\n    \"\"\"\n    For a robot with redundant DOF(s), a nullspace exists which is orthogonal to the remainder of the controllable\n    subspace of the robot's joints. Therefore, an additional secondary objective that does not impact the original\n    controller objective may attempt to be maintained using these nullspace torques.\n    This utility function specifically calculates nullspace torques that attempt to maintain a given robot joint\n    positions @initial_joint with zero velocity using proportinal gain @joint_kp\n    :Note: @mass_matrix, @nullspace_matrix, @joint_pos, and @joint_vel should reflect the robot's state at the current\n    timestep\n    Args:",
        "detail": "robosuite.robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "opspace_matrices",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.control_utils",
        "description": "robosuite.robosuite.utils.control_utils",
        "peekOfCode": "def opspace_matrices(mass_matrix, J_full, J_pos, J_ori):\n    \"\"\"\n    Calculates the relevant matrices used in the operational space control algorithm\n    Args:\n        mass_matrix (np.array): 2d array representing the mass matrix of the robot\n        J_full (np.array): 2d array representing the full Jacobian matrix of the robot\n        J_pos (np.array): 2d array representing the position components of the Jacobian matrix of the robot\n        J_ori (np.array): 2d array representing the orientation components of the Jacobian matrix of the robot\n    Returns:\n        4-tuple:",
        "detail": "robosuite.robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "orientation_error",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.control_utils",
        "description": "robosuite.robosuite.utils.control_utils",
        "peekOfCode": "def orientation_error(desired, current):\n    \"\"\"\n    This function calculates a 3-dimensional orientation error vector for use in the\n    impedance controller. It does this by computing the delta rotation between the\n    inputs and converting that rotation to exponential coordinates (axis-angle\n    representation, where the 3d vector is axis * angle).\n    See https://en.wikipedia.org/wiki/Axis%E2%80%93angle_representation for more information.\n    Optimized function to determine orientation error from matrices\n    Args:\n        desired (np.array): 2d array representing target orientation matrix",
        "detail": "robosuite.robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "set_goal_position",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.control_utils",
        "description": "robosuite.robosuite.utils.control_utils",
        "peekOfCode": "def set_goal_position(delta,\n                      current_position,\n                      position_limit=None,\n                      set_pos=None):\n    \"\"\"\n    Calculates and returns the desired goal position, clipping the result accordingly to @position_limits.\n    @delta and @current_position must be specified if a relative goal is requested, else @set_pos must be\n    specified to define a global goal position\n    Args:\n        delta (np.array): Desired relative change in position",
        "detail": "robosuite.robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "set_goal_orientation",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.control_utils",
        "description": "robosuite.robosuite.utils.control_utils",
        "peekOfCode": "def set_goal_orientation(delta,\n                         current_orientation,\n                         orientation_limit=None,\n                         set_ori=None):\n    \"\"\"\n    Calculates and returns the desired goal orientation, clipping the result accordingly to @orientation_limits.\n    @delta and @current_orientation must be specified if a relative goal is requested, else @set_ori must be\n    an orientation matrix specified to define a global orientation\n    Args:\n        delta (np.array): Desired relative change in orientation, in axis-angle form [ax, ay, az]",
        "detail": "robosuite.robosuite.utils.control_utils",
        "documentation": {}
    },
    {
        "label": "robosuiteError",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.errors",
        "description": "robosuite.robosuite.utils.errors",
        "peekOfCode": "class robosuiteError(Exception):\n    \"\"\"Base class for exceptions in robosuite.\"\"\"\n    pass\nclass XMLError(robosuiteError):\n    \"\"\"Exception raised for errors related to xml.\"\"\"\n    pass\nclass SimulationError(robosuiteError):\n    \"\"\"Exception raised for errors during runtime.\"\"\"\n    pass\nclass RandomizationError(robosuiteError):",
        "detail": "robosuite.robosuite.utils.errors",
        "documentation": {}
    },
    {
        "label": "XMLError",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.errors",
        "description": "robosuite.robosuite.utils.errors",
        "peekOfCode": "class XMLError(robosuiteError):\n    \"\"\"Exception raised for errors related to xml.\"\"\"\n    pass\nclass SimulationError(robosuiteError):\n    \"\"\"Exception raised for errors during runtime.\"\"\"\n    pass\nclass RandomizationError(robosuiteError):\n    \"\"\"Exception raised for really really bad RNG.\"\"\"\n    pass",
        "detail": "robosuite.robosuite.utils.errors",
        "documentation": {}
    },
    {
        "label": "SimulationError",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.errors",
        "description": "robosuite.robosuite.utils.errors",
        "peekOfCode": "class SimulationError(robosuiteError):\n    \"\"\"Exception raised for errors during runtime.\"\"\"\n    pass\nclass RandomizationError(robosuiteError):\n    \"\"\"Exception raised for really really bad RNG.\"\"\"\n    pass",
        "detail": "robosuite.robosuite.utils.errors",
        "documentation": {}
    },
    {
        "label": "RandomizationError",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.errors",
        "description": "robosuite.robosuite.utils.errors",
        "peekOfCode": "class RandomizationError(robosuiteError):\n    \"\"\"Exception raised for really really bad RNG.\"\"\"\n    pass",
        "detail": "robosuite.robosuite.utils.errors",
        "documentation": {}
    },
    {
        "label": "choose_environment",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.input_utils",
        "description": "robosuite.robosuite.utils.input_utils",
        "peekOfCode": "def choose_environment():\n    \"\"\"\n    Prints out environment options, and returns the selected env_name choice\n    Returns:\n        str: Chosen environment name\n    \"\"\"\n    # get the list of all environments\n    envs = sorted(suite.ALL_ENVIRONMENTS)\n    # Select environment to run\n    print(\"Here is a list of environments in the suite:\\n\")",
        "detail": "robosuite.robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "choose_controller",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.input_utils",
        "description": "robosuite.robosuite.utils.input_utils",
        "peekOfCode": "def choose_controller():\n    \"\"\"\n    Prints out controller options, and returns the requested controller name\n    Returns:\n        str: Chosen controller name\n    \"\"\"\n    # get the list of all controllers\n    controllers_info = suite.controllers.CONTROLLER_INFO\n    controllers = list(suite.ALL_CONTROLLERS)\n    # Select controller to use",
        "detail": "robosuite.robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "choose_multi_arm_config",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.input_utils",
        "description": "robosuite.robosuite.utils.input_utils",
        "peekOfCode": "def choose_multi_arm_config():\n    \"\"\"\n    Prints out multi-arm environment configuration options, and returns the requested config name\n    Returns:\n        str: Requested multi-arm configuration name\n    \"\"\"\n    # Get the list of all multi arm configs\n    env_configs = {\n        \"Single Arms Opposed\": \"single-arm-opposed\",\n        \"Single Arms Parallel\": \"single-arm-parallel\",",
        "detail": "robosuite.robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "choose_robots",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.input_utils",
        "description": "robosuite.robosuite.utils.input_utils",
        "peekOfCode": "def choose_robots(exclude_bimanual=False):\n    \"\"\"\n    Prints out robot options, and returns the requested robot. Restricts options to single-armed robots if\n    @exclude_bimanual is set to True (False by default)\n    Args:\n        exclude_bimanual (bool): If set, excludes bimanual robots from the robot options\n    Returns:\n        str: Requested robot name\n    \"\"\"\n    # Get the list of robots",
        "detail": "robosuite.robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "input2action",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.input_utils",
        "description": "robosuite.robosuite.utils.input_utils",
        "peekOfCode": "def input2action(device, robot, active_arm=\"right\", env_configuration=None):\n    \"\"\"\n    Converts an input from an active device into a valid action sequence that can be fed into an env.step() call\n    If a reset is triggered from the device, immediately returns None. Else, returns the appropriate action\n    Args:\n        device (Device): A device from which user inputs can be converted into actions. Can be either a Spacemouse or\n            Keyboard device class\n        robot (Robot): Which robot we're controlling\n        active_arm (str): Only applicable for multi-armed setups (e.g.: multi-arm environments or bimanual robots).\n            Allows inputs to be converted correctly if the control type (e.g.: IK) is dependent on arm choice.",
        "detail": "robosuite.robosuite.utils.input_utils",
        "documentation": {}
    },
    {
        "label": "USING_INSTANCE_RANDOMIZATION",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.macros",
        "description": "robosuite.robosuite.utils.macros",
        "peekOfCode": "USING_INSTANCE_RANDOMIZATION = False\n# Numba settings\nENABLE_NUMBA = True\nCACHE_NUMBA = True\n# Image Convention\n# Robosuite (Mujoco)-rendered images are based on the OpenGL coordinate frame convention, whereas many downstream\n# applications assume an OpenCV coordinate frame convention. For consistency, you can set the image convention\n# here; this will assure that any rendered frames will match the associated convention.\n# See the figure at the bottom of https://amytabb.com/ts/2019_06_28/ for an informative overview.\nIMAGE_CONVENTION = \"opengl\"     # Options are {\"opengl\", \"opencv\"}",
        "detail": "robosuite.robosuite.utils.macros",
        "documentation": {}
    },
    {
        "label": "ENABLE_NUMBA",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.macros",
        "description": "robosuite.robosuite.utils.macros",
        "peekOfCode": "ENABLE_NUMBA = True\nCACHE_NUMBA = True\n# Image Convention\n# Robosuite (Mujoco)-rendered images are based on the OpenGL coordinate frame convention, whereas many downstream\n# applications assume an OpenCV coordinate frame convention. For consistency, you can set the image convention\n# here; this will assure that any rendered frames will match the associated convention.\n# See the figure at the bottom of https://amytabb.com/ts/2019_06_28/ for an informative overview.\nIMAGE_CONVENTION = \"opengl\"     # Options are {\"opengl\", \"opencv\"}",
        "detail": "robosuite.robosuite.utils.macros",
        "documentation": {}
    },
    {
        "label": "CACHE_NUMBA",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.macros",
        "description": "robosuite.robosuite.utils.macros",
        "peekOfCode": "CACHE_NUMBA = True\n# Image Convention\n# Robosuite (Mujoco)-rendered images are based on the OpenGL coordinate frame convention, whereas many downstream\n# applications assume an OpenCV coordinate frame convention. For consistency, you can set the image convention\n# here; this will assure that any rendered frames will match the associated convention.\n# See the figure at the bottom of https://amytabb.com/ts/2019_06_28/ for an informative overview.\nIMAGE_CONVENTION = \"opengl\"     # Options are {\"opengl\", \"opencv\"}",
        "detail": "robosuite.robosuite.utils.macros",
        "documentation": {}
    },
    {
        "label": "IMAGE_CONVENTION",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.macros",
        "description": "robosuite.robosuite.utils.macros",
        "peekOfCode": "IMAGE_CONVENTION = \"opengl\"     # Options are {\"opengl\", \"opencv\"}",
        "detail": "robosuite.robosuite.utils.macros",
        "documentation": {}
    },
    {
        "label": "CustomMaterial",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "class CustomMaterial(object):\n    \"\"\"\n    Simple class to instantiate the necessary parameters to define an appropriate texture / material combo\n    Instantiates a nested dict holding necessary components for procedurally generating a texture / material combo\n    Please see http://www.mujoco.org/book/XMLreference.html#asset for specific details on\n        attributes expected for Mujoco texture / material tags, respectively\n    Note that the values in @tex_attrib and @mat_attrib can be in string or array / numerical form.\n    Args:\n        texture (None or str or 4-array): Name of texture file to be imported. If a string, should be part of\n            ALL_TEXTURES. If texture is a 4-array, then this argument will be interpreted as an rgba tuple value and",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "xml_path_completion",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def xml_path_completion(xml_path):\n    \"\"\"\n    Takes in a local xml path and returns a full path.\n        if @xml_path is absolute, do nothing\n        if @xml_path is not absolute, load xml that is shipped by the package\n    Args:\n        xml_path (str): local xml path\n    Returns:\n        str: Full (absolute) xml path\n    \"\"\"",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "array_to_string",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def array_to_string(array):\n    \"\"\"\n    Converts a numeric array into the string format in mujoco.\n    Examples:\n        [0, 1, 2] => \"0 1 2\"\n    Args:\n        array (n-array): Array to convert to a string\n    Returns:\n        str: String equivalent of @array\n    \"\"\"",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "string_to_array",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def string_to_array(string):\n    \"\"\"\n    Converts a array string in mujoco xml to np.array.\n    Examples:\n        \"0 1 2\" => [0, 1, 2]\n    Args:\n        string (str): String to convert to an array\n    Returns:\n        np.array: Numerical array equivalent of @string\n    \"\"\"",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "convert_to_string",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def convert_to_string(inp):\n    \"\"\"\n    Converts any type of {bool, int, float, list, tuple, array, string, np.str_} into an mujoco-xml compatible string.\n        Note that an input string / np.str_ results in a no-op action.\n    Args:\n        inp: Input to convert to string\n    Returns:\n        str: String equivalent of @inp\n    \"\"\"\n    if type(inp) in {list, tuple, np.ndarray}:",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "set_alpha",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def set_alpha(node, alpha=0.1):\n    \"\"\"\n    Sets all a(lpha) field of the rgba attribute to be @alpha\n    for @node and all subnodes\n    used for managing display\n    Args:\n        node (ET.Element): Specific node element within XML tree\n        alpha (float): Value to set alpha value of rgba tuple\n    \"\"\"\n    for child_node in node.findall(\".//*[@rgba]\"):",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_element",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_element(tag, name, **kwargs):\n    \"\"\"\n    Creates a new @tag element with attributes specified by @**kwargs.\n    Args:\n        tag (str): Type of element to create\n        name (None or str): Name for this element. Should only be None for elements that do not have an explicit\n            name attribute (e.g.: inertial elements)\n        **kwargs: Specified attributes for the new joint\n    Returns:\n        ET.Element: new specified xml element",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_joint",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_joint(name, **kwargs):\n    \"\"\"\n    Creates a joint tag with attributes specified by @**kwargs.\n    Args:\n        name (str): Name for this joint\n        **kwargs: Specified attributes for the new joint\n    Returns:\n        ET.Element: new joint xml element\n    \"\"\"\n    return new_element(tag=\"joint\", name=name, **kwargs)",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_actuator",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_actuator(name, joint, act_type=\"actuator\", **kwargs):\n    \"\"\"\n    Creates an actuator tag with attributes specified by @**kwargs.\n    Args:\n        name (str): Name for this actuator\n        joint (str): type of actuator transmission.\n            see all types here: http://mujoco.org/book/modeling.html#actuator\n        act_type (str): actuator type. Defaults to \"actuator\"\n        **kwargs: Any additional specified attributes for the new joint\n    Returns:",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_site",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_site(name, rgba=RED, pos=(0, 0, 0), size=(0.005,), **kwargs):\n    \"\"\"\n    Creates a site element with attributes specified by @**kwargs.\n    NOTE: With the exception of @name, @pos, and @size, if any arg is set to\n        None, the value will automatically be popped before passing the values\n        to create the appropriate XML\n    Args:\n        name (str): Name for this site\n        rgba (4-array): (r,g,b,a) color and transparency. Defaults to solid red.\n        pos (3-array): (x,y,z) 3d position of the site.",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_geom",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_geom(name, type, size, pos=(0, 0, 0), group=0, **kwargs):\n    \"\"\"\n    Creates a geom element with attributes specified by @**kwargs.\n    NOTE: With the exception of @geom_type, @size, and @pos, if any arg is set to\n        None, the value will automatically be popped before passing the values\n        to create the appropriate XML\n    Args:\n        name (str): Name for this geom\n        type (str): type of the geom.\n            see all types here: http://mujoco.org/book/modeling.html#geom",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_body",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_body(name, pos=(0, 0, 0), **kwargs):\n    \"\"\"\n    Creates a body element with attributes specified by @**kwargs.\n    Args:\n        name (str): Name for this body\n        pos (3-array): (x,y,z) 3d position of the body frame.\n        **kwargs: Any additional specified attributes for the new body\n    Returns:\n        ET.Element: new body xml element\n    \"\"\"",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "new_inertial",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def new_inertial(pos=(0, 0, 0), mass=None, **kwargs):\n    \"\"\"\n    Creates a inertial element with attributes specified by @**kwargs.\n    Args:\n        pos (3-array): (x,y,z) 3d position of the inertial frame.\n        mass (float): The mass of inertial\n        **kwargs: Any additional specified attributes for the new inertial element\n    Returns:\n        ET.Element: new inertial xml element\n    \"\"\"",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "get_size",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def get_size(size,\n             size_max,\n             size_min,\n             default_max,\n             default_min):\n    \"\"\"\n    Helper method for providing a size, or a range to randomize from\n    Args:\n        size (n-array): Array of numbers that explicitly define the size\n        size_max (n-array): Array of numbers that define the custom max size from which to randomly sample",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "postprocess_model_xml",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def postprocess_model_xml(xml_str):\n    \"\"\"\n    This function postprocesses the model.xml collected from a MuJoCo demonstration\n    in order to make sure that the STL files can be found.\n    Args:\n        xml_str (str): Mujoco sim demonstration XML file as string\n    Returns:\n        str: Post-processed xml file as string\n    \"\"\"\n    path = os.path.split(robosuite.__file__)[0]",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "add_to_dict",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def add_to_dict(dic, fill_in_defaults=True, default_value=None, **kwargs):\n    \"\"\"\n    Helper function to add key-values to dictionary @dic where each entry is its own array (list).\n    Args:\n        dic (dict): Dictionary to which new key / value pairs will be added. If the key already exists,\n            will append the value to that key entry\n        fill_in_defaults (bool): If True, will automatically add @default_value to all dictionary entries that are\n            not explicitly specified in @kwargs\n        default_value (any): Default value to fill (None by default)\n    Returns:",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "add_prefix",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def add_prefix(\n        root,\n        prefix,\n        tags=\"default\",\n        attribs=\"default\",\n        exclude=None,\n):\n    \"\"\"\n    Find all element(s) matching the requested @tag, and appends @prefix to all @attributes if they exist.\n    Args:",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "add_material",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def add_material(root, naming_prefix=\"\", custom_material=None):\n    \"\"\"\n    Iterates through all element(s) in @root recursively and adds a material / texture to all visual geoms that don't\n    already have a material specified.\n    Args:\n        root (ET.Element): Root of the xml element tree to start recursively searching through.\n        naming_prefix (str): Adds this prefix to all material and texture names\n        custom_material (None or CustomMaterial): If specified, will add this material to all visual geoms.\n            Else, will add a default \"no-change\" material.\n    Returns:",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "recolor_collision_geoms",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def recolor_collision_geoms(root, rgba, exclude=None):\n    \"\"\"\n    Iteratively searches through all elements starting with @root to find all geoms belonging to group 0 and set\n    the corresponding rgba value to the specified @rgba argument. Note: also removes any material values for these\n    elements.\n    Args:\n        root (ET.Element): Root of the xml element tree to start recursively searching through\n        rgba (4-array): (R, G, B, A) values to assign to all geoms with this group.\n        exclude (None or function): Filtering function that should take in an ET.Element and\n            return True if we should exclude the given element / attribute from having its collision geom impacted.",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "sort_elements",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def sort_elements(root, parent=None, element_filter=None, _elements_dict=None):\n    \"\"\"\n    Utility method to iteratively sort all elements based on @tags. This XML ElementTree will be parsed such that\n    all elements with the same key as returned by @element_filter will be grouped as a list entry in the returned\n    dictionary.\n    Args:\n        root (ET.Element): Root of the xml element tree to start recursively searching through\n        parent (ET.Element): Parent of the root node. Default is None (no parent node initially)\n        element_filter (None or function): Function used to filter the incoming elements. Should take in two\n            ET.Elements (current_element, parent_element) and return a string filter_key if the element",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "find_elements",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def find_elements(root, tags, attribs, return_first=True):\n    \"\"\"\n    Find all element(s) matching the requested @tag and @attributes. If @return_first is True, then will return the\n    first element found matching the criteria specified. Otherwise, will return a list of elements that match the\n    criteria.\n    Args:\n        root (ET.Element): Root of the xml element tree to start recursively searching through. Default is None\n            (use automatic top-level root in this XML object)\n        tags (str or list of str or set): Tag(s) to search for in this ElementTree.\n        attribs (dict of str): Element attribute(s) to check against for a filtered element. A match is",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "save_sim_model",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "def save_sim_model(sim, fname):\n    \"\"\"\n    Saves the current model xml from @sim at file location @fname.\n    Args:\n        sim (MjSim): XML file to save, in string form\n        fname (str): Absolute filepath to the location to save the file\n    \"\"\"\n    with open(fname, \"w\") as f:\n        sim.save(file=f, format=\"xml\")",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "RED",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "RED = [1, 0, 0, 1]\nGREEN = [0, 1, 0, 1]\nBLUE = [0, 0, 1, 1]\nCYAN = [0, 1, 1, 1]\nROBOT_COLLISION_COLOR = [0, 0.5, 0, 1]\nMOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "GREEN",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "GREEN = [0, 1, 0, 1]\nBLUE = [0, 0, 1, 1]\nCYAN = [0, 1, 1, 1]\nROBOT_COLLISION_COLOR = [0, 0.5, 0, 1]\nMOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "BLUE",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "BLUE = [0, 0, 1, 1]\nCYAN = [0, 1, 1, 1]\nROBOT_COLLISION_COLOR = [0, 0.5, 0, 1]\nMOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "CYAN",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "CYAN = [0, 1, 1, 1]\nROBOT_COLLISION_COLOR = [0, 0.5, 0, 1]\nMOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "ROBOT_COLLISION_COLOR",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "ROBOT_COLLISION_COLOR = [0, 0.5, 0, 1]\nMOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "MOUNT_COLLISION_COLOR",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "MOUNT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nGRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",\n    \"force\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "GRIPPER_COLLISION_COLOR",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "GRIPPER_COLLISION_COLOR = [0, 0, 0.5, 1]\nOBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",\n    \"force\",\n    \"torque\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "OBJECT_COLLISION_COLOR",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "OBJECT_COLLISION_COLOR = [0.5, 0, 0, 1]\nENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",\n    \"force\",\n    \"torque\",\n    \"magnetometer\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT_COLLISION_COLOR",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "ENVIRONMENT_COLLISION_COLOR = [0.5, 0.5, 0, 1]\nSENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",\n    \"force\",\n    \"torque\",\n    \"magnetometer\",\n    \"rangefinder\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "SENSOR_TYPES",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "SENSOR_TYPES = {\n    \"touch\",\n    \"accelerometer\",\n    \"velocimeter\",\n    \"gyro\",\n    \"force\",\n    \"torque\",\n    \"magnetometer\",\n    \"rangefinder\",\n    \"jointpos\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "MUJOCO_NAMED_ATTRIBUTES",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "MUJOCO_NAMED_ATTRIBUTES = {\n    \"class\", \"childclass\", \"name\", \"objname\", \"material\", \"texture\",\n    \"joint\", \"joint1\", \"joint2\", \"jointinparent\", \"geom\", \"geom1\", \"geom2\",\n    \"mesh\", \"fixed\", \"actuator\", \"objname\", \"tendon\", \"tendon1\", \"tendon2\",\n    \"slidesite\", \"cranksite\", \"body\", \"body1\", \"body2\", \"hfield\", \"target\",\n    \"prefix\", \"site\",\n}\nIMAGE_CONVENTION_MAPPING = {\n    \"opengl\": 1,\n    \"opencv\": -1,",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "IMAGE_CONVENTION_MAPPING",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "IMAGE_CONVENTION_MAPPING = {\n    \"opengl\": 1,\n    \"opencv\": -1,\n}\nTEXTURES = {\n    \"WoodRed\": \"red-wood.png\",\n    \"WoodGreen\": \"green-wood.png\",\n    \"WoodBlue\": \"blue-wood.png\",\n    \"WoodLight\": \"light-wood.png\",\n    \"WoodDark\": \"dark-wood.png\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "TEXTURES",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "TEXTURES = {\n    \"WoodRed\": \"red-wood.png\",\n    \"WoodGreen\": \"green-wood.png\",\n    \"WoodBlue\": \"blue-wood.png\",\n    \"WoodLight\": \"light-wood.png\",\n    \"WoodDark\": \"dark-wood.png\",\n    \"WoodTiles\": \"wood-tiles.png\",\n    \"WoodPanels\": \"wood-varnished-panels.png\",\n    \"WoodgrainGray\": \"gray-woodgrain.png\",\n    \"PlasterCream\": \"cream-plaster.png\",",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "ALL_TEXTURES",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjcf_utils",
        "description": "robosuite.robosuite.utils.mjcf_utils",
        "peekOfCode": "ALL_TEXTURES = TEXTURES.keys()\nclass CustomMaterial(object):\n    \"\"\"\n    Simple class to instantiate the necessary parameters to define an appropriate texture / material combo\n    Instantiates a nested dict holding necessary components for procedurally generating a texture / material combo\n    Please see http://www.mujoco.org/book/XMLreference.html#asset for specific details on\n        attributes expected for Mujoco texture / material tags, respectively\n    Note that the values in @tex_attrib and @mat_attrib can be in string or array / numerical form.\n    Args:\n        texture (None or str or 4-array): Name of texture file to be imported. If a string, should be part of",
        "detail": "robosuite.robosuite.utils.mjcf_utils",
        "documentation": {}
    },
    {
        "label": "BaseModder",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.mjmod",
        "description": "robosuite.robosuite.utils.mjmod",
        "peekOfCode": "class BaseModder():\n    \"\"\"\n    Base class meant to modify simulation attributes mid-sim.\n    Using @random_state ensures that sampling here won't be affected\n    by sampling that happens outside of the modders.\n    Args:\n        sim (MjSim): simulation object\n        random_state (RandomState): instance of np.random.RandomState, specific\n            seed used to randomize these modifications without impacting other\n            numpy seeds / randomizations",
        "detail": "robosuite.robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "LightingModder",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.mjmod",
        "description": "robosuite.robosuite.utils.mjmod",
        "peekOfCode": "class LightingModder(BaseModder):\n    \"\"\"\n    Modder to modify lighting within a Mujoco simulation.\n    Args:\n        sim (MjSim): MjSim object\n        random_state (RandomState): instance of np.random.RandomState\n        light_names (None or list of str): list of lights to use for randomization. If not provided, all\n            lights in the model are randomized.\n        randomize_position (bool): If True, randomizes position of lighting\n        randomize_direction (bool): If True, randomizes direction of lighting",
        "detail": "robosuite.robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "CameraModder",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.mjmod",
        "description": "robosuite.robosuite.utils.mjmod",
        "peekOfCode": "class CameraModder(BaseModder):\n    \"\"\"\n    Modder for modifying camera attributes in mujoco sim\n    Args:\n        sim (MjSim): MjSim object\n        random_state (None or RandomState): instance of np.random.RandomState\n        camera_names (None or list of str): list of camera names to use for randomization. If not provided,\n            all cameras are used for randomization.\n        randomize_position (bool): if True, randomize camera position\n        randomize_rotation (bool): if True, randomize camera rotation",
        "detail": "robosuite.robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "TextureModder",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.mjmod",
        "description": "robosuite.robosuite.utils.mjmod",
        "peekOfCode": "class TextureModder(BaseModder):\n    \"\"\"\n    Modify textures in model. Example use:\n        sim = MjSim(...)\n        modder = TextureModder(sim)\n        modder.whiten_materials()  # ensures materials won't impact colors\n        modder.set_checker('some_geom', (255, 0, 0), (0, 0, 0))\n        modder.rand_all('another_geom')\n    Note: in order for the textures to take full effect, you'll need to set\n    the rgba values for all materials to [1, 1, 1, 1], otherwise the texture",
        "detail": "robosuite.robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "Texture",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.mjmod",
        "description": "robosuite.robosuite.utils.mjmod",
        "peekOfCode": "class Texture:\n    \"\"\"\n    Helper class for operating on the MuJoCo textures.\n    Args:\n        model (MjModel): Mujoco sim model\n        tex_id (int): id of specific texture in mujoco sim\n    \"\"\"\n    __slots__ = ['id', 'type', 'height', 'width', 'tex_adr', 'tex_rgb']\n    def __init__(self, model, tex_id):\n        self.id = tex_id",
        "detail": "robosuite.robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "PhysicalParameterModder",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.mjmod",
        "description": "robosuite.robosuite.utils.mjmod",
        "peekOfCode": "class PhysicalParameterModder(BaseModder):\n    \"\"\"\n    Modder for various physical parameters of the mujoco model\n    can use to modify parameters stored in MjModel (ie friction, damping, etc.) as\n    well as optimizer parameters like global friction multipliers (eg solimp, solref, etc)\n    To modify a parameteter, use the parameter to be changed as a keyword argument to\n    self.mod and the new value as the value for that argument. Supports arbitray many\n    modifications in a single step.\n    :NOTE: It is necesary to perform sim.forward after performing the modification.\n    :NOTE: Some parameters might not be able to be changed. users are to verify that",
        "detail": "robosuite.robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "MJT_TEXTURE_ENUM",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.mjmod",
        "description": "robosuite.robosuite.utils.mjmod",
        "peekOfCode": "MJT_TEXTURE_ENUM = ['2d', 'cube', 'skybox']\nclass Texture:\n    \"\"\"\n    Helper class for operating on the MuJoCo textures.\n    Args:\n        model (MjModel): Mujoco sim model\n        tex_id (int): id of specific texture in mujoco sim\n    \"\"\"\n    __slots__ = ['id', 'type', 'height', 'width', 'tex_adr', 'tex_rgb']\n    def __init__(self, model, tex_id):",
        "detail": "robosuite.robosuite.utils.mjmod",
        "documentation": {}
    },
    {
        "label": "CustomMjViewer",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.mujoco_py_renderer",
        "description": "robosuite.robosuite.utils.mujoco_py_renderer",
        "peekOfCode": "class CustomMjViewer(MjViewer):\n    \"\"\"\n    Custom class extending the vanilla MjViewer class to add additional key-stroke callbacks\n    \"\"\"\n    keypress = defaultdict(list)\n    keyup = defaultdict(list)\n    keyrepeat = defaultdict(list)\n    def key_callback(self, window, key, scancode, action, mods):\n        \"\"\"\n        Processes key callbacks from the glfw renderer",
        "detail": "robosuite.robosuite.utils.mujoco_py_renderer",
        "documentation": {}
    },
    {
        "label": "MujocoPyRenderer",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.mujoco_py_renderer",
        "description": "robosuite.robosuite.utils.mujoco_py_renderer",
        "peekOfCode": "class MujocoPyRenderer:\n    \"\"\"\n    Mujoco-py renderer object\n    Args:\n        sim: MjSim object\n    \"\"\"\n    def __init__(self, sim):\n        self.viewer = CustomMjViewer(sim)\n        self.callbacks = {}\n    def set_camera(self, camera_id):",
        "detail": "robosuite.robosuite.utils.mujoco_py_renderer",
        "documentation": {}
    },
    {
        "label": "jit_decorator",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.numba",
        "description": "robosuite.robosuite.utils.numba",
        "peekOfCode": "def jit_decorator(func):\n    if macros.ENABLE_NUMBA:\n        return numba.jit(nopython=True, cache=macros.CACHE_NUMBA)(func)\n    return func",
        "detail": "robosuite.robosuite.utils.numba",
        "documentation": {}
    },
    {
        "label": "ObjectPositionSampler",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.placement_samplers",
        "description": "robosuite.robosuite.utils.placement_samplers",
        "peekOfCode": "class ObjectPositionSampler:\n    \"\"\"\n    Base class of object placement sampler.\n    Args:\n        name (str): Name of this sampler.\n        mujoco_objects (None or MujocoObject or list of MujocoObject): single model or list of MJCF object models\n        ensure_object_boundary_in_range (bool): If True, will ensure that the object is enclosed within a given boundary\n            (should be implemented by subclass)\n        ensure_valid_placement (bool): If True, will check for correct (valid) object placements\n        reference_pos (3-array): global (x,y,z) position relative to which sampling will occur",
        "detail": "robosuite.robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "UniformRandomSampler",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.placement_samplers",
        "description": "robosuite.robosuite.utils.placement_samplers",
        "peekOfCode": "class UniformRandomSampler(ObjectPositionSampler):\n    \"\"\"\n    Places all objects within the table uniformly random.\n    Args:\n        name (str): Name of this sampler.\n        mujoco_objects (None or MujocoObject or list of MujocoObject): single model or list of MJCF object models\n        x_range (2-array of float): Specify the (min, max) relative x_range used to uniformly place objects\n        y_range (2-array of float): Specify the (min, max) relative y_range used to uniformly place objects\n        rotation (None or float or Iterable):\n            :`None`: Add uniform random random rotation",
        "detail": "robosuite.robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "SequentialCompositeSampler",
        "kind": 6,
        "importPath": "robosuite.robosuite.utils.placement_samplers",
        "description": "robosuite.robosuite.utils.placement_samplers",
        "peekOfCode": "class SequentialCompositeSampler(ObjectPositionSampler):\n    \"\"\"\n    Samples position for each object sequentially. Allows chaining\n    multiple placement initializers together - so that object locations can\n    be sampled on top of other objects or relative to other object placements.\n    Args:\n        name (str): Name of this sampler.\n    \"\"\"\n    def __init__(self, name):\n        # Samplers / args will be filled in later",
        "detail": "robosuite.robosuite.utils.placement_samplers",
        "documentation": {}
    },
    {
        "label": "check_bimanual",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.robot_utils",
        "description": "robosuite.robosuite.utils.robot_utils",
        "peekOfCode": "def check_bimanual(robot_name):\n    \"\"\"\n    Utility function that returns whether the inputted robot_name is a bimanual robot or not\n    Args:\n        robot_name (str): Name of the robot to check\n    Returns:\n        bool: True if the inputted robot is a bimanual robot\n    \"\"\"\n    return robot_name.lower() in BIMANUAL_ROBOTS",
        "detail": "robosuite.robosuite.utils.robot_utils",
        "documentation": {}
    },
    {
        "label": "convert_quat",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def convert_quat(q, to=\"xyzw\"):\n    \"\"\"\n    Converts quaternion from one convention to another.\n    The convention to convert TO is specified as an optional argument.\n    If to == 'xyzw', then the input is in 'wxyz' format, and vice-versa.\n    Args:\n        q (np.array): a 4-dim array corresponding to a quaternion\n        to (str): either 'xyzw' or 'wxyz', determining which convention to convert to.\n    \"\"\"\n    if to == \"xyzw\":",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_multiply",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def quat_multiply(quaternion1, quaternion0):\n    \"\"\"\n    Return multiplication of two quaternions (q1 * q0).\n    E.g.:\n    >>> q = quat_multiply([1, -2, 3, 4], [-5, 6, 7, 8])\n    >>> np.allclose(q, [-44, -14, 48, 28])\n    True\n    Args:\n        quaternion1 (np.array): (x,y,z,w) quaternion\n        quaternion0 (np.array): (x,y,z,w) quaternion",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_conjugate",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def quat_conjugate(quaternion):\n    \"\"\"\n    Return conjugate of quaternion.\n    E.g.:\n    >>> q0 = random_quaternion()\n    >>> q1 = quat_conjugate(q0)\n    >>> q1[3] == q0[3] and all(q1[:3] == -q0[:3])\n    True\n    Args:\n        quaternion (np.array): (x,y,z,w) quaternion",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_inverse",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def quat_inverse(quaternion):\n    \"\"\"\n    Return inverse of quaternion.\n    E.g.:\n    >>> q0 = random_quaternion()\n    >>> q1 = quat_inverse(q0)\n    >>> np.allclose(quat_multiply(q0, q1), [0, 0, 0, 1])\n    True\n    Args:\n        quaternion (np.array): (x,y,z,w) quaternion",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_distance",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def quat_distance(quaternion1, quaternion0):\n    \"\"\"\n    Returns distance between two quaternions, such that distance * quaternion0 = quaternion1\n    Args:\n        quaternion1 (np.array): (x,y,z,w) quaternion\n        quaternion0 (np.array): (x,y,z,w) quaternion\n    Returns:\n        np.array: (x,y,z,w) quaternion distance\n    \"\"\"\n    return quat_multiply(quaternion1, quat_inverse(quaternion0))",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat_slerp",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def quat_slerp(quat0, quat1, fraction, shortestpath=True):\n    \"\"\"\n    Return spherical linear interpolation between two quaternions.\n    E.g.:\n    >>> q0 = random_quat()\n    >>> q1 = random_quat()\n    >>> q = quat_slerp(q0, q1, 0.0)\n    >>> np.allclose(q, q0)\n    True\n    >>> q = quat_slerp(q0, q1, 1.0)",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "random_quat",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def random_quat(rand=None):\n    \"\"\"\n    Return uniform random unit quaternion.\n    E.g.:\n    >>> q = random_quat()\n    >>> np.allclose(1.0, vector_norm(q))\n    True\n    >>> q = random_quat(np.random.random(3))\n    >>> q.shape\n    (4,)",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "random_axis_angle",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def random_axis_angle(angle_limit=None, random_state=None):\n    \"\"\"\n    Samples an axis-angle rotation by first sampling a random axis\n    and then sampling an angle. If @angle_limit is provided, the size\n    of the rotation angle is constrained. \n    If @random_state is provided (instance of np.random.RandomState), it\n    will be used to generate random numbers.\n    Args:\n        angle_limit (None or float): If set, determines magnitude limit of angles to generate\n        random_state (None or RandomState): RNG to use if specified",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "vec",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def vec(values):\n    \"\"\"\n    Converts value tuple into a numpy vector.\n    Args:\n        values (n-array): a tuple of numbers\n    Returns:\n        np.array: vector of given values\n    \"\"\"\n    return np.array(values, dtype=np.float32)\ndef mat4(array):",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat4",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def mat4(array):\n    \"\"\"\n    Converts an array to 4x4 matrix.\n    Args:\n        array (n-array): the array in form of vec, list, or tuple\n    Returns:\n        np.array: a 4x4 numpy matrix\n    \"\"\"\n    return np.array(array, dtype=np.float32).reshape((4, 4))\ndef mat2pose(hmat):",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat2pose",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def mat2pose(hmat):\n    \"\"\"\n    Converts a homogeneous 4x4 matrix into pose.\n    Args:\n        hmat (np.array): a 4x4 homogeneous matrix\n    Returns:\n        2-tuple:\n            - (np.array) (x,y,z) position array in cartesian coordinates\n            - (np.array) (x,y,z,w) orientation array in quaternion form\n    \"\"\"",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat2quat",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def mat2quat(rmat):\n    \"\"\"\n    Converts given rotation matrix to quaternion.\n    Args:\n        rmat (np.array): 3x3 rotation matrix\n    Returns:\n        np.array: (x,y,z,w) float quaternion angles\n    \"\"\"\n    M = np.asarray(rmat).astype(np.float32)[:3, :3]\n    m00 = M[0, 0]",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "euler2mat",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def euler2mat(euler):\n    \"\"\"\n    Converts euler angles into rotation matrix form\n    Args:\n        euler (np.array): (r,p,y) angles\n    Returns:\n        np.array: 3x3 rotation matrix\n    Raises:\n        AssertionError: [Invalid input shape]\n    \"\"\"",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "mat2euler",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def mat2euler(rmat, axes=\"sxyz\"):\n    \"\"\"\n    Converts given rotation matrix to euler angles in radian.\n    Args:\n        rmat (np.array): 3x3 rotation matrix\n        axes (str): One of 24 axis sequences as string or encoded tuple (see top of this module)\n    Returns:\n        np.array: (r,p,y) converted euler angles in radian vec3 float\n    \"\"\"\n    try:",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "pose2mat",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def pose2mat(pose):\n    \"\"\"\n    Converts pose to homogeneous matrix.\n    Args:\n        pose (2-tuple): a (pos, orn) tuple where pos is vec3 float cartesian, and\n            orn is vec4 float quaternion.\n    Returns:\n        np.array: 4x4 homogeneous matrix\n    \"\"\"\n    homo_pose_mat = np.zeros((4, 4), dtype=np.float32)",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat2mat",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def quat2mat(quaternion):\n    \"\"\"\n    Converts given quaternion to matrix.\n    Args:\n        quaternion (np.array): (x,y,z,w) vec4 float angles\n    Returns:\n        np.array: 3x3 rotation matrix\n    \"\"\"\n    # awkward semantics for use with numba\n    inds = np.array([3, 0, 1, 2])",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat2axisangle",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def quat2axisangle(quat):\n    \"\"\"\n    Converts quaternion to axis-angle format.\n    Returns a unit vector direction scaled by its angle in radians.\n    Args:\n        quat (np.array): (x,y,z,w) vec4 float angles\n    Returns:\n        np.array: (ax,ay,az) axis-angle exponential coordinates\n    \"\"\"\n    # clip quaternion",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "quat2euler",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def quat2euler(quat):\n    \"\"\"\n    Convert a quaternion into euler angles (roll, pitch, yaw)\n    roll is rotation around x in radians (counterclockwise)\n    pitch is rotation around y in radians (counterclockwise)\n    yaw is rotation around z in radians (counterclockwise)\n    Taken from:\n    https://automaticaddison.com/how-to-convert-a-quaternion-into-euler-angles-in-python/\n    \"\"\"\n    x, y, z, w = quat",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "axisangle2quat",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def axisangle2quat(vec):\n    \"\"\"\n    Converts scaled axis-angle to quat.\n    Args:\n        vec (np.array): (ax,ay,az) axis-angle exponential coordinates\n    Returns:\n        np.array: (x,y,z,w) vec4 float angles\n    \"\"\"\n    # Grab angle\n    angle = np.linalg.norm(vec)",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "pose_in_A_to_pose_in_B",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def pose_in_A_to_pose_in_B(pose_A, pose_A_in_B):\n    \"\"\"\n    Converts a homogenous matrix corresponding to a point C in frame A\n    to a homogenous matrix corresponding to the same point C in frame B.\n    Args:\n        pose_A (np.array): 4x4 matrix corresponding to the pose of C in frame A\n        pose_A_in_B (np.array): 4x4 matrix corresponding to the pose of A in frame B\n    Returns:\n        np.array: 4x4 matrix corresponding to the pose of C in frame B\n    \"\"\"",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "pose_inv",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def pose_inv(pose):\n    \"\"\"\n    Computes the inverse of a homogeneous matrix corresponding to the pose of some\n    frame B in frame A. The inverse is the pose of frame A in frame B.\n    Args:\n        pose (np.array): 4x4 matrix for the pose to inverse\n    Returns:\n        np.array: 4x4 matrix for the inverse pose\n    \"\"\"\n    # Note, the inverse of a pose matrix is the following",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "vel_in_A_to_vel_in_B",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def vel_in_A_to_vel_in_B(vel_A, ang_vel_A, pose_A_in_B):\n    \"\"\"\n    Converts linear and angular velocity of a point in frame A to the equivalent in frame B.\n    Args:\n        vel_A (np.array): (vx,vy,vz) linear velocity in A\n        ang_vel_A (np.array): (wx,wy,wz) angular velocity in A\n        pose_A_in_B (np.array): 4x4 matrix corresponding to the pose of A in frame B\n    Returns:\n        2-tuple:\n            - (np.array) (vx,vy,vz) linear velocities in frame B",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "force_in_A_to_force_in_B",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def force_in_A_to_force_in_B(force_A, torque_A, pose_A_in_B):\n    \"\"\"\n    Converts linear and rotational force at a point in frame A to the equivalent in frame B.\n    Args:\n        force_A (np.array): (fx,fy,fz) linear force in A\n        torque_A (np.array): (tx,ty,tz) rotational force (moment) in A\n        pose_A_in_B (np.array): 4x4 matrix corresponding to the pose of A in frame B\n    Returns:\n        2-tuple:\n            - (np.array) (fx,fy,fz) linear forces in frame B",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "rotation_matrix",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def rotation_matrix(angle, direction, point=None):\n    \"\"\"\n    Returns matrix to rotate about axis defined by point and direction.\n    E.g.:\n        >>> angle = (random.random() - 0.5) * (2*math.pi)\n        >>> direc = numpy.random.random(3) - 0.5\n        >>> point = numpy.random.random(3) - 0.5\n        >>> R0 = rotation_matrix(angle, direc, point)\n        >>> R1 = rotation_matrix(angle-2*math.pi, direc, point)\n        >>> is_same_transform(R0, R1)",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "clip_translation",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def clip_translation(dpos, limit):\n    \"\"\"\n    Limits a translation (delta position) to a specified limit\n    Scales down the norm of the dpos to 'limit' if norm(dpos) > limit, else returns immediately\n    Args:\n        dpos (n-array): n-dim Translation being clipped (e,g.: (x, y, z)) -- numpy array\n        limit (float): Value to limit translation by -- magnitude (scalar, in same units as input)\n    Returns:\n        2-tuple:\n            - (np.array) Clipped translation (same dimension as inputs)",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "clip_rotation",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def clip_rotation(quat, limit):\n    \"\"\"\n    Limits a (delta) rotation to a specified limit\n    Converts rotation to axis-angle, clips, then re-converts back into quaternion\n    Args:\n        quat (np.array): (x,y,z,w) rotation being clipped\n        limit (float): Value to limit rotation by -- magnitude (scalar, in radians)\n    Returns:\n        2-tuple:\n            - (np.array) Clipped rotation quaternion (x, y, z, w)",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "make_pose",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def make_pose(translation, rotation):\n    \"\"\"\n    Makes a homogeneous pose matrix from a translation vector and a rotation matrix.\n    Args:\n        translation (np.array): (x,y,z) translation value\n        rotation (np.array): a 3x3 matrix representing rotation\n    Returns:\n        pose (np.array): a 4x4 homogeneous matrix\n    \"\"\"\n    pose = np.zeros((4, 4))",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "unit_vector",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def unit_vector(data, axis=None, out=None):\n    \"\"\"\n    Returns ndarray normalized by length, i.e. eucledian norm, along axis.\n    E.g.:\n        >>> v0 = numpy.random.random(3)\n        >>> v1 = unit_vector(v0)\n        >>> numpy.allclose(v1, v0 / numpy.linalg.norm(v0))\n        True\n        >>> v0 = numpy.random.rand(5, 4, 3)\n        >>> v1 = unit_vector(v0, axis=-1)",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "get_orientation_error",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def get_orientation_error(target_orn, current_orn):\n    \"\"\"\n    Returns the difference between two quaternion orientations as a 3 DOF numpy array.\n    For use in an impedance controller / task-space PD controller.\n    Args:\n        target_orn (np.array): (x, y, z, w) desired quaternion orientation\n        current_orn (np.array): (x, y, z, w) current quaternion orientation\n    Returns:\n        orn_error (np.array): (ax,ay,az) current orientation error, corresponds to\n            (target_orn - current_orn)",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "get_pose_error",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def get_pose_error(target_pose, current_pose):\n    \"\"\"\n    Computes the error corresponding to target pose - current pose as a 6-dim vector.\n    The first 3 components correspond to translational error while the last 3 components\n    correspond to the rotational error.\n    Args:\n        target_pose (np.array): a 4x4 homogenous matrix for the target pose\n        current_pose (np.array): a 4x4 homogenous matrix for the current pose\n    Returns:\n        np.array: 6-dim pose error.",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "matrix_inverse",
        "kind": 2,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "def matrix_inverse(matrix):\n    \"\"\"\n    Helper function to have an efficient matrix inversion function.\n    Args:\n        matrix (np.array): 2d-array representing a matrix\n    Returns:\n        np.array: 2d-array representing the matrix inverse\n    \"\"\"\n    return np.linalg.inv(matrix)",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "PI",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "PI = np.pi\nEPS = np.finfo(float).eps * 4.\n# axis sequences for Euler angles\n_NEXT_AXIS = [1, 2, 0, 1]\n# map axes strings to/from tuples of inner axis, parity, repetition, frame\n_AXES2TUPLE = {\n    \"sxyz\": (0, 0, 0, 0),\n    \"sxyx\": (0, 0, 1, 0),\n    \"sxzy\": (0, 1, 0, 0),\n    \"sxzx\": (0, 1, 1, 0),",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "EPS",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "EPS = np.finfo(float).eps * 4.\n# axis sequences for Euler angles\n_NEXT_AXIS = [1, 2, 0, 1]\n# map axes strings to/from tuples of inner axis, parity, repetition, frame\n_AXES2TUPLE = {\n    \"sxyz\": (0, 0, 0, 0),\n    \"sxyx\": (0, 0, 1, 0),\n    \"sxzy\": (0, 1, 0, 0),\n    \"sxzx\": (0, 1, 1, 0),\n    \"syzx\": (1, 0, 0, 0),",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "_NEXT_AXIS",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "_NEXT_AXIS = [1, 2, 0, 1]\n# map axes strings to/from tuples of inner axis, parity, repetition, frame\n_AXES2TUPLE = {\n    \"sxyz\": (0, 0, 0, 0),\n    \"sxyx\": (0, 0, 1, 0),\n    \"sxzy\": (0, 1, 0, 0),\n    \"sxzx\": (0, 1, 1, 0),\n    \"syzx\": (1, 0, 0, 0),\n    \"syzy\": (1, 0, 1, 0),\n    \"syxz\": (1, 1, 0, 0),",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "_AXES2TUPLE",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "_AXES2TUPLE = {\n    \"sxyz\": (0, 0, 0, 0),\n    \"sxyx\": (0, 0, 1, 0),\n    \"sxzy\": (0, 1, 0, 0),\n    \"sxzx\": (0, 1, 1, 0),\n    \"syzx\": (1, 0, 0, 0),\n    \"syzy\": (1, 0, 1, 0),\n    \"syxz\": (1, 1, 0, 0),\n    \"syxy\": (1, 1, 1, 0),\n    \"szxy\": (2, 0, 0, 0),",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "_TUPLE2AXES",
        "kind": 5,
        "importPath": "robosuite.robosuite.utils.transform_utils",
        "description": "robosuite.robosuite.utils.transform_utils",
        "peekOfCode": "_TUPLE2AXES = dict((v, k) for k, v in _AXES2TUPLE.items())\ndef convert_quat(q, to=\"xyzw\"):\n    \"\"\"\n    Converts quaternion from one convention to another.\n    The convention to convert TO is specified as an optional argument.\n    If to == 'xyzw', then the input is in 'wxyz' format, and vice-versa.\n    Args:\n        q (np.array): a 4-dim array corresponding to a quaternion\n        to (str): either 'xyzw' or 'wxyz', determining which convention to convert to.\n    \"\"\"",
        "detail": "robosuite.robosuite.utils.transform_utils",
        "documentation": {}
    },
    {
        "label": "DataCollectionWrapper",
        "kind": 6,
        "importPath": "robosuite.robosuite.wrappers.data_collection_wrapper",
        "description": "robosuite.robosuite.wrappers.data_collection_wrapper",
        "peekOfCode": "class DataCollectionWrapper(Wrapper):\n    def __init__(self, env, directory, collect_freq=1, flush_freq=100):\n        \"\"\"\n        Initializes the data collection wrapper.\n        Args:\n            env (MujocoEnv): The environment to monitor.\n            directory (str): Where to store collected data.\n            collect_freq (int): How often to save simulation state, in terms of environment steps.\n            flush_freq (int): How frequently to dump data to disk, in terms of environment steps.\n        \"\"\"",
        "detail": "robosuite.robosuite.wrappers.data_collection_wrapper",
        "documentation": {}
    },
    {
        "label": "DemoSamplerWrapper",
        "kind": 6,
        "importPath": "robosuite.robosuite.wrappers.demo_sampler_wrapper",
        "description": "robosuite.robosuite.wrappers.demo_sampler_wrapper",
        "peekOfCode": "class DemoSamplerWrapper(Wrapper):\n    \"\"\"\n    Initializes a wrapper that provides support for resetting the environment\n    state to one from a demonstration. It also supports curriculums for\n    altering how often to sample from demonstration vs. sampling a reset\n    state from the environment.\n    Args:\n        env (MujocoEnv): The environment to wrap.\n        demo_path (str): The path to the folder containing the demonstrations.\n            There should be a `demo.hdf5` file and a folder named `models` with",
        "detail": "robosuite.robosuite.wrappers.demo_sampler_wrapper",
        "documentation": {}
    },
    {
        "label": "DomainRandomizationWrapper",
        "kind": 6,
        "importPath": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "description": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "peekOfCode": "class DomainRandomizationWrapper(Wrapper):\n    \"\"\"\n    Wrapper that allows for domain randomization mid-simulation.\n    Args:\n        env (MujocoEnv): The environment to wrap.\n        seed (int): Integer used to seed all randomizations from this wrapper. It is\n            used to create a np.random.RandomState instance to make sure samples here\n            are isolated from sampling occurring elsewhere in the code. If not provided,\n            will default to using global random state.\n        randomize_color (bool): if True, randomize geom colors and texture colors",
        "detail": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_COLOR_ARGS",
        "kind": 5,
        "importPath": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "description": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "peekOfCode": "DEFAULT_COLOR_ARGS = {\n    'geom_names' : None, # all geoms are randomized\n    'randomize_local' : True, # sample nearby colors\n    'randomize_material' : True, # randomize material reflectance / shininess / specular\n    'local_rgb_interpolation' : 0.2,\n    'local_material_interpolation' : 0.3,\n    'texture_variations' : ['rgb', 'checker', 'noise', 'gradient'], # all texture variation types\n    'randomize_skybox' : True, # by default, randomize skybox too\n}\nDEFAULT_CAMERA_ARGS = {",
        "detail": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CAMERA_ARGS",
        "kind": 5,
        "importPath": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "description": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "peekOfCode": "DEFAULT_CAMERA_ARGS = {\n    'camera_names' : None, # all cameras are randomized\n    'randomize_position' : True,\n    'randomize_rotation' : True,\n    'randomize_fovy' : True,\n    'position_perturbation_size' : 0.01,\n    'rotation_perturbation_size' : 0.087,\n    'fovy_perturbation_size' : 5.,\n}\nDEFAULT_LIGHTING_ARGS = {",
        "detail": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LIGHTING_ARGS",
        "kind": 5,
        "importPath": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "description": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "peekOfCode": "DEFAULT_LIGHTING_ARGS = {\n    'light_names' : None, # all lights are randomized\n    'randomize_position' : True,\n    'randomize_direction' : True,\n    'randomize_specular' : True,\n    'randomize_ambient' : True,\n    'randomize_diffuse' : True,\n    'randomize_active' : True,\n    'position_perturbation_size' : 0.1,\n    'direction_perturbation_size' : 0.35,",
        "detail": "robosuite.robosuite.wrappers.domain_randomization_wrapper",
        "documentation": {}
    },
    {
        "label": "GymWrapper",
        "kind": 6,
        "importPath": "robosuite.robosuite.wrappers.gym_wrapper",
        "description": "robosuite.robosuite.wrappers.gym_wrapper",
        "peekOfCode": "class GymWrapper(Wrapper, Env):\n    \"\"\"\n    Initializes the Gym wrapper. Mimics many of the required functionalities of the Wrapper class\n    found in the gym.core module\n    Args:\n        env (MujocoEnv): The environment to wrap.\n        keys (None or list of str): If provided, each observation will\n            consist of concatenated keys from the wrapped environment's\n            observation dictionary. Defaults to robot-state and object-state.\n    Raises:",
        "detail": "robosuite.robosuite.wrappers.gym_wrapper",
        "documentation": {}
    },
    {
        "label": "VisualizationWrapper",
        "kind": 6,
        "importPath": "robosuite.robosuite.wrappers.visualization_wrapper",
        "description": "robosuite.robosuite.wrappers.visualization_wrapper",
        "peekOfCode": "class VisualizationWrapper(Wrapper):\n    def __init__(self, env, indicator_configs=None):\n        \"\"\"\n        Initializes the data collection wrapper. Note that this automatically conducts a (hard) reset initially to make\n        sure indicators are properly added to the sim model.\n        Args:\n            env (MujocoEnv): The environment to visualize\n            indicator_configs (None or str or dict or list): Configurations to use for indicator objects.\n                If None, no indicator objects will be used\n                If a string, this should be `'default'`, which corresponds to single default spherical indicator",
        "detail": "robosuite.robosuite.wrappers.visualization_wrapper",
        "documentation": {}
    },
    {
        "label": "DEFAULT_INDICATOR_SITE_CONFIG",
        "kind": 5,
        "importPath": "robosuite.robosuite.wrappers.visualization_wrapper",
        "description": "robosuite.robosuite.wrappers.visualization_wrapper",
        "peekOfCode": "DEFAULT_INDICATOR_SITE_CONFIG = {\n    \"type\": \"sphere\",\n    \"size\": [0.03],\n    \"rgba\": [1, 0, 0, 0.5],\n}\nclass VisualizationWrapper(Wrapper):\n    def __init__(self, env, indicator_configs=None):\n        \"\"\"\n        Initializes the data collection wrapper. Note that this automatically conducts a (hard) reset initially to make\n        sure indicators are properly added to the sim model.",
        "detail": "robosuite.robosuite.wrappers.visualization_wrapper",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "kind": 6,
        "importPath": "robosuite.robosuite.wrappers.wrapper",
        "description": "robosuite.robosuite.wrappers.wrapper",
        "peekOfCode": "class Wrapper:\n    \"\"\"\n    Base class for all wrappers in robosuite.\n    Args:\n        env (MujocoEnv): The environment to wrap.\n    \"\"\"\n    def __init__(self, env):\n        self.env = env\n    @classmethod\n    def class_name(cls):",
        "detail": "robosuite.robosuite.wrappers.wrapper",
        "documentation": {}
    },
    {
        "label": "test_all_controllers",
        "kind": 2,
        "importPath": "robosuite.tests.test_controllers.test_all_controllers",
        "description": "robosuite.tests.test_controllers.test_all_controllers",
        "peekOfCode": "def test_all_controllers():\n    for controller_name in controllers.keys():\n        # Define variables for each controller test\n        action_dim = controllers[controller_name][0]\n        num_test_steps = controllers[controller_name][1]\n        test_value = controllers[controller_name][2]\n        neutral = np.zeros(action_dim)\n        # Define controller path to load\n        controller_config = load_controller_config(default_controller=controller_name)\n        # Now, create a test env for testing the controller on",
        "detail": "robosuite.tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_all_controllers",
        "description": "robosuite.tests.test_controllers.test_all_controllers",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action='store_true', help=\"Whether to render this test or not for visual validation\")\nargs = parser.parse_args()\n# Define the controllers to use (action_dim, num_test_steps, test_value)\ncontrollers = {\n        \"OSC_POSE\":         [7, 6, 0.1],\n        \"OSC_POSITION\":     [4, 3, 0.1],\n        \"IK_POSE\":          [7, 6, 0.01],\n        \"JOINT_POSITION\":   [8, 7, 0.2],\n        \"JOINT_VELOCITY\":   [8, 7, -0.1],",
        "detail": "robosuite.tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_all_controllers",
        "description": "robosuite.tests.test_controllers.test_all_controllers",
        "peekOfCode": "args = parser.parse_args()\n# Define the controllers to use (action_dim, num_test_steps, test_value)\ncontrollers = {\n        \"OSC_POSE\":         [7, 6, 0.1],\n        \"OSC_POSITION\":     [4, 3, 0.1],\n        \"IK_POSE\":          [7, 6, 0.01],\n        \"JOINT_POSITION\":   [8, 7, 0.2],\n        \"JOINT_VELOCITY\":   [8, 7, -0.1],\n        \"JOINT_TORQUE\":     [8, 7, 0.25]\n    }",
        "detail": "robosuite.tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "controllers",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_all_controllers",
        "description": "robosuite.tests.test_controllers.test_all_controllers",
        "peekOfCode": "controllers = {\n        \"OSC_POSE\":         [7, 6, 0.1],\n        \"OSC_POSITION\":     [4, 3, 0.1],\n        \"IK_POSE\":          [7, 6, 0.01],\n        \"JOINT_POSITION\":   [8, 7, 0.2],\n        \"JOINT_VELOCITY\":   [8, 7, -0.1],\n        \"JOINT_TORQUE\":     [8, 7, 0.25]\n    }\n# Define the number of timesteps to use per controller action as well as timesteps in between actions\nsteps_per_action = 50",
        "detail": "robosuite.tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "steps_per_action",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_all_controllers",
        "description": "robosuite.tests.test_controllers.test_all_controllers",
        "peekOfCode": "steps_per_action = 50\nsteps_per_rest = 25\ndef test_all_controllers():\n    for controller_name in controllers.keys():\n        # Define variables for each controller test\n        action_dim = controllers[controller_name][0]\n        num_test_steps = controllers[controller_name][1]\n        test_value = controllers[controller_name][2]\n        neutral = np.zeros(action_dim)\n        # Define controller path to load",
        "detail": "robosuite.tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "steps_per_rest",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_all_controllers",
        "description": "robosuite.tests.test_controllers.test_all_controllers",
        "peekOfCode": "steps_per_rest = 25\ndef test_all_controllers():\n    for controller_name in controllers.keys():\n        # Define variables for each controller test\n        action_dim = controllers[controller_name][0]\n        num_test_steps = controllers[controller_name][1]\n        test_value = controllers[controller_name][2]\n        neutral = np.zeros(action_dim)\n        # Define controller path to load\n        controller_config = load_controller_config(default_controller=controller_name)",
        "detail": "robosuite.tests.test_controllers.test_all_controllers",
        "documentation": {}
    },
    {
        "label": "step",
        "kind": 2,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "def step(env, action, current_torques):\n    env.timestep += 1\n    policy_step = True\n    summed_abs_delta_torques = np.zeros(7)\n    for i in range(int(env.control_timestep / env.model_timestep)):\n        env.sim.forward()\n        env._pre_action(action, policy_step)\n        last_torques = current_torques\n        current_torques = env.robots[0].torques\n        summed_abs_delta_torques += np.abs(current_torques - last_torques)",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "test_linear_interpolator",
        "kind": 2,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "def test_linear_interpolator():\n    for controller_name in [\"IK_POSE\", \"OSC_POSE\"]:\n        for traj in [\"pos\", \"ori\"]:\n            # Define counter to increment timesteps and torques for each trajectory\n            timesteps = [0, 0]\n            summed_abs_delta_torques = [np.zeros(7), np.zeros(7)]\n            for interpolator in [None, \"linear\"]:\n                # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory\n                np.random.seed(3)\n                # Define controller path to load",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "pos_y_threshold",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "pos_y_threshold = 0.1\ndelta_pos_y = 0.01\npos_action_osc = [0, delta_pos_y * 40, 0]\npos_action_ik = [0, delta_pos_y, 0]\n# Rotation trajectory\nrot_r_threshold = np.pi / 2\ndelta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "delta_pos_y",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "delta_pos_y = 0.01\npos_action_osc = [0, delta_pos_y * 40, 0]\npos_action_ik = [0, delta_pos_y, 0]\n# Rotation trajectory\nrot_r_threshold = np.pi / 2\ndelta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "pos_action_osc",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "pos_action_osc = [0, delta_pos_y * 40, 0]\npos_action_ik = [0, delta_pos_y, 0]\n# Rotation trajectory\nrot_r_threshold = np.pi / 2\ndelta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "pos_action_ik",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "pos_action_ik = [0, delta_pos_y, 0]\n# Rotation trajectory\nrot_r_threshold = np.pi / 2\ndelta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "rot_r_threshold",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "rot_r_threshold = np.pi / 2\ndelta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "delta_rot_r",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "delta_rot_r = 0.01\nrot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "rot_action_osc",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "rot_action_osc = [delta_rot_r * 40, 0, 0]\nrot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "rot_action_ik",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "rot_action_ik = [delta_rot_r * 5, 0, 0]\n# Concatenated thresholds and corresponding indexes (y = 1 in x,y,z; roll = 0 in r,p,y)\nthresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "thresholds",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "thresholds = [pos_y_threshold, rot_r_threshold]\nindexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Setup printing options for numbers\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.3f}\".format(x)})",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "indexes",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "indexes = [1, 0]\n# Threshold ratio\nmin_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Setup printing options for numbers\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.3f}\".format(x)})\n# function to run the actual sim in order to receive summed absolute delta torques",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "min_ratio",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "min_ratio = 1.10\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Setup printing options for numbers\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.3f}\".format(x)})\n# function to run the actual sim in order to receive summed absolute delta torques\ndef step(env, action, current_torques):\n    env.timestep += 1",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Setup printing options for numbers\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.3f}\".format(x)})\n# function to run the actual sim in order to receive summed absolute delta torques\ndef step(env, action, current_torques):\n    env.timestep += 1\n    policy_step = True\n    summed_abs_delta_torques = np.zeros(7)",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_linear_interpolator",
        "description": "robosuite.tests.test_controllers.test_linear_interpolator",
        "peekOfCode": "args = parser.parse_args()\n# Setup printing options for numbers\nnp.set_printoptions(formatter={'float': lambda x: \"{0:0.3f}\".format(x)})\n# function to run the actual sim in order to receive summed absolute delta torques\ndef step(env, action, current_torques):\n    env.timestep += 1\n    policy_step = True\n    summed_abs_delta_torques = np.zeros(7)\n    for i in range(int(env.control_timestep / env.model_timestep)):\n        env.sim.forward()",
        "detail": "robosuite.tests.test_controllers.test_linear_interpolator",
        "documentation": {}
    },
    {
        "label": "test_variable_impedance",
        "kind": 2,
        "importPath": "robosuite.tests.test_controllers.test_variable_impedance",
        "description": "robosuite.tests.test_controllers.test_variable_impedance",
        "peekOfCode": "def test_variable_impedance():\n    for controller_name in [\"OSC_POSE\", \"OSC_POSITION\", \"JOINT_POSITION\"]:\n        # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory\n        np.random.seed(3)\n        # Define controller path to load\n        controller_path = os.path.join(os.path.dirname(__file__),\n                                       '../../robosuite',\n                                       'controllers/config/{}.json'.format(controller_name.lower()))\n        # Load the controller\n        with open(controller_path) as f:",
        "detail": "robosuite.tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "num_timesteps_per_change",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_variable_impedance",
        "description": "robosuite.tests.test_controllers.test_variable_impedance",
        "peekOfCode": "num_timesteps_per_change = 10\npercent_increase = 0.05\n# Define delta values for trajectory\nd = 0.05\n# Define default values for fixing one of the two gains\nkp_default = 150\ndamping_default = 1     # critically damped\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")",
        "detail": "robosuite.tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "percent_increase",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_variable_impedance",
        "description": "robosuite.tests.test_controllers.test_variable_impedance",
        "peekOfCode": "percent_increase = 0.05\n# Define delta values for trajectory\nd = 0.05\n# Define default values for fixing one of the two gains\nkp_default = 150\ndamping_default = 1     # critically damped\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()",
        "detail": "robosuite.tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_variable_impedance",
        "description": "robosuite.tests.test_controllers.test_variable_impedance",
        "peekOfCode": "d = 0.05\n# Define default values for fixing one of the two gains\nkp_default = 150\ndamping_default = 1     # critically damped\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Running the actual test #\ndef test_variable_impedance():",
        "detail": "robosuite.tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "kp_default",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_variable_impedance",
        "description": "robosuite.tests.test_controllers.test_variable_impedance",
        "peekOfCode": "kp_default = 150\ndamping_default = 1     # critically damped\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Running the actual test #\ndef test_variable_impedance():\n    for controller_name in [\"OSC_POSE\", \"OSC_POSITION\", \"JOINT_POSITION\"]:\n        # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory",
        "detail": "robosuite.tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "damping_default",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_variable_impedance",
        "description": "robosuite.tests.test_controllers.test_variable_impedance",
        "peekOfCode": "damping_default = 1     # critically damped\n# Define arguments for this test\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Running the actual test #\ndef test_variable_impedance():\n    for controller_name in [\"OSC_POSE\", \"OSC_POSITION\", \"JOINT_POSITION\"]:\n        # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory\n        np.random.seed(3)",
        "detail": "robosuite.tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_variable_impedance",
        "description": "robosuite.tests.test_controllers.test_variable_impedance",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument(\"--render\", action=\"store_true\", help=\"Whether to render tests or run headless\")\nargs = parser.parse_args()\n# Running the actual test #\ndef test_variable_impedance():\n    for controller_name in [\"OSC_POSE\", \"OSC_POSITION\", \"JOINT_POSITION\"]:\n        # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory\n        np.random.seed(3)\n        # Define controller path to load\n        controller_path = os.path.join(os.path.dirname(__file__),",
        "detail": "robosuite.tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "robosuite.tests.test_controllers.test_variable_impedance",
        "description": "robosuite.tests.test_controllers.test_variable_impedance",
        "peekOfCode": "args = parser.parse_args()\n# Running the actual test #\ndef test_variable_impedance():\n    for controller_name in [\"OSC_POSE\", \"OSC_POSITION\", \"JOINT_POSITION\"]:\n        # Define numpy seed so we guarantee consistent starting pos / ori for each trajectory\n        np.random.seed(3)\n        # Define controller path to load\n        controller_path = os.path.join(os.path.dirname(__file__),\n                                       '../../robosuite',\n                                       'controllers/config/{}.json'.format(controller_name.lower()))",
        "detail": "robosuite.tests.test_controllers.test_variable_impedance",
        "documentation": {}
    },
    {
        "label": "test_all_environments",
        "kind": 2,
        "importPath": "robosuite.tests.test_environments.test_all_environments",
        "description": "robosuite.tests.test_environments.test_all_environments",
        "peekOfCode": "def test_all_environments():\n    envs = sorted(suite.ALL_ENVIRONMENTS)\n    for env_name in envs:\n        # Create config dict\n        env_config = {\"env_name\": env_name}\n        for robot_name in (\"Panda\", \"Sawyer\", \"Baxter\"):\n            # create an environment for learning on pixels\n            config = None\n            if \"TwoArm\" in env_name:\n                if robot_name == \"Baxter\":",
        "detail": "robosuite.tests.test_environments.test_all_environments",
        "documentation": {}
    },
    {
        "label": "test_all_gripper",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_all_grippers",
        "description": "robosuite.tests.test_grippers.test_all_grippers",
        "peekOfCode": "def test_all_gripper():\n    for name, gripper in GRIPPER_MAPPING.items():\n        # Test all grippers except the null gripper\n        if name not in {None, \"WipingGripper\"}:\n            print(\"Testing {}...\".format(name))\n            _test_gripper(gripper())\ndef _test_gripper(gripper):\n    action = gripper.format_action([1] * gripper.dof)\n    assert action is not None\n    assert gripper.init_qpos is not None",
        "detail": "robosuite.tests.test_grippers.test_all_grippers",
        "documentation": {}
    },
    {
        "label": "test_robotiq",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_jaco_threefinger",
        "description": "robosuite.tests.test_grippers.test_jaco_threefinger",
        "peekOfCode": "def test_robotiq():\n    robotiq_tester(False)\ndef robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = JacoThreeFingerGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "robosuite.tests.test_grippers.test_jaco_threefinger",
        "documentation": {}
    },
    {
        "label": "robotiq_tester",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_jaco_threefinger",
        "description": "robosuite.tests.test_grippers.test_jaco_threefinger",
        "peekOfCode": "def robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = JacoThreeFingerGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=0.01,\n        gripper_high_pos=0.1,",
        "detail": "robosuite.tests.test_grippers.test_jaco_threefinger",
        "documentation": {}
    },
    {
        "label": "test_panda_gripper",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_panda_gripper",
        "description": "robosuite.tests.test_grippers.test_panda_gripper",
        "peekOfCode": "def test_panda_gripper():\n    panda_gripper_tester(False)\ndef panda_gripper_tester(render,\n                      total_iters=1,\n                      test_y=True):\n    gripper = PandaGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "robosuite.tests.test_grippers.test_panda_gripper",
        "documentation": {}
    },
    {
        "label": "panda_gripper_tester",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_panda_gripper",
        "description": "robosuite.tests.test_grippers.test_panda_gripper",
        "peekOfCode": "def panda_gripper_tester(render,\n                      total_iters=1,\n                      test_y=True):\n    gripper = PandaGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=-0.10,\n        gripper_high_pos=0.01,",
        "detail": "robosuite.tests.test_grippers.test_panda_gripper",
        "documentation": {}
    },
    {
        "label": "test_two_finger",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_rethink_gripper",
        "description": "robosuite.tests.test_grippers.test_rethink_gripper",
        "peekOfCode": "def test_two_finger():\n    two_finger_tester(False)\ndef two_finger_tester(render,\n                      total_iters=1,\n                      test_y=True):\n    gripper = RethinkGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "robosuite.tests.test_grippers.test_rethink_gripper",
        "documentation": {}
    },
    {
        "label": "two_finger_tester",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_rethink_gripper",
        "description": "robosuite.tests.test_grippers.test_rethink_gripper",
        "peekOfCode": "def two_finger_tester(render,\n                      total_iters=1,\n                      test_y=True):\n    gripper = RethinkGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=-0.07,\n        gripper_high_pos=0.02,",
        "detail": "robosuite.tests.test_grippers.test_rethink_gripper",
        "documentation": {}
    },
    {
        "label": "test_robotiq",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_robotiq_140",
        "description": "robosuite.tests.test_grippers.test_robotiq_140",
        "peekOfCode": "def test_robotiq():\n    robotiq_tester(False)\ndef robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = Robotiq140Gripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "robosuite.tests.test_grippers.test_robotiq_140",
        "documentation": {}
    },
    {
        "label": "robotiq_tester",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_robotiq_140",
        "description": "robosuite.tests.test_grippers.test_robotiq_140",
        "peekOfCode": "def robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = Robotiq140Gripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=0.02,\n        gripper_high_pos=0.1,",
        "detail": "robosuite.tests.test_grippers.test_robotiq_140",
        "documentation": {}
    },
    {
        "label": "test_robotiq",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_robotiq_85",
        "description": "robosuite.tests.test_grippers.test_robotiq_85",
        "peekOfCode": "def test_robotiq():\n    robotiq_tester(False)\ndef robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = Robotiq85Gripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"-0.02 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "robosuite.tests.test_grippers.test_robotiq_85",
        "documentation": {}
    },
    {
        "label": "robotiq_tester",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_robotiq_85",
        "description": "robosuite.tests.test_grippers.test_robotiq_85",
        "peekOfCode": "def robotiq_tester(render,\n                   total_iters=1,\n                   test_y=True):\n    gripper = Robotiq85Gripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"-0.02 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=-0.065,\n        gripper_high_pos=0.01,",
        "detail": "robosuite.tests.test_grippers.test_robotiq_85",
        "documentation": {}
    },
    {
        "label": "test_robotiq_three_finger",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_robotiq_threefinger",
        "description": "robosuite.tests.test_grippers.test_robotiq_threefinger",
        "peekOfCode": "def test_robotiq_three_finger():\n    robotiq_three_finger_tester(False)\ndef robotiq_three_finger_tester(render,\n                                total_iters=1,\n                                test_y=True):\n    gripper = RobotiqThreeFingerGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",",
        "detail": "robosuite.tests.test_grippers.test_robotiq_threefinger",
        "documentation": {}
    },
    {
        "label": "robotiq_three_finger_tester",
        "kind": 2,
        "importPath": "robosuite.tests.test_grippers.test_robotiq_threefinger",
        "description": "robosuite.tests.test_grippers.test_robotiq_threefinger",
        "peekOfCode": "def robotiq_three_finger_tester(render,\n                                total_iters=1,\n                                test_y=True):\n    gripper = RobotiqThreeFingerGripper()\n    tester = GripperTester(\n        gripper=gripper,\n        pos=\"0 0 0.3\",\n        quat=\"0 0 1 0\",\n        gripper_low_pos=-0.02,\n        gripper_high_pos=0.1,",
        "detail": "robosuite.tests.test_grippers.test_robotiq_threefinger",
        "documentation": {}
    },
    {
        "label": "this_directory",
        "kind": 5,
        "importPath": "robosuite.setup",
        "description": "robosuite.setup",
        "peekOfCode": "this_directory = path.abspath(path.dirname(__file__))\nwith open(path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    lines = f.readlines()\n# remove images from README\nlines = [x for x in lines if '.png' not in x]\nlong_description = ''.join(lines)\nsetup(\n    name=\"robosuite\",\n    packages=[\n        package for package in find_packages() if package.startswith(\"robosuite\")",
        "detail": "robosuite.setup",
        "documentation": {}
    },
    {
        "label": "lines",
        "kind": 5,
        "importPath": "robosuite.setup",
        "description": "robosuite.setup",
        "peekOfCode": "lines = [x for x in lines if '.png' not in x]\nlong_description = ''.join(lines)\nsetup(\n    name=\"robosuite\",\n    packages=[\n        package for package in find_packages() if package.startswith(\"robosuite\")\n    ],\n    install_requires=[\n        \"numpy>=1.13.3\",\n        \"numba>=0.49.1\",",
        "detail": "robosuite.setup",
        "documentation": {}
    },
    {
        "label": "long_description",
        "kind": 5,
        "importPath": "robosuite.setup",
        "description": "robosuite.setup",
        "peekOfCode": "long_description = ''.join(lines)\nsetup(\n    name=\"robosuite\",\n    packages=[\n        package for package in find_packages() if package.startswith(\"robosuite\")\n    ],\n    install_requires=[\n        \"numpy>=1.13.3\",\n        \"numba>=0.49.1\",\n        \"scipy>=1.2.3\",",
        "detail": "robosuite.setup",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "kind": 6,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "class AttrDict(dict):\n    def __init__(self, *args, **kwargs):\n        super(AttrDict, self).__init__(*args, **kwargs)\n        self.__dict__ = self\ndef unique(l):\n    return list(set(l))\ndef flatten(l):\n    return [item for sublist in l for item in sublist]\ndef load_progress(progress_csv_path):\n    print(\"Reading %s\" % progress_csv_path)",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "Selector",
        "kind": 6,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "class Selector(object):\n    def __init__(self, exps_data, filters=None, custom_filters=None):\n        self._exps_data = exps_data\n        if filters is None:\n            self._filters = tuple()\n        else:\n            self._filters = tuple(filters)\n        if custom_filters is None:\n            self._custom_filters = []\n        else:",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "unique",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def unique(l):\n    return list(set(l))\ndef flatten(l):\n    return [item for sublist in l for item in sublist]\ndef load_progress(progress_csv_path):\n    print(\"Reading %s\" % progress_csv_path)\n    entries = dict()\n    if progress_csv_path.split('.')[-1] == \"csv\":\n        delimiter = ','\n    else:",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "flatten",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def flatten(l):\n    return [item for sublist in l for item in sublist]\ndef load_progress(progress_csv_path):\n    print(\"Reading %s\" % progress_csv_path)\n    entries = dict()\n    if progress_csv_path.split('.')[-1] == \"csv\":\n        delimiter = ','\n    else:\n        delimiter = '\\t'\n    with open(progress_csv_path, 'r') as csvfile:",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "load_progress",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def load_progress(progress_csv_path):\n    print(\"Reading %s\" % progress_csv_path)\n    entries = dict()\n    if progress_csv_path.split('.')[-1] == \"csv\":\n        delimiter = ','\n    else:\n        delimiter = '\\t'\n    with open(progress_csv_path, 'r') as csvfile:\n        reader = csv.DictReader(csvfile, delimiter=delimiter)\n        for row in reader:",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "to_json",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def to_json(stub_object):\n    from rllab.misc.instrument import StubObject\n    from rllab.misc.instrument import StubAttr\n    if isinstance(stub_object, StubObject):\n        assert len(stub_object.args) == 0\n        data = dict()\n        for k, v in stub_object.kwargs.items():\n            data[k] = to_json(v)\n        data[\"_name\"] = stub_object.proxy_class.__module__ + \\\n                        \".\" + stub_object.proxy_class.__name__",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "flatten_dict",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def flatten_dict(d):\n    flat_params = dict()\n    for k, v in d.items():\n        if isinstance(v, dict):\n            v = flatten_dict(v)\n            for subk, subv in flatten_dict(v).items():\n                flat_params[k + \".\" + subk] = subv\n        else:\n            flat_params[k] = v\n    return flat_params",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "load_params",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def load_params(params_json_path):\n    with open(params_json_path, 'r') as f:\n        data = json.loads(f.read())\n        if \"args_data\" in data:\n            del data[\"args_data\"]\n        if \"exp_name\" not in data:\n            data[\"exp_name\"] = params_json_path.split(\"/\")[-2]\n    return data\ndef lookup(d, keys):\n    if not isinstance(keys, list):",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "lookup",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def lookup(d, keys):\n    if not isinstance(keys, list):\n        keys = keys.split(\".\")\n    for k in keys:\n        if hasattr(d, \"__getitem__\"):\n            if k in d:\n                d = d[k]\n            else:\n                return None\n        else:",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "load_exps_data",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def load_exps_data(\n        exp_folder_paths,\n        data_filename='progress.csv',\n        params_filename='params.json',\n        disable_variant=False,\n):\n    exps = []\n    for exp_folder_path in exp_folder_paths:\n        exps += [x[0] for x in os.walk(exp_folder_path)]\n    exps_data = []",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "smart_repr",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def smart_repr(x):\n    if isinstance(x, tuple):\n        if len(x) == 0:\n            return \"tuple()\"\n        elif len(x) == 1:\n            return \"(%s,)\" % smart_repr(x[0])\n        else:\n            return \"(\" + \",\".join(map(smart_repr, x)) + \")\"\n    elif isinstance(x, list):\n        if len(x) == 0:",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "smart_eval",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def smart_eval(string):\n    string = string.replace(',inf)', ',\"inf\")')\n    return eval(string)\ndef extract_distinct_params(exps_data, excluded_params=('seed', 'log_dir'), l=1):\n    # all_pairs = unique(flatten([d.flat_params.items() for d in exps_data]))\n    # if logger:\n    #     logger(\"(Excluding {excluded})\".format(excluded=', '.join(excluded_params)))\n    # def cmp(x,y):\n    #     if x < y:\n    #         return -1",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "extract_distinct_params",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def extract_distinct_params(exps_data, excluded_params=('seed', 'log_dir'), l=1):\n    # all_pairs = unique(flatten([d.flat_params.items() for d in exps_data]))\n    # if logger:\n    #     logger(\"(Excluding {excluded})\".format(excluded=', '.join(excluded_params)))\n    # def cmp(x,y):\n    #     if x < y:\n    #         return -1\n    #     elif x > y:\n    #         return 1\n    #     else:",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "exp_has_key_value",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def exp_has_key_value(exp, k, v):\n    return (\n        str(exp.flat_params.get(k, None)) == str(v)\n        # TODO: include this?\n        or (k not in exp.flat_params)\n    )\nclass Selector(object):\n    def __init__(self, exps_data, filters=None, custom_filters=None):\n        self._exps_data = exps_data\n        if filters is None:",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "hex_to_rgb",
        "kind": 2,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "def hex_to_rgb(hex, opacity=1.0):\n    if hex[0] == '#':\n        hex = hex[1:]\n    assert (len(hex) == 6)\n    return \"rgba({0},{1},{2},{3})\".format(int(hex[:2], 16), int(hex[2:4], 16), int(hex[4:6], 16), opacity)",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "color_defaults",
        "kind": 5,
        "importPath": "viskit.viskit.core",
        "description": "viskit.viskit.core",
        "peekOfCode": "color_defaults = [\n    '#1f77b4',  # muted blue\n    '#ff7f0e',  # safety orange\n    '#2ca02c',  # cooked asparagus green\n    '#d62728',  # brick red\n    '#9467bd',  # muted purple\n    '#8c564b',  # chestnut brown\n    '#e377c2',  # raspberry yogurt pink\n    '#7f7f7f',  # middle gray\n    '#bcbd22',  # curry yellow-green",
        "detail": "viskit.viskit.core",
        "documentation": {}
    },
    {
        "label": "flatten",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def flatten(xs):\n    return [x for y in xs for x in y]\ndef sliding_mean(data_array, window=5):\n    data_array = np.array(data_array)\n    new_list = []\n    for i in range(len(data_array)):\n        indices = list(range(max(i - window + 1, 0),\n                             min(i + window + 1, len(data_array))))\n        avg = 0\n        for j in indices:",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "sliding_mean",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def sliding_mean(data_array, window=5):\n    data_array = np.array(data_array)\n    new_list = []\n    for i in range(len(data_array)):\n        indices = list(range(max(i - window + 1, 0),\n                             min(i + window + 1, len(data_array))))\n        avg = 0\n        for j in indices:\n            avg += data_array[j]\n        avg /= float(len(indices))",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "send_js",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def send_js(path):\n    return flask.send_from_directory('js', path)\n@app.route('/css/<path:path>')\ndef send_css(path):\n    return flask.send_from_directory('css', path)\ndef create_bar_chart(\n        plot_lists,\n        use_median=False,\n        plot_width=None,\n        plot_height=None,",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "send_css",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def send_css(path):\n    return flask.send_from_directory('css', path)\ndef create_bar_chart(\n        plot_lists,\n        use_median=False,\n        plot_width=None,\n        plot_height=None,\n        title=None,\n        value_i=-1,\n    ):",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "create_bar_chart",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def create_bar_chart(\n        plot_lists,\n        use_median=False,\n        plot_width=None,\n        plot_height=None,\n        title=None,\n        value_i=-1,\n    ):\n    \"\"\"\n    plot_lists is a list of lists.",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "make_plot",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def make_plot(\n        plot_lists,\n        use_median=False,\n        plot_width=None,\n        plot_height=None,\n        title=None,\n    ):\n    \"\"\"\n    plot_lists is a list of lists.\n    Each outer list represents different y-axis attributes.",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "make_plot_eps",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def make_plot_eps(plot_list, use_median=False, counter=0):\n    import matplotlib.pyplot as _plt\n    f, ax = _plt.subplots(figsize=(8, 5))\n    for idx, plt in enumerate(plot_list):\n        color = core.color_defaults[idx % len(core.color_defaults)]\n        if use_median:\n            x = list(range(len(plt.percentile50)))\n            y = list(plt.percentile50)\n            y_upper = list(plt.percentile75)\n            y_lower = list(plt.percentile25)",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "summary_name",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def summary_name(exp, selector=None):\n    # if selector is not None:\n    #     exclude_params = set([x[0] for x in selector._filters])\n    # else:\n    #     exclude_params = set()\n    # rest_params = set([x[0] for x in distinct_params]).difference(exclude_params)\n    # if len(rest_params) > 0:\n    #     name = \"\"\n    #     for k in rest_params:\n    #         name += \"%s=%s;\" % (k.split(\".\")[-1], str(exp.flat_params.get(k, \"\")).split(\".\")[-1])",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "check_nan",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def check_nan(exp):\n    return all(\n        not np.any(np.isnan(vals)) for vals in list(exp.progress.values()))\ndef get_plot_instruction(\n        plot_keys,\n        x_keys=None,\n        split_keys=None,\n        group_keys=None,\n        best_filter_key=None,\n        filters=None,",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "get_plot_instruction",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def get_plot_instruction(\n        plot_keys,\n        x_keys=None,\n        split_keys=None,\n        group_keys=None,\n        best_filter_key=None,\n        filters=None,\n        exclusions=None,\n        use_median=False,\n        only_show_best=False,",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "shorten_key",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def shorten_key(key):\n    \"\"\"\n    Convert a dot-map string like \"foo.bar.baz\" into \"f.b.baz\"\n    \"\"\"\n    *heads, tail = key.split(\".\")\n    new_key_builder = []\n    for subkey in heads:\n        if len(subkey) > 0:\n            new_key_builder.append(subkey[0])\n    new_key_builder.append(tail)",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "get_selector_score",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def get_selector_score(key, selector, use_median, best_based_on_final):\n    \"\"\"\n    :param key: Thing to measure (e.g. Average Returns, Loss, etc.)\n    :param selector: Selector instance\n    :param use_median: Use the median? Else use the mean\n    :param best_based_on_final: Only look at the final value? Else use all\n    values.\n    :return: A single number that gives the score of `key` inside `selector`\n    \"\"\"\n    data = selector.extract()",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "get_statistics",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def get_statistics(progresses, use_median, normalize_errors):\n    \"\"\"\n    Get some dictionary of statistics (e.g. the median, mean).\n    :param progresses:\n    :param use_median:\n    :param normalize_errors:\n    :return:\n    \"\"\"\n    if use_median:\n        return dict(",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "process_statistics",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def process_statistics(\n        statistics,\n        smooth_curve,\n        clip_plot_value,\n        window_size\n):\n    \"\"\"\n    Smoothen and clip time-series data.\n    \"\"\"\n    clean_statistics = {}",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "get_possible_values",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def get_possible_values(distinct_params, key):\n    return [vs for k, vs in distinct_params if k == key][0]\ndef split_by_key(selector, key, distinct_params):\n    \"\"\"\n    Return a list of selectors based on this selector.\n    Each selector represents one distinct value of `key`.\n    \"\"\"\n    values = get_possible_values(distinct_params, key)\n    return [selector.where(key, v) for v in values]\ndef split_by_keys(base_selector, keys, distinct_params):",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "split_by_key",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def split_by_key(selector, key, distinct_params):\n    \"\"\"\n    Return a list of selectors based on this selector.\n    Each selector represents one distinct value of `key`.\n    \"\"\"\n    values = get_possible_values(distinct_params, key)\n    return [selector.where(key, v) for v in values]\ndef split_by_keys(base_selector, keys, distinct_params):\n    \"\"\"\n    Return a list of selectors based on the base_selector.",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "split_by_keys",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def split_by_keys(base_selector, keys, distinct_params):\n    \"\"\"\n    Return a list of selectors based on the base_selector.\n    Each selector represents one distinct set of values for each key in `keys`.\n    :param base_selector:\n    :param keys:\n    :param distinct_params:\n    :return:\n    \"\"\"\n    list_of_key_and_unique_value = [",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "parse_float_arg",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def parse_float_arg(args, key):\n    x = args.get(key, \"\")\n    try:\n        return float(x)\n    except Exception:\n        return None\n@app.route(\"/plot_div\")\ndef plot_div():\n    args = flask.request.args\n    plot_keys_json = args.get(\"plot_keys\")",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "plot_div",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def plot_div():\n    args = flask.request.args\n    plot_keys_json = args.get(\"plot_keys\")\n    plot_keys = json.loads(plot_keys_json)\n    x_keys_json = args.get(\"x_keys\")\n    x_keys = json.loads(x_keys_json)\n    split_keys_json = args.get(\"split_keys\", \"[]\")\n    split_keys = json.loads(split_keys_json)\n    group_keys_json = args.get(\"group_keys\", \"[]\")\n    group_keys = json.loads(group_keys_json)",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "safer_eval",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def safer_eval(some_string):\n    \"\"\"\n    Not full-proof, but taking advice from:\n    https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html\n    \"\"\"\n    if \"__\" in some_string or \"import\" in some_string:\n        raise Exception(\"string to eval looks suspicious\")\n    return eval(some_string, {'__builtins__': {}})\n@app.route(\"/\")\ndef index():",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def index():\n    if \"AverageReturn\" in plottable_keys:\n        plot_keys = [\"AverageReturn\"]\n    elif 'training/return-average' in plottable_keys:\n        plot_keys = ['training/return-average']\n    elif len(plottable_keys) > 0:\n        plot_keys = plottable_keys[0:1]\n    else:\n        plot_keys = None\n    plot_div = get_plot_instruction(plot_keys=plot_keys)",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "reload",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def reload():\n    reload_data()\n    return 'Reloaded'\ndef reload_data():\n    global exps_data\n    global plottable_keys\n    global distinct_params\n    exps_data = core.load_exps_data(\n        args.data_paths,\n        args.data_filename,",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "reload_data",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def reload_data():\n    global exps_data\n    global plottable_keys\n    global distinct_params\n    exps_data = core.load_exps_data(\n        args.data_paths,\n        args.data_filename,\n        args.params_filename,\n        args.disable_variant,\n    )",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "def main():\n    global args\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"data_paths\", type=str, nargs='*')\n    parser.add_argument(\"--prefix\", type=str, nargs='?', default=\"???\")\n    parser.add_argument(\"--debug\", action=\"store_true\", default=False)\n    parser.add_argument(\"--port\", type=int, default=5000)\n    parser.add_argument(\"--disable-variant\", default=False, action='store_true')\n    parser.add_argument(\"--data-filename\",\n                        default='progress.csv',",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "named_colors",
        "kind": 5,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "named_colors = [\n    'dodgerblue',\n    'darkorange',\n    'green',\n    'cyan',\n    'magenta',\n    'orange',\n    'yellow',\n    'black',\n    'blue',",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "app = flask.Flask(__name__, static_url_path='/static')\nexps_data = None\nplottable_keys = None\ndistinct_params = None\n@app.route('/js/<path:path>')\ndef send_js(path):\n    return flask.send_from_directory('js', path)\n@app.route('/css/<path:path>')\ndef send_css(path):\n    return flask.send_from_directory('css', path)",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "exps_data",
        "kind": 5,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "exps_data = None\nplottable_keys = None\ndistinct_params = None\n@app.route('/js/<path:path>')\ndef send_js(path):\n    return flask.send_from_directory('js', path)\n@app.route('/css/<path:path>')\ndef send_css(path):\n    return flask.send_from_directory('css', path)\ndef create_bar_chart(",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "plottable_keys",
        "kind": 5,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "plottable_keys = None\ndistinct_params = None\n@app.route('/js/<path:path>')\ndef send_js(path):\n    return flask.send_from_directory('js', path)\n@app.route('/css/<path:path>')\ndef send_css(path):\n    return flask.send_from_directory('css', path)\ndef create_bar_chart(\n        plot_lists,",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "distinct_params",
        "kind": 5,
        "importPath": "viskit.viskit.frontend",
        "description": "viskit.viskit.frontend",
        "peekOfCode": "distinct_params = None\n@app.route('/js/<path:path>')\ndef send_js(path):\n    return flask.send_from_directory('js', path)\n@app.route('/css/<path:path>')\ndef send_css(path):\n    return flask.send_from_directory('css', path)\ndef create_bar_chart(\n        plot_lists,\n        use_median=False,",
        "detail": "viskit.viskit.frontend",
        "documentation": {}
    },
    {
        "label": "REQUIRED_PACKAGES",
        "kind": 5,
        "importPath": "viskit.setup",
        "description": "viskit.setup",
        "peekOfCode": "REQUIRED_PACKAGES = ['Flask==2.0.1', 'matplotlib', 'plotly==5.1.0', 'numpy', 'Jinja2>=3.0']\nsetup(name='viskit',\n    version='0.1',\n    install_requires=REQUIRED_PACKAGES,\n    include_package_data=True,\n    package_data={\n        'viskit': ['static/css/*', 'static/js/*', 'templates/main.html'],\n    },\n    packages=[p for p in find_packages() if p.startswith('viskit')],\n    description=\"rllab's viskit with some added features\")",
        "detail": "viskit.setup",
        "documentation": {}
    }
]